<Chapter><Heading> <M>FpG</M>-modules</Heading>

<Section><Heading> &nbsp;</Heading>

<ManSection>

<Var Name="CompositionSeriesOfFpGModules"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and 
 returns a list of <M>FpG</M>-modules that constitute a composition series for <M>M</M>.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="DirectSumOfFpGModules" Arg="M,N"/>
 
<Func Name="DirectSumOfFpGModules" Arg="[ M[1], M[2], ..., M[k] ]"/>
<Description>
<P/>

Inputs two <M>FpG</M>-modules <M>M</M> and <M>N</M> 
with common group and characteristic. It returns the direct sum of 
<M>M</M> and <M>N</M> as an <M>FpG</M>-Module.
<P/>
Alternatively, the function can input a list of <M>FpG</M>-modules 
with common group <M>G</M>. It returns the direct sum of the list.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="FpGModule" Arg="A,P"/>

<Func Name="FpGModule" Arg="A,G,p"/>
<Description>
<P/>

Inputs a <M>p</M>-group <M>P</M> and a matrix <M>A</M> 
whose rows have length a multiple of the order of <M>G</M>. 
It returns the <Quoted>canonical</Quoted>
<M>FpG</M>-module generated by the rows of <M>A</M>.

<P/>
A small non-prime-power group <M>G</M> can also be input, provided the characteristic <M>p</M> is entered as a third input variable. 
<P/><B>Examples:</B> <URL><Link>../www/SideLinks/About/aboutAbelianCategories.html</Link><LinkText>1</LinkText></URL>&nbsp;,
<URL><Link>../www/SideLinks/About/aboutIntro.html</Link><LinkText>2</LinkText></URL>&nbsp;,
<URL><Link>../www/SideLinks/About/aboutTorAndExt.html</Link><LinkText>3</LinkText></URL>&nbsp; 

</Description>





















































































</ManSection>

<ManSection>

<Func Name="FpGModuleDualBasis" Arg="M"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module <M>M</M>. It returns a record 
<M>R</M> with two components:
<List>
<Item><M>R.freeModule</M> is the free module <M>FG</M> of rank one.</Item>
<Item><M>R.basis</M> is a list representing an <M>F</M>-basis 
for the module <M>Hom_{FG}(M,FG)</M>. Each term in the 
list is a matrix <M>A</M> whose rows are vectors in <M>FG</M> 
such that  <M>M!.generators[i] \longrightarrow A[i]</M>  
extends to a module homomorphism <M>M \longrightarrow FG</M>.
	</Item>
	</List>
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="FpGModuleHomomorphism" Arg="M,N,A"/>

<Func Name="FpGModuleHomomorphismNC" Arg="M,N,A"/>
<Description>
<P/>

Inputs <M>FpG</M>-modules <M>M</M> and <M>N</M> over a common <M>p</M>-group <M>G</M>. 
Also inputs a list <M>A</M> of vectors in the vector space spanned by 
<M>N!.matrix</M>. It tests that the function
<P/>
<M> M!.generators[i] \longrightarrow A[i]</M>
<P/>
 extends to a homomorphism of <M>FpG</M>-modules and, 
 if the test is passed, returns the corresponding <M>FpG</M>-module 
 homomorphism. If the test is failed it returns fail.
<P/>
 The "NC" version of the function assumes that the input 
 defines a homomorphism and simply returns the <M>FpG</M>-module homomorphism.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>
<ManSection>

<Func Name="DesuspensionFpGModule" Arg="M,n"/>

<Func Name="DesuspensionFpGModule" Arg="R,n"/>
<Description>
<P/>

Inputs a positive integer <M>n</M> and and FpG-module <M>M</M>. It returns an 
FpG-module <M>D^nM</M> which is mathematically related to <M>M</M> via
 an exact sequence
 <M> 0 \longrightarrow D^nM \longrightarrow R_n \longrightarrow \ldots
 \longrightarrow R_0 \longrightarrow M \longrightarrow 0</M> where <M>R_\ast</M>
 is a free resolution.
 (If <M>G=Group(M)</M> is of prime-power order then the resolution is minimal.)

<P/>
Alternatively, the function can input a positive integer <M>n</M>
and at least <M>n</M> terms of a free 
resolution <M>R</M> of <M>M</M>.

<P/><B>Examples:</B> 
</Description>





















































































</ManSection>
<ManSection>

<Func Name="RadicalOfFpGModule" Arg="M"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> with <M>G</M> a <M>p</M>-group, and returns the Radical of 
<M>M</M> as an <M>FpG</M>-module. (Ig <M>G</M> is not a <M>p</M>-group then a submodule of the radical is returned.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="RadicalSeriesOfFpGModule" Arg="M"/>
<Description>
 <P/>

Inputs an <M>FpG</M>-module <M>M</M> and
 returns a list of <M>FpG</M>-modules that constitute the radical
 series for <M>M</M>.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="GeneratorsOfFpGModule" Arg="M"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and returns a matrix whose 
rows correspond to a  minimal generating set for <M>M</M>. 
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>
<ManSection>

<Func Name="ImageOfFpGModuleHomomorphism" Arg="f"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module homomorphism <M>f:M \longrightarrow N</M>
and returns its image <M>f(M)</M> as an <M>FpG</M>-module. 
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="GroupAlgebraAsFpGModule" Arg="G"/>
<Description>
 <P/>

Inputs a <M>p</M>-group <M>G</M> and
 returns its mod <M>p</M> group algebra as an <M>FpG</M>-module.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="IntersectionOfFpGModules" Arg="M,N"/>
<Description>
<P/>

Inputs two <M>FpG</M>-modules <M>M, N</M> arising as submodules in a 
common free module <M>(FG)^n</M> where <M>G</M> is a  finite group and 
<M>F</M> the field of <M>p</M>-elements. It returns the <M>FpG</M>-module
arising as the intersection of <M>M</M> and <M>N</M>.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="IsFpGModuleHomomorphismData" Arg="M,N,A"/>
<Description>
<P/>

Inputs <M>FpG</M>-modules <M>M</M> and <M>N</M> over a common <M>p</M>-group <M>G</M>. 
Also inputs a list <M>A</M> of vectors in the vector space spanned by 
<M>N!.matrix</M>. It returns true if the function
<P/>
<M> M!.generators[i] \longrightarrow A[i]</M>
<P/>
 extends to a homomorphism of <M>FpG</M>-modules. Otherwise it 
 returns false.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="MaximalSubmoduleOfFpGModule" Arg="M"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and
 returns one maximal <M>FpG</M>-submodule of <M>M</M>.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="MaximalSubmodulesOfFpGModule" Arg="M"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and
 returns the list of maximal <M>FpG</M>-submodules of <M>M</M>.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="MultipleOfFpGModule" Arg="w,M"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and a list 
<M>w:=[g_1 , ..., g_t]</M> of elements in the group <M>G=M!.group</M>. 
The list <M>w</M> can be thought of as representing the element 
<M>w=g_1 + \ldots + g_t</M> in the group algebra <M>FG</M>, 
and the function returns a semi-echelon matrix <M>B</M> 
which is a basis for the vector subspace <M>wM</M> .
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>
<ManSection>

<Func Name="ProjectedFpGModule" Arg="M,k"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> of ambient dimension <M>n|G|</M>, 
and an integer <M>k</M> between <M>1</M> and <M>n</M>. The module 
<M>M</M> is a submodule of the free module <M>(FG)^n</M> . Let 
<M>M_k</M> denote the  intersection of <M>M</M> with the last <M>k</M> 
summands of <M>(FG)^n</M> .  
The function returns the image of the 
projection of <M>M_k</M> onto the <M>k</M>-th summand of <M>(FG)^n</M> . This 
image is returned  an <M>FpG</M>-module with 
ambient dimension <M>|G|</M>.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>
<ManSection>

<Func Name="RandomHomomorphismOfFpGModules" Arg="M,N"/>
<Description>
<P/>

Inputs two <M>FpG</M>-modules <M>M</M> and <M>N</M> over a common group 
<M>G</M>. It returns a random matrix <M>A</M> whose rows are vectors in 
<M>N</M> such that the function
<P/>
<M> M!.generators[i] \longrightarrow A[i]</M>
<P/>
 extends to a homomorphism <M>M \longrightarrow N</M> of <M>FpG</M>-modules.
 (There is a problem with this function at present.)
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>
<ManSection>

<Func Name="Rank" Arg="f"/>
<Description>
<P/>

Inputs an <M>FpG</M>-module homomorphism <M>f:M \longrightarrow N</M>
and returns the dimension of the image of <M>f</M> as a vector 
space over the field <M>F</M> of <M>p</M> elements.
<P/><B>Examples:</B> <URL><Link>../www/SideLinks/About/aboutPeriodic.html</Link><LinkText>1</LinkText></URL>&nbsp; 

</Description>





















































































</ManSection>
<ManSection>

<Func Name="SumOfFpGModules" Arg="M,N"/>
<Description>
<P/>

Inputs two <M>FpG</M>-modules <M>M, N</M> arising as submodules in 
a common free module <M>(FG)^n</M> where <M>G</M> is a finite group 
and <M>F</M> the field of <M>p</M>-elements. It returns the 
<M>FpG</M>-Module arising as the sum of <M>M</M> and <M>N</M>.
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>
<ManSection>

<Func Name="SumOp" Arg="f,g"/>
<Description>
<P/>

Inputs two <M>FpG</M>-module homomorphisms <M>f,g:M \longrightarrow N</M>
with common sorce and common target. It returns the sum <M>f+g:M \longrightarrow N</M> . (This operation is also available using "+".
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

<ManSection>

<Func Name="VectorsToFpGModuleWords" Arg="M,L"/>
<Description>
 <P/>

Inputs an <M>FpG</M>-module <M>M</M> and a list 
<M>L=[v_1,\ldots ,v_k]</M> of vectors in <M>M</M>. 
It returns a list <M>L'= [x_1,...,x_k]</M> . Each 
<M>x_j=[[W_1,G_1],...,[W_t,G_t]]</M> 
is a list of integer pairs corresponding to an expression of 
<M>v_j</M> as a word
 <P/>
<M>  v_j  = g_1*w_1 + g_2*w_1 + ... + g_t*w_t </M>

<P/>
where

<P/>

<M>g_i=Elements(M!.group)[G_i]</M>
<P/>
<M>w_i=GeneratorsOfFpGModule(M)[W_i]</M>
 .

	  
<P/><B>Examples:</B> 
</Description>





















































































</ManSection>

</Section>
</Chapter>

