<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (HAP commands) - Chapter 5: Topological data analysis</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap5"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap5_mj.html">[MathJax on]</a></p>
<p><a id="X7B7E077887694A9F" name="X7B7E077887694A9F"></a></p>
<div class="ChapSects"><a href="chap5.html#X7B7E077887694A9F">5 <span class="Heading">Topological data analysis</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X80A70B20873378E0">5.1 <span class="Heading">Persistent homology  </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X7D512DA37F789B4C">5.1-1 <span class="Heading">Background to the data</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X849556107A23FF7B">5.2 <span class="Heading">Mapper clustering</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X7D512DA37F789B4C">5.2-1 <span class="Heading">Background to the data</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X79616D12822FDB9A">5.3 <span class="Heading">Digital image analysis and persistent homology</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X8066F9B17B78418E">5.3-1 <span class="Heading">Naive example of image segmentation by automatic thresholding</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X7D512DA37F789B4C">5.3-2 <span class="Heading">Background to the data</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X7A8224DA7B00E0D9">5.4 <span class="Heading">A second example of digital image segmentation</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X7D2CC9CB85DF1BAF">5.5 <span class="Heading">Alternative approaches to computing persistent homology</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X86FD0A867EC9E64F">5.5-1 <span class="Heading">Non-trivial cup product</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X87AF06677F05C624">5.6 <span class="Heading">Random simplicial complexes</span></a>
</span>
</div>
</div>

<h3>5 <span class="Heading">Topological data analysis</span></h3>

<p><a id="X80A70B20873378E0" name="X80A70B20873378E0"></a></p>

<h4>5.1 <span class="Heading">Persistent homology  </span></h4>

<p>Pairwise distances between <span class="SimpleMath">74</span> points from some metric space have been recorded and stored in a <span class="SimpleMath">74× 74</span> matrix <span class="SimpleMath">D</span>. The following commands load the matrix, construct a filtration of length <span class="SimpleMath">100</span> on the first two dimensions of the assotiated clique complex (also known as the <em>Rips Complex</em>), and display the resulting degree <span class="SimpleMath">0</span> persistent homology as a barcode. A single bar with label <span class="SimpleMath">n</span> denotes <span class="SimpleMath">n</span> bars with common starting point and common end point.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">file:=HapFile("data253a.txt");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Read(file);</span>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:=SymmetricMatrixToFilteredGraph(D,100);</span>
Filtered graph on 74 vertices.

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K:=FilteredRegularCWComplex(CliqueComplex(G,2));</span>
Filtered regular CW-complex of dimension 2

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=PersistentBettiNumbers(K,0);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BarCodeCompactDisplay(P);</span>

</pre></div>

<p><img src="images/bar0.png" align="center" height="60" alt="degree 0 barcode"/></p>

<p>The next commands display the resulting degree <span class="SimpleMath">1</span> persistent homology as a barcode.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=PersistentBettiNumbers(K,1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BarCodeCompactDisplay(P);</span>

</pre></div>

<p><img src="images/bar1.png" align="center" height="120" alt="degree 1 bar code"/></p>

<p>The following command displays the <span class="SimpleMath">1</span> skeleton of the simplicial complex arizing as the <span class="SimpleMath">65</span>-th term in the filtration on the clique complex.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y:=FiltrationTerm(K,65);</span>
Regular CW-complex of dimension 1

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(HomotopyGraph(Y));</span>

</pre></div>

<p><img src="images/twocircles.png" align="center" height="300" alt="1-skeleton"/></p>

<p>These computations suuggest that the dataset contains two persistent path components (or clusters), and that each path component is in some sense periodic. The final command displays one possible representation of the data as points on two circles.</p>

<p><a id="X7D512DA37F789B4C" name="X7D512DA37F789B4C"></a></p>

<h5>5.1-1 <span class="Heading">Background to the data</span></h5>

<p>Each point in the dataset was an image consisting of <span class="SimpleMath">732× 761</span> pixels. This point was regarded as a vector in <span class="SimpleMath">R^732× 761</span> and the matrix <span class="SimpleMath">D</span> was constructed using the Euclidean metric. The images were the following:</p>

<p><img src="images/letters.png" align="center" height="220" alt="letters"/></p>

<p><a id="X849556107A23FF7B" name="X849556107A23FF7B"></a></p>

<h4>5.2 <span class="Heading">Mapper clustering</span></h4>

<p>The following example reads in a set <span class="SimpleMath">S</span> of vectors of rational numbers. It uses the Euclidean distance <span class="SimpleMath">d(u,v)</span> between vectors. It fixes some vector $u_0\in S$ and uses the associated function <span class="SimpleMath">f: D→ [0,b] ⊂ R, v↦ d(u_0,v)</span>. In addition, it uses an open cover of the interval <span class="SimpleMath">[0,b]</span> consisting of <span class="SimpleMath">100</span> uniformly distributed overlapping open subintervals of radius <span class="SimpleMath">r=29</span>. It also uses a simple clustering algorithm implemented in the function <code class="code">cluster</code>.</p>

<p>These ingredients are input into the Mapper clustering procedure to produce a simplicial complex <span class="SimpleMath">M</span> which is intended to be a representation of the data. The complex <span class="SimpleMath">M</span> is <span class="SimpleMath">1</span>-dimensional and the final command uses GraphViz software to visualize the graph. The nodes of this simplicial complex are "buckets" containing data points. A data point may reside in several buckets. The number of points in the bucket determines the size of the node. Two nodes are connected by an edge when their end-point nodes contain common data points.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">file:=HapFile("data134.txt");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Read(file);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dx:=EuclideanApproximatedMetric;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dz:=EuclideanApproximatedMetric;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=List(S,x-&gt;Maximum(List(S,y-&gt;dx(x,y))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n:=Position(L,Minimum(L));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=function(x); return [dx(S[n],x)]; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=30*[0..100];; P:=List(P, i-&gt;[i]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r:=29;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">epsilon:=75;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> cluster:=function(S)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local Y, P, C;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  if Length(S)=0 then return S; fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Y:=VectorsToOneSkeleton(S,epsilon,dx);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  P:=PiZero(Y);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  C:=Classify([1..Length(S)],P[2]);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return List(C,x-&gt;S{x});</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:=Mapper(S,dx,f,dz,P,r,cluster);</span>
Simplicial complex of dimension 1.

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(GraphOfSimplicialComplex(M));</span>

</pre></div>

<p><img src="images/mapper.png" align="center" height="300" alt="Mapper graph"/></p>

<p><a id="X7D512DA37F789B4C" name="X7D512DA37F789B4C"></a></p>

<h5>5.2-1 <span class="Heading">Background to the data</span></h5>

<p>The datacloud <span class="SimpleMath">S</span> consists of the <span class="SimpleMath">400</span> points in the plane shown in the following picture.</p>

<p><img src="images/mappercloud.png" align="center" height="400" alt="data cloud"/></p>

<p><a id="X79616D12822FDB9A" name="X79616D12822FDB9A"></a></p>

<h4>5.3 <span class="Heading">Digital image analysis and persistent homology</span></h4>

<p>The following example reads in a digital image as a filtered pure cubical complexex. The filtration is obtained by thresholding at a sequence of uniformly spaced values on the greyscale range. The persistent homology of this filtered complex is calculated in degrees <span class="SimpleMath">0</span> and <span class="SimpleMath">1</span> and displayed as two barcodes.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">file:=HapFile("image1.3.2.png");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F:=ReadImageAsFilteredPureCubicalComplex(file,20);</span>
Filtered pure cubical complex of dimension 2.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=PersistentBettiNumbers(F,0);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BarCodeCompactDisplay(P);</span>

</pre></div>

<p><img src="images/imbar0.gif" align="center" height="400" alt="barcode"/></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=PersistentBettiNumbers(F,1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BarCodeCompactDisplay(P);</span>

</pre></div>

<p><img src="images/imbar1.gif" align="center" height="400" alt="barcode"/></p>

<p>The <span class="SimpleMath">20</span> persistent bars in the degree <span class="SimpleMath">0</span> barcode suggest that the image has <span class="SimpleMath">20</span> objects. The degree <span class="SimpleMath">1</span> barcode suggests that <span class="SimpleMath">14</span> (or possibly <span class="SimpleMath">17</span>) of these objects have holes in them.</p>

<p><a id="X8066F9B17B78418E" name="X8066F9B17B78418E"></a></p>

<h5>5.3-1 <span class="Heading">Naive example of image segmentation by automatic thresholding</span></h5>

<p>Assuming that short bars and isolated points in the barcodes represent noise while long bars represent essential features, a "noiseless" representation of the image should correspond to a term in the filtration corresponding to a column in the barcode incident with all long bars but incident with no short bars or isolated points. The following commands confirm that the 4th term in the filtration is such a term and display this term as a binary image.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y:=FiltrationTerm(F,4);            </span>
Pure cubical complex of dimension 2.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BettiNumber(Y,0);</span>
20
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BettiNumber(Y,1);</span>
14
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(Y);</span>


</pre></div>

<p><img src="images/binaryimage.png" align="center" height="400" alt="binary image"/></p>

<p><a id="X7D512DA37F789B4C" name="X7D512DA37F789B4C"></a></p>

<h5>5.3-2 <span class="Heading">Background to the data</span></h5>

<p>The following image was used in the example.</p>

<p><img src="../tst/examples/image1.3.2.png" align="center" height="400" alt="barcode"/></p>

<p><a id="X7A8224DA7B00E0D9" name="X7A8224DA7B00E0D9"></a></p>

<h4>5.4 <span class="Heading">A second example of digital image segmentation</span></h4>

<p>In order to automatically count the number of coins in this picture</p>

<p><img src="images/my_coins.png" align="center" height="400" alt="collection of coins"/></p>

<p>we can load the image as a filtered pure cubical complex <span class="SimpleMath">F</span> of filtration length 30 say, and observe the degree zero persistent Betti numbers to establish that the 21-st term or so of <span class="SimpleMath">F</span> seems to be 'noise free' in degree zero. We can then set <span class="SimpleMath">M</span> equal to the 21-st term of <span class="SimpleMath">F</span> and thicken <span class="SimpleMath">M</span> a couple of times say to remove any tiny holes it may have. We can then construct the complement <span class="SimpleMath">C</span> of <span class="SimpleMath">M</span>. Then we can construct a 'neighbourhood thickening' filtration <span class="SimpleMath">T</span> of <span class="SimpleMath">C</span> with say <span class="SimpleMath">50</span> consecutive thickenings. The degree one persistent barcode for <span class="SimpleMath">T</span> has <span class="SimpleMath">24</span> long bars, suggesting that the original picture consists of <span class="SimpleMath">24</span> coins.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F:=ReadImageAsFilteredPureCubicalComplex("my_coins.png",30);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:=FiltrationTerm(F,21);;  #Chosen after viewing degree 0 barcode for F</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:=PureComplexThickened(M);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:=PureComplexThickened(M);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:=PureComplexComplement(M);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T:=ThickeningFiltration(C,50);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=PersistentBettiNumbers(T,1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BarCodeCompactDisplay(P);</span>

</pre></div>

<p><img src="images/coinsbettizero.gif" align="center" height="400" alt="barcode"/></p>

<p>The pure cubical complex <span class="SimpleMath">M</span> has the correct number of path components, namely <span class="SimpleMath">25</span>, but its path components are very much subsets of the regions in the image corresponding to coins. The complex <span class="SimpleMath">M</span> can be thickened repeatedly, subject to no two path components being allowed to merge, in order to obtain a more realistic image segmentation with path components corresponding more closely to coins. This is done in the follow commands which use a makeshift function <code class="code">Basins(L)</code> available <span class="URL"><a href="tutex/basins.g">here</a></span>. The commands essentially implement the standard watershed segmentation algorithm but do so by using the language of filtered pure cubical complexes.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W:=PureComplexComplement(FiltrationTerm(T,25));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=[];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [1..PathComponentOfPureComplex(W,0)] do</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P:=PathComponentOfPureComplex(W,i);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q:=ThickeningFiltration(P,50,M);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add(L,Q);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">od;;</span>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B:=Basins(L);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(B);</span>

</pre></div>

<p><img src="images/segmented_coins.png" align="center" height="400" alt="segmented coins"/></p>

<p><a id="X7D2CC9CB85DF1BAF" name="X7D2CC9CB85DF1BAF"></a></p>

<h4>5.5 <span class="Heading">Alternative approaches to computing persistent homology</span></h4>

<p>From any sequence <span class="SimpleMath">X_0 ⊂ X_1 ⊂ X_2 ⊂ ⋯ ⊂ X_T</span> of cellular spaces (such as pure cubical complexes, or cubical complexes, or simplicial complexes, or regular CW complexes) we can construct a filtered chain complex <span class="SimpleMath">C_∗ X_0 ⊂ C_∗ X_1 ⊂ C_∗ X_2 ⊂ ⋯ C_∗ X_T</span>. The induced homology homomorphisms <span class="SimpleMath">H_n(C_∗ X_0, F) → H_n(C_∗ X_1, F) → H_n(C_∗ X_2, F) → ⋯ → H_n(C_∗ X_T, F)</span> with coefficients in a field <span class="SimpleMath">F</span> can be computed by applying an appropriate sequence of elementary row operations to the boundary matrices in the chain complex <span class="SimpleMath">C_∗ X_T⊗ F</span>; the boundary matrices are sparse and are best represented as such; the row operations need to be applied in a fashion that respects the filtration. This method is used in the above examples of persistent homology. The method is not practical when the number of cells in <span class="SimpleMath">X_T</span> is large.</p>

<p>An alternative approach is to construct an admissible discrete vector field on each term <span class="SimpleMath">X_k</span> in the filtration. For each vector field there is a non-regular CW-complex <span class="SimpleMath">Y_k</span> whose cells correspond to the critical cells in <span class="SimpleMath">X_k</span> and for which there is a homotopy equivalence <span class="SimpleMath">X_k≃ Y_k</span>. For each <span class="SimpleMath">k</span> the composite homomorphism <span class="SimpleMath">H_n(C_∗ Y_k, F) stackrel≅→ H_n(C_∗ X_k, F) → H_n(C_∗ X_k+1, F) stackrel≅→ H_n(C_∗ Y_k+1, F)</span> can be computed and the persistent homology can be derived from these homology homomorphisms. This method is implemented in the function <code class="code">PersistentBettiNUmbersAlt(X,n,p)</code> where <span class="SimpleMath">p</span> is the characteristic of the field, <span class="SimpleMath">n</span> is the homology degree, and <span class="SimpleMath">X</span> can be a filtered pure cubical complex, or a filtered simplicial complex, or a filtered regular CW complex, or indeed a filtered chain complex (represented in sparse form). This function incorporates the functions <code class="code">ContractedFilteredPureCubicalComplex(X)</code> and <code class="code">ContractedFilteredRegularComplex(X)</code> which respectively input a filtered pure cubical complex and filtered regular CW-complex and return a filtered complex of the same data type in which each term of the output filtration is a deformation retract of the corresponding term in the input filtration.</p>

<p>In this approach the vector fields on the various spaces <span class="SimpleMath">X_k</span> are completely independent and so the method lends itself to a degree of easy parallelism. This is not incorporated into the current implementation.</p>

<p>As an illustration we consider a synthetic data set <span class="SimpleMath">S</span> consisting of <span class="SimpleMath">3527</span> points sampled, with errors, from an `unknown' manifold <span class="SimpleMath">M</span> in <span class="SimpleMath">R^3</span>. From such a data set one can associate a <span class="SimpleMath">3</span>-dimensional cubical complex <span class="SimpleMath">X_0</span> consisting of one unit cube centred on each (suitably scaled) data point. Given a pure cubical complex <span class="SimpleMath">X_s</span> we construct <span class="SimpleMath">X_s+1 =X_s ∪ {overline e^3_λ}_λ∈ Λ</span> by adding to <span class="SimpleMath">X_s</span> each closed unit cube <span class="SimpleMath">overline e^3_λ</span> in <span class="SimpleMath">R^3</span> that intersects non-trivially with <span class="SimpleMath">X_s</span>. We construct the filtered cubical complex <span class="SimpleMath">X_∗ ={X_i}_0≤ i≤ 19</span> and compute the persistence matrices <span class="SimpleMath">β_d^∗∗</span> for <span class="SimpleMath">d=0,1,2</span> and for <span class="SimpleMath">Z_2</span> coefficients. The filtered complex <span class="SimpleMath">X_∗</span> is quite large. In particular, the final space <span class="SimpleMath">X_19</span> in the filtration involves <span class="SimpleMath">1092727</span> vertices, <span class="SimpleMath">3246354</span> edges, <span class="SimpleMath">3214836</span> faces of dimension <span class="SimpleMath">2</span> and <span class="SimpleMath">1061208</span> faces of dimension <span class="SimpleMath">3</span>. The usual matrix reduction approach to computing persistent Betti numbers would involve an appropriate row reduction of sparse matrices one of which has over 3 million rows and 3 million columns.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">file:=HapFile("data247.txt");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Read(file);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F:=ThickeningFiltration(T,20);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P2:=PersistentBettiNumbersAlt(F,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BarCodeCompactDisplay(P2);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P1:=PersistentBettiNumbersAlt(F,1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BarCodeCompactDisplay(P1);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P0:=PersistentBettiNumbersAlt(F,0);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BarCodeCompactDisplay(P0);</span>

</pre></div>

<p><img src="images/barcodes123.gif" align="center" height="400" alt="barcodes"/></p>

<p>The barcodes suggest that the data points might have been sampled from a manifold with the homotopy type of a torus.</p>

<p><a id="X86FD0A867EC9E64F" name="X86FD0A867EC9E64F"></a></p>

<h5>5.5-1 <span class="Heading">Non-trivial cup product</span></h5>

<p>Of course, a wedge <span class="SimpleMath">S^2∨ S^1∨ S^1</span> has the same homology as the torus <span class="SimpleMath">S^1× S^1</span>. By establishing that a 'noise free' model for our data points, say the 10-th term <span class="SimpleMath">X_10</span> in the filtration, has a non-trivial cup product <span class="SimpleMath">∪: H^1(X_10, Z) × H^1(X_10, Z) → H^2(X_10, Z)</span> we can eliminate <span class="SimpleMath">S^2∨ S^1∨ S^1</span> as a candidate from which the data was sampled.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X10:=RegularCWComplex(FiltrationTerm(F,10));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cup:=LowDimensionalCupProduct(X10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cup([1,0],[0,1]);</span>
[ 1 ]

</pre></div>

<p><a id="X87AF06677F05C624" name="X87AF06677F05C624"></a></p>

<h4>5.6 <span class="Heading">Random simplicial complexes</span></h4>

<p>For a positive integer <span class="SimpleMath">n</span> and probability <span class="SimpleMath">p</span> we denote by <span class="SimpleMath">Y(n,p)</span> the <em>Linial-Meshulam random simplicial 2-complex</em>. Its <span class="SimpleMath">1</span>-skeleton is the complete graph on <span class="SimpleMath">n</span> vertices; each possible <span class="SimpleMath">2</span>-simplex is included independently with probability <span class="SimpleMath">p</span>.</p>

<p>The following commands first compute the number <span class="SimpleMath">h_i</span> of non-trivial cyclic summands in <span class="SimpleMath">H_i(Y(100,p), Z)</span> for a range of probabilities <span class="SimpleMath">p</span> and <span class="SimpleMath">i=1,2</span> and then produce a plot of <span class="SimpleMath">h_i</span> versus <span class="SimpleMath">p</span>. The plot for <span class="SimpleMath">h_1</span> is red and the plot for <span class="SimpleMath">h_2</span> is blue. A plot for the Euler characteristic <span class="SimpleMath">1-h_1+h_2</span> is shown in green.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=[];;M:=[];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for p in [1..100] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">K:=RegularCWComplex(RandomSimplicialTwoComplex(100,p/1000));;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">h1:=Length(Homology(K,1));;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">h2:=Length(Homology(K,2));;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Add(L, [1.0*(p/1000),h1,"red"]);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Add(L, [1.0*(p/1000),h2,"blue"]);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Add(M, [1.0*(p/1000),1-h1+h2,"green"]);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ScatterPlot(L);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ScatterPlot(M);</span>

</pre></div>

<p><img src="tutex/graph4.7.png" align="center" height="500" alt="a graph"/> <img src="tutex/graph4.77.png" align="center" height="500" alt="a graph"/></p>

<p>From this plot it seems that there is a <em>phase change threshold</em> at around <span class="SimpleMath">p=0.025</span>. An inspection of the first homology groups <span class="SimpleMath">H_1(Y(100,p), Z)</span> shows that in most cases there is no torsion. However, around the threshold some of the complexes do have torsion in their first homology.</p>

<p>Similar commands for <span class="SimpleMath">Y(75,p)</span> suggest a phase transition at around <span class="SimpleMath">p=0.035</span> in this case. The following commands compute <span class="SimpleMath">H_1(Y(75,p), Z)</span> for <span class="SimpleMath">900</span> random <span class="SimpleMath">2</span>-complexes with <span class="SimpleMath">p</span> in a small interval around <span class="SimpleMath">0.035</span> and, in each case where there is torsion, the torsion coefficients are stored in a list. The final command prints these lists -- all but one of which are of length <span class="SimpleMath">1</span>. For example, there is one <span class="SimpleMath">2</span>-dimensional simplicial complex on <span class="SimpleMath">75</span> vertices whose first homology contains the summand <span class="SimpleMath">Z_107879661870516800665161182578823128</span>. The largest prime factor is <span class="SimpleMath">80555235907994145009690263</span> occuring in the summand <span class="SimpleMath">Z_259837760616287294231081766978855</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">torsion:=function(n,p)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">local H, Y;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Y:=RegularCWComplex(RandomSimplicialTwoComplex(n,p));</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">H:=Homology(Y,1);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">H:=Filtered(H,x-&gt;not x=0);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">return H;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;</span>
function( n, p ) ... end


<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L:=[];;for n in [73000..73900] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">t:=torsion(75,n/2000000);  </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">if not t=[] then Add(L,t); fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(L);</span>
[ [                                     2 ],
  [                                    26 ],
  [     259837760616287294231081766978855 ],
  [                                     2 ],
  [                                     3 ],
  [                                     2 ],
  [          2761642698060127444812143568 ],
  [       2626355281010974663776273381976 ],
  [                                     2 ],
  [                                     3 ],
  [         33112382751264894819430785350 ],
  [                                    16 ],
  [                                     4 ],
  [                                     3 ],
  [                                     2 ],
  [                                     3 ],
  [                                     2 ],
  [      85234949999183888967763100590977 ],
  [                                     2 ],
  [      24644196130785821107897718662022 ],
  [                                     2,                                     2 ],
  [                                     2 ],
  [           416641662889025645492982468 ],
  [         41582773001875039168786970816 ],
  [                                     2 ],
  [            75889883165411088431747730 ],
  [         33523474091636554792305315165 ],
  [  107879661870516800665161182578823128 ],
  [          5588265814409119568341729980 ],
  [                                     2 ],
  [          5001457249224115878015053458 ],
  [                                    10 ],
  [                                    12 ],
  [                                     2 ],
  [                                     2 ],
  [                                     3 ],
  [          7757870243425246987971789322 ],
  [       8164648856993269673396613497412 ],
  [                                     2 ] ]

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
