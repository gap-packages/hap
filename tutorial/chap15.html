<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (HAP commands) - Chapter 15: Regular CW-structure on knots</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap15"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap14.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap15_mj.html">[MathJax on]</a></p>
<p><a id="X807B5257781BD6F3" name="X807B5257781BD6F3"></a></p>
<div class="ChapSects"><a href="chap15.html#X807B5257781BD6F3">15 <span class="Heading">Regular CW-structure on knots</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X86F56A85848347FF">15.1 <span class="Heading">Knot complements in the 3-ball</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X83EA2A38801E7A4C">15.2 <span class="Heading">Tubular neighbourhoods</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap15.html#X78C28038837300BD">15.3 <span class="Heading">Knotted surface complements in the 4-ball</span></a>
</span>
</div>
</div>

<h3>15 <span class="Heading">Regular CW-structure on knots</span></h3>

<p><a id="X86F56A85848347FF" name="X86F56A85848347FF"></a></p>

<h4>15.1 <span class="Heading">Knot complements in the 3-ball</span></h4>

<p>While methods for endowing knot complements with CW-structure already exist in HAP (see section 2.1), they often result in a large number of cells which can make computing with them taxing. The following example shows how one can obtain a comparatively small 3-dimensional regular CW-complex corresponding to the complement of a thickened trefoil knot from an arc presentation. Recall that an arc presentation is encoded in HAP as a list of integer pairs corresponding to the position of the endpoints of each horizontal arc in a grid.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k_:=PureCubicalKnot(3,1);                  </span>
prime knot 1 with 3 crossings

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">arc:=ArcPresentation(k_);                  </span>
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k_:=RegularCWComplex(PureComplexComplement(k_));</span>
Regular CW-complex of dimension 3

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(k_);</span>
13291
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k:=KnotComplement(arc);                                         </span>
Regular CW-complex of dimension 3

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(k);</span>
395

</pre></div>

<p>An optional argument of <code class="code">"rand"</code> in the <code class="code">KnotComplement</code> function randomises the order in which <span class="SimpleMath">2</span>-cells are added to the complex. This allows for alternate presentations of the knot group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">arc:=ArcPresentation(PureCubicalKnot(3,1));</span>
[ [ 2, 5 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 1, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k:=KnotComplement(arc,"rand");</span>
Random 2-cell selection is enabled.
Regular CW-complex of dimension 3

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=FundamentalGroup(k); RelatorsOfFpGroup(g); </span>
#I  there are 2 generators and 1 relator of total length 6
&lt;fp group of size infinity on the generators [ f1, f2 ]&gt;
[ f2^-1*f1*f2^-1*f1^-1*f2*f1^-1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k:=KnotComplement(arc,"rand");               </span>
Random 2-cell selection is enabled.
Regular CW-complex of dimension 3

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=FundamentalGroup(k); RelatorsOfFpGroup(g);</span>
#I  there are 2 generators and 1 relator of total length 7
&lt;fp group of size infinity on the generators [ f1, f2 ]&gt;
[ f1*f2^-2*f1*f2*f1^-1*f2 ]

</pre></div>

<p>It is often useful to obtain an inclusion of regular CW-complexes <span class="SimpleMath">ι : ∂ (N(K)) ↪ B^3 backslash N(K)</span> from the boundary of a tubular neighbourhood of some knot <span class="SimpleMath">N(K)</span> into its complement in the <span class="SimpleMath">3</span>-ball <span class="SimpleMath">B^3 backslash N(K)</span>. The below example does this for the first prime knot on 11 crossings.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">arc:=ArcPresentation(PureCubicalKnot(11,1));</span>
[ [ 2, 9 ], [ 1, 3 ], [ 2, 6 ], [ 4, 7 ], [ 3, 5 ], [ 6, 10 ], [ 4, 8 ], 
  [ 9, 11 ], [ 7, 10 ], [ 1, 8 ], [ 5, 11 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k:=KnotComplementWithBoundary(arc);</span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(Source(i));</span>
616
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(Target(i));</span>
1043

</pre></div>

<p>Note that we can add <span class="SimpleMath">n</span>-cells to regular CW-complexes by specifying the <span class="SimpleMath">(n-1)</span>-cells in their boundaries and <span class="SimpleMath">(n+1)</span>-cells in their coboundaries.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k:=KnotComplement([[1,2],[1,2]])!.boundaries;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Homology(RegularCWComplex(k),0);</span>
[ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddCell(k,0,[0],[]);                          </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Homology(RegularCWComplex(k),0);</span>
[ 0, 0 ]

</pre></div>

<p><a id="X83EA2A38801E7A4C" name="X83EA2A38801E7A4C"></a></p>

<h4>15.2 <span class="Heading">Tubular neighbourhoods</span></h4>

<p>Let <span class="SimpleMath">Y</span> denote a CW-subcomplex of a regular CW-complex <span class="SimpleMath">X</span> and let <span class="SimpleMath">N(Y)</span> denote an open tubular neighbourhood of <span class="SimpleMath">Y</span>. Given an inclusion of regular CW-complexes <span class="SimpleMath">f : Y ↪ X</span>, this algorithm describes a procedure for obtaining the associated inclusion <span class="SimpleMath">f' : ∂ C ↪ C</span> where <span class="SimpleMath">C=X backslash N(Y)</span> and <span class="SimpleMath">∂ C</span> denotes the boundary of <span class="SimpleMath">C</span>. The following is also assumed:</p>

<p>Let <span class="SimpleMath">e^n</span> denote a cell of <span class="SimpleMath">X backslash Y</span> of dimension <span class="SimpleMath">n</span> with <span class="SimpleMath">bare^n</span> denoting its closure. For each <span class="SimpleMath">n</span>-cell, all of the connected components of the subcomplex <span class="SimpleMath">bare^n ∩ Y</span> are contractible.</p>

<p>Some additional terminology and notation is needed to describe this algorithm. The output regular CW-complex <span class="SimpleMath">X backslash N(Y)</span> consists of the cell complex <span class="SimpleMath">X backslash Y</span> as well as some additional cells to maintain regularity. A cell of <span class="SimpleMath">X backslash N(Y)</span> is referred to as <em>internal</em> if it lies in <span class="SimpleMath">X backslash Y</span>, it is <em>external</em> otherwise. Let <span class="SimpleMath">bare^n</span> denote the closure in <span class="SimpleMath">X</span> of an internal cell <span class="SimpleMath">e^n</span>. Note that <span class="SimpleMath">bare^n</span> is a CW-subcomplex of <span class="SimpleMath">X</span> and so is the intersection <span class="SimpleMath">bare^n ∩ Y</span> which can be expressed as the union</p>

<p><span class="SimpleMath">bare^n ∩ Y = A_1 ∪ A_2 ∪ ⋯ ∪ A_k</span></p>

<p>of its path components <span class="SimpleMath">A_i</span> all of which are CW-subcomplexes of <span class="SimpleMath">Y</span>. For each <span class="SimpleMath">n</span>-cell of <span class="SimpleMath">X backslash Y</span> there is one internal <span class="SimpleMath">n</span>-cell <span class="SimpleMath">e^n</span> of <span class="SimpleMath">X backslash N(Y)</span>. For <span class="SimpleMath">n ≥ 1</span> there is also one external <span class="SimpleMath">(n-1)</span>-cell <span class="SimpleMath">f^e^n_A_i</span> for each path component <span class="SimpleMath">A_i</span> of <span class="SimpleMath">bare^n ∩ Y</span>. Lastly, we need a method for determining the homological boundary of the internal and external cells:</p>

<p><span class="SimpleMath">∙</span> The boundary of an internal <span class="SimpleMath">n</span>-cell <span class="SimpleMath">e^n</span> consists of all those internal <span class="SimpleMath">(n-1)</span>-cells of <span class="SimpleMath">bare^n</span> together with all external <span class="SimpleMath">(n-1)</span>-cells <span class="SimpleMath">f^e^n_A_i</span> where <span class="SimpleMath">A_i</span> is a path component of <span class="SimpleMath">bare^n ∩ Y</span>.</p>

<p><span class="SimpleMath">∙</span> The boundary of an external <span class="SimpleMath">(n-1)</span>-cell <span class="SimpleMath">f^e^n_A_i</span> consists of all those external <span class="SimpleMath">(n-2)</span>-cells <span class="SimpleMath">f^e^n-1}_B_j</span> where <span class="SimpleMath">e^n-1</span> is an <span class="SimpleMath">(n-1)</span>-cell of <span class="SimpleMath">bare^n</span> and <span class="SimpleMath">B_j ⊆ A_i</span> is a path component of <span class="SimpleMath">A_i</span>.</p>

<p>The following three steps comprise the algorithm.</p>

<p><span class="SimpleMath">(1)</span> For each internal <span class="SimpleMath">n</span>-cell <span class="SimpleMath">e^n ⊂ X backslash Y</span>, compute the CW-complex <span class="SimpleMath">bare^n ∩ Y</span> as a union of path components <span class="SimpleMath">A_1 ∪ A_2 ∪ ⋯ ∪ A_k</span>. This information can be used to determine the number of cells of <span class="SimpleMath">X backslash N(Y)</span> in each dimension.</p>

<p><span class="SimpleMath">(2)</span> Create a list <span class="SimpleMath">B=[ [ ], [ ], ..., [ ] ]</span> of length <span class="SimpleMath">dimX +1</span>.</p>

<p><span class="SimpleMath">(3)</span> For <span class="SimpleMath">0 ≤ n ≤ dimX</span> set <span class="SimpleMath">B[n+1]=[ b_1, b_2, ..., b_α_n ]</span> where <span class="SimpleMath">α_n</span> is the number of <span class="SimpleMath">n</span>-cells in <span class="SimpleMath">X backslash N(Y)</span> and <span class="SimpleMath">b_i</span> is a list of integers describing the <span class="SimpleMath">(n-1)</span>-cells of the <span class="SimpleMath">i ^ th</span> <span class="SimpleMath">n</span>-cell of <span class="SimpleMath">X backslash N(Y)</span>. The internal cells will always be listed before the external cells in each sublist. Return B as a regular CW-complex.</p>

<p>The following example computes the tubular neighbourhood of a <span class="SimpleMath">1</span>-dimensional subcomplex of a <span class="SimpleMath">3</span>-dimensional complex corresponding to the Hopf link embedded in the closed <span class="SimpleMath">3</span>-ball.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">arc:=[[2,4],[1,3],[2,4],[1,3]];;            </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=ArcPresentationToKnottedOneComplex(arc);</span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comp:=RegularCWComplexComplement(f);</span>
Testing contractibility...
151 out of 151 cells tested.
The input is compatible with this algorithm.
Regular CW-complex of dimension 3


</pre></div>

<p>Note that the output of this algorithm is just a regular CW-complex, not an inclusion map. The function <code class="code">BoundaryMap</code> can be employed to obtain the boundary of a pure complex. This results in three path components for this example: two corresponding to the boundary of the knotted tori and the other corresponding to the boundary of the <span class="SimpleMath">3</span>-ball in which the link was embedded. These path components can be obtained as individual CW-subcomplexes if desired. A CW-subcomplex is represented in HAP as a list <span class="SimpleMath">[X,s]</span> where <span class="SimpleMath">X</span> is a regular CW-complex and <span class="SimpleMath">s</span> is a list of length <span class="SimpleMath">n</span> whose <span class="SimpleMath">i^th</span> entry lists the indexing of each <span class="SimpleMath">(i-1)</span>-cell of the <span class="SimpleMath">n</span>-dimensional subcomplex of <span class="SimpleMath">X</span>. CW-subcomplexes and CW maps can be converted between each other interchangeably. This next example obtains the inclusion detailed in the above algorithm, finds the path components of the source of said inclusion, shows that they are in fact disjoint, and then obtains the first four integral homology groups of each component.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f_:=BoundaryMap(comp);</span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f_:=RegularCWMapToCWSubcomplex(f_);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">paths:=PathComponentsCWSubcomplex(f_);</span>
[ [ Regular CW-complex of dimension 3
        , 
      [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 18, 19, 20 ], 
          [ 1, 2, 3, 4, 5, 6, 13, 14, 15, 16, 17, 18, 33, 34, 35, 46, 47, 48 
             ], [ 11, 12, 13, 14, 15, 16, 35, 36 ] ] ], 
  [ Regular CW-complex of dimension 3
        , [ [ 21, 24, 25, 27, 30, 31, 32, 37, 38, 39, 40, 43, 45, 46, 48 ], 
          [ 49, 51, 53, 56, 57, 59, 61, 63, 65, 67, 69, 71, 73, 74, 76, 79, 
              82, 83, 86, 87, 90, 91 ], [ 37, 39, 41, 44, 45, 47, 49 ] ] ], 
  [ Regular CW-complex of dimension 3
        , [ [ 22, 23, 26, 28, 29, 33, 34, 35, 36, 41, 42, 44, 47, 49, 50 ], 
          [ 50, 52, 54, 55, 58, 60, 62, 64, 66, 68, 70, 72, 75, 77, 78, 80, 
              81, 84, 85, 88, 89, 92 ], [ 38, 40, 42, 43, 46, 48, 50 ] ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">paths:=List(paths,CWSubcomplexToRegularCWMap);</span>
[ Map of regular CW-complexes
    , Map of regular CW-complexes
    , Map of regular CW-complexes
     ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..3],x-&gt;List(Difference([1..3],[x]),y-&gt;IntersectionCWSubcomplex(paths[x],paths[y])));</span>
[ [ [ Regular CW-complex of dimension 3
            , [ [  ], [  ], [  ] ] ], [ Regular CW-complex of dimension 3
            , [ [  ], [  ], [  ] ] ] ], [ [ Regular CW-complex of dimension 3
            , [ [  ], [  ], [  ] ] ], [ Regular CW-complex of dimension 3
            , [ [  ], [  ], [  ] ] ] ], [ [ Regular CW-complex of dimension 3
            , [ [  ], [  ], [  ] ] ], [ Regular CW-complex of dimension 3
            , [ [  ], [  ], [  ] ] ] ] ]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(paths,x-&gt;List([0..3],y-&gt;Homology(Source(x),y)));</span>
[ [ [ 0 ], [  ], [ 0 ], [  ] ], [ [ 0 ], [ 0, 0 ], [ 0 ], [  ] ], 
  [ [ 0 ], [ 0, 0 ], [ 0 ], [  ] ] ]

</pre></div>

<p>As previously mentioned, for the tubular neighbourhood algorithm to work, we require that no external cells yield non-contractible path-components in their intersection with the subcomplex. If this is ever the case then we can subdivide the offending cell to prevent this from happening. We have implemented two subdivision algorithms in HAP, one for barycentrically subdividing a given cell, and the other for subdividing an <span class="SimpleMath">n</span>-cell into as many <span class="SimpleMath">n</span>-cells as there are <span class="SimpleMath">(n-1)</span>-cells in its boundary. Barycentric subdivision is integrated into the <code class="code">RegularCWComplexComplement</code> function and will be performed automatically as required. The following example shows this automatic subdivision running via the complement of a tubular neighbourhood of the unknot, then obtains an inclusion map from the closure of an arbitrary <span class="SimpleMath">3</span>-cell of this complex and then compares the difference in size of the two different subdivisions of a 2-cell in the boundary of this <span class="SimpleMath">3</span>-cell.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">arc:=[[1,2],[1,2]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">unknot:=ArcPresentationToKnottedOneComplex(arc);</span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=RegularCWComplexComplement(unknot);</span>
Testing contractibility...
79 out of 79 cells tested.
Subdividing 3 cell(s):
100% complete. 
Testing contractibility...
145 out of 145 cells tested.
The input is compatible with this algorithm.
Regular CW-complex of dimension 3

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:=Objectify(HapRegularCWMap,rec(source:=f,target:=f,mapping:={i,j}-&gt;j));    </span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">closure:=ClosureCWCell(Target(f),3,1);</span>
[ Regular CW-complex of dimension 3
    , 
  [ [ 1, 2, 3, 4, 7, 8, 9, 10, 11, 13, 14, 20, 21, 22, 23, 25 ], 
      [ 1, 2, 3, 7, 8, 9, 10, 11, 15, 16, 17, 20, 21, 22, 23, 24, 25, 27, 28, 55, 58, 59, 
          60, 63 ], [ 1, 4, 7, 8, 9, 13, 14, 15, 18, 52 ], [ 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(Target(f));                                          </span>
195
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(Target(BarycentricallySubdivideCell(f,2,1)));        </span>
231
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(Target(SubdivideCell(f,2,1)));        </span>
207

</pre></div>

<p><a id="X78C28038837300BD" name="X78C28038837300BD"></a></p>

<h4>15.3 <span class="Heading">Knotted surface complements in the 4-ball</span></h4>

<p>A construction of Satoh's, the tube map, associates a ribbon torus-knot to virtual knot diagrams. A virtual knot diagram differs from a knot diagram in that it allows for a third type of crossing, a virtual crossing. The image of such a crossing via the tube map is two tori which pass through each other. An arc diagram is a triple of lists <code class="code">[arc,cross,cols]</code> that encode virtual knot diagrams. <code class="code">arc</code> is an arc presentation. <code class="code">cross</code> is a list of length the number of crossings in the knot associated to the arc presentation whose entries are <span class="SimpleMath">-1,0</span> or <span class="SimpleMath">1</span> corresponding to an undercrossing (horizontal arc underneath vertical arc), a virtual crossing (depicted by intersecting horizontal and vertical arcs) and an overcrossing (horizontal arc above vertical arc) respectively. <code class="code">cols</code> is a list of length the number of <span class="SimpleMath">0</span> entries in <code class="code">cross</code> and its entries are <span class="SimpleMath">1,2,3</span> or <span class="SimpleMath">4</span>. It describes the types of 'colourings' we assign to the virtual crossings. We interpret each integer as the change in 4-dimensional height information as represented by a colour scale from blue (lower down in 4-space), to green (0 level), to red (higher up in 4-space). Without loss of generality, we impose that at each virtual crossing, the vertical arc passes through the horizontal arc. Thus, <span class="SimpleMath">1</span> corresponds to the vertical bar entering the horizontal bar as blue and leaving as blue, <span class="SimpleMath">2</span> corresponds to entering as blue and leaving as red, <span class="SimpleMath">3</span> corresponds to entering as red and leaving as blue and <span class="SimpleMath">4</span> corresponds to entering and leaving as red. A coloured arc diagram can be visualised using the <code class="code">ViewColouredArcDiagram</code> function.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">arc:=ArcPresentation(PureCubicalKnot(6,1));</span>
[ [ 5, 8 ], [ 4, 6 ], [ 3, 5 ], [ 2, 4 ], [ 1, 3 ], [ 2, 7 ], [ 6, 8 ], [ 1, 7 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cross:=[0,0,1,-1,-1,0];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cols:=[1,4,3];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ViewColouredArcDiagram(arc,cross,cols);  </span>
convert-im6.q16: pixels are not authentic `/tmp/HAPtmpImage.txt' @ error/cache.c/QueueAuthenticPixelCacheNexus/4381.


</pre></div>

<p><img src="../lib/Kelvin/images/kelvin-01.png" width="350"/></p>

<p>Towards obtaining a regular CW-decomposition of ribbon torus-knots, we first begin by embedding a self-intersecting knotted torus in the 3-ball. The function <code class="code">ArcDiagramToTubularSurface</code> inputs a coloured arc diagram and outputs an inclusion from the boundary of some (potentially self-intersecting) torus in the <span class="SimpleMath">3</span>-ball. By inputting just an arc presentation, one can obtain an inclusion identical to the <code class="code">KnotComplementWithBoundary</code> function. By additionally inputting a list of <span class="SimpleMath">-1</span>s and <span class="SimpleMath">1</span>s, one can obtain an inclusion similar to <code class="code">KnotComplementWithBoundary</code> but where there is extra freedom in determining whether or not a given crossing is an under/overcrossing. If one inputs both of the above but includes <span class="SimpleMath">0</span> entries in the <code class="code">cross</code> list and includes the list of colours, the output is then an inclusion from an embedded self-intersecting torus into the 3-ball where each <span class="SimpleMath">2</span>-cell (the top-dimensional cells of the self-intersecting surface) is assigned a colour.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tub:=ArcDiagramToTubularSurface(arc);        </span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tub:=ArcDiagramToTubularSurface([arc,cross]);</span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tub:=ArcDiagramToTubularSurface([arc,cross,cols]);</span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..Length(Source(tub)!.boundaries[3])],x-&gt;tub!.colour(2,tub!.mapping(2,x)));</span>
[ [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], 
  [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], 
  [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], 
  [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], 
  [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ -1 ], [ -1 ], 
  [ 0 ], [ 0 ], [ -1 ], [ -1 ], [ -1 ], [ -1 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 1 ], [ 1 ], 
  [ 0 ], [ 0 ], [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 1 ], [ 1 ], [ 0 ], 
  [ 0 ], [ -1 ], [ -1 ], [ 1 ], [ -1 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ -1 ], [ -1 ], [ 0 ], 
  [ 1 ], [ 1 ], [ 0 ], [ 0 ], [ 0 ], [ 0 ], [ 1 ], [ -1 ], [ 0 ] ]

</pre></div>

<p>From this self-intersecting surface with colour, we can lift it to a surface without self-intersections in <span class="SimpleMath">R^4</span>. We do this by constructing a regular CW-complex of the direct product <span class="SimpleMath">B^3 × [a,b]</span> where <span class="SimpleMath">B^3</span> denotes the <span class="SimpleMath">3</span>-ball, <span class="SimpleMath">a</span> is <span class="SimpleMath">1</span> less than the smallest integer assigned to a cell by the colouring, and <span class="SimpleMath">b</span> is <span class="SimpleMath">1</span> greater than the largest integer assigned to a cell by the colouring. The subcomplex of the direct product corresponding to the surface without intersection can be obtained using the colouring with additional care taken to not lift any 1-cells arising as double-point singularities. The following example constructs the complement of a ribbon torus-link embedded in <span class="SimpleMath">R^4</span> obtained from the Hopf link with one virtual crossing and then calculates some invariants of the resulting space. We compare the size of this complex, as well as how long it takes to obtain the same invariants, with a cubical complex of the same space. As barycentric subdivision can massively increase the size of the cell complex, the below method sequentially obtains the tubular neighbourhood of the entire subcomplex by obtaining the tubular neighbourhood of each individual <span class="SimpleMath">2</span>-cell. This has yet to be optimised so it currently takes some time to complete.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">arc:=[[2,4],[1,3],[2,4],[1,3]];;                </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tub:=ArcDiagramToTubularSurface([arc,[0,-1],[2]]);</span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tub:=LiftColouredSurface(tub);</span>
Map of regular CW-complexes

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension(Source(tub));</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension(Source(tub));</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map:=RegularCWMapToCWSubcomplex(tub);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sub:=SortedList(map[2][3]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sub:=List(sub,x-&gt;x-(Position(sub,x)-1));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">clsr:=ClosureCWCell(map[1],2,sub[1])[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">seq:=CWSubcomplexToRegularCWMap([map[1],clsr]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tub:=RegularCWComplexComplement(seq);</span>
Testing contractibility...
3501 out of 3501 cells tested.
The input is compatible with this algorithm.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [2..Length(sub)] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    clsr:=ClosureCWCell(tub,2,sub[i])[2];;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    seq:=CWSubcomplexToRegularCWMap([tub,clsr]);;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    tub:=RegularCWComplexComplement(seq);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
Testing contractibility...
3612 out of 3612 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
3693 out of 3693 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
3871 out of 3871 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
3925 out of 3925 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
4084 out of 4084 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
4216 out of 4216 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
4348 out of 4348 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
4529 out of 4529 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
4688 out of 4688 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
4723 out of 4723 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
4918 out of 4918 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
5107 out of 5107 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
5269 out of 5269 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
5401 out of 5401 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
5548 out of 5548 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
5702 out of 5702 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
5846 out of 5846 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
6027 out of 6027 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
6089 out of 6089 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
6124 out of 6124 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
6159 out of 6159 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
6349 out of 6349 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
6467 out of 6467 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
6639 out of 6639 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
6757 out of 6757 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
6962 out of 6962 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
7052 out of 7052 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
7242 out of 7242 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
7360 out of 7360 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
7470 out of 7470 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
7561 out of 7561 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
7624 out of 7624 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
7764 out of 7764 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
7904 out of 7904 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
7979 out of 7979 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8024 out of 8024 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8086 out of 8086 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8148 out of 8148 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8202 out of 8202 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8396 out of 8396 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8534 out of 8534 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8625 out of 8625 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8736 out of 8736 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8817 out of 8817 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
8983 out of 8983 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
9073 out of 9073 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
9218 out of 9218 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
9323 out of 9323 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
9442 out of 9442 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
9487 out of 9487 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
9538 out of 9538 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
9583 out of 9583 cells tested.
The input is compatible with this algorithm.
Testing contractibility...
9634 out of 9634 cells tested.
The input is compatible with this algorithm.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(tub);      </span>
9685
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">total_time_1:=0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([0..4],x-&gt;Homology(tub,x)); total_time_1:=total_time_1+time;;</span>
[ [ 0 ], [ 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0 ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:=ChainComplexOfUniversalCover(tub);; total_time_1:=total_time_1+time;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l:=Filtered(LowIndexSubgroups(c!.group,5),g-&gt;Index(c!.group,g)=5);; total_time_1:=total_time_1+time;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv:=Set(l,g-&gt;Homology(TensorWithIntegersOverSubgroup(c,g),2)); total_time_1:=total_time_1+time;;</span>
[ [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] 
 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">total_time_1;</span>
3407
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hopf:=PureComplexComplement(HopfSatohSurface());;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hopf:=RegularCWComplex(hopf);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(hopf);</span>
4508573
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">total_time_2:=0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c_:=ChainComplexOfUniversalCover(hopf);; total_time_2:=total_time_2+time;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l_:=Filtered(LowIndexSubgroups(c_!.group,5),g-&gt;Index(c_!.group,g)=5);; total_time_2:=total_time_2+time;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv_:=Set(l_,g-&gt;Homology(TensorWithIntegersOverSubgroup(c_,g),2));; total_time_2:=total_time_2+time;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">total_time_2;</span>
1116000
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv_=inv;</span>
true

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap14.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
