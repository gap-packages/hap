<Chapter><Heading> <M>FpG</M>-modules</Heading>

<Table Align="|l|" >

<Row>
<Item>
<Index> CompositionSeriesOfFpGModules</Index>
<C>CompositionSeriesOfFpGModules(M) </C>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and 
 returns a list of <M>FpG</M>-modules that constitute a composition series for <M>M</M>.
</Item>
</Row>


<Row>
<Item>
<Index> DirectSumOfFpGModules</Index>
<C>DirectSumOfFpGModules(M,N) </C> 
<C>DirectSumOfFpGModules([ M[1], M[2], ..., M[k] ])) </C>
<P/>

Inputs two <M>FpG</M>-modules <M>M</M> and <M>N</M> 
with common group and characteristic. It returns the direct sum of 
<M>M</M> and <M>N</M> as an <M>FpG</M>-Module.
<P/>
Alternatively, the function can input a list of <M>FpG</M>-modules 
with common group <M>G</M>. It returns the direct sum of the list.
</Item>
</Row>

<Row>
<Item>
<Index> FpGModule</Index>
<C>FpGModule(A,P) </C>
<C>FpGModule(A,G,p) </C>
<P/>

Inputs a <M>p</M>-group <M>P</M> and a matrix <M>A</M> 
whose rows have length a multiple of the order of <M>G</M>. 
It returns the <Quoted>canonical</Quoted>
<M>FpG</M>-module generated by the rows of <M>A</M>.

<P/>
A small non-prime-power group <M>G</M> can also be input, provided the characteristic <M>p</M> is entered as a third input variable. 
</Item>
</Row>

<Row>
<Item>
<Index> FpGModuleDualBasis</Index>
<C>FpGModuleDualBasis(M) </C>
<P/>

Inputs an <M>FpG</M>-module <M>M</M>. It returns a record 
<M>R</M> with two components:
<List>
<Item><M>R.freeModule</M> is the free module <M>FG</M> of rank one.</Item>
<Item><M>R.basis</M> is a list representing an <M>F</M>-basis 
for the module <M>Hom_{FG}(M,FG)</M>. Each term in the 
list is a matrix <M>A</M> whose rows are vectors in <M>FG</M> 
such that  <M>M!.generators[i] \longrightarrow A[i]</M>  
extends to a module homomorphism <M>M \longrightarrow FG</M>.
	</Item>
	</List>
</Item>
</Row>

<Row>
<Item>
<Index> FpGModuleHomomorphism</Index>
<C>FpGModuleHomomorphism(M,N,A) </C>
<C>FpGModuleHomomorphismNC(M,N,A) </C>
<P/>

Inputs <M>FpG</M>-modules <M>M</M> and <M>N</M> over a common <M>p</M>-group <M>G</M>. 
Also inputs a list <M>A</M> of vectors in the vector space spanned by 
<M>N!.matrix</M>. It tests that the function
<P/>
<M> M!.generators[i] \longrightarrow A[i]</M>
<P/>
 extends to a homomorphism of <M>FpG</M>-modules and, 
 if the test is passed, returns the corresponding <M>FpG</M>-module 
 homomorphism. If the test is failed it returns fail.
<P/>
 The "NC" version of the function assumes that the input 
 defines a homomorphism and simply returns the <M>FpG</M>-module homomorphism.
</Item>
</Row>
<Row>
<Item>
<Index>DesuspensionFpGModule</Index>
<C> DesuspensionFpGModule(M,n)</C>
<C>DesuspensionFpGModule(R,n) </C>
<P/>

Inputs a positive integer <M>n</M> and and FpG-module <M>M</M>. It returns an 
FpG-module <M>D^nM</M> which is mathematically related to <M>M</M> via
 an exact sequence
 <M> 0 \longrightarrow D^nM \longrightarrow R_n \longrightarrow \ldots
 \longrightarrow R_0 \longrightarrow M \longrightarrow 0</M> where <M>R_\ast</M>
 is a free resolution.
 (If <M>G=Group(M)</M> is of prime-power order then the resolution is minimal.)

<P/>
Alternatively, the function can input a positive integer <M>n</M>
and at least <M>n</M> terms of a free 
resolution <M>R</M> of <M>M</M>.

</Item>
</Row>
<Row>
<Item>
<Index> RadicalOfFpGModule</Index>
<C>RadicalOfFpGModule(M) </C>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> with <M>G</M> a <M>p</M>-group, and returns the Radical of 
<M>M</M> as an <M>FpG</M>-module. (Ig <M>G</M> is not a <M>p</M>-group then a submodule of the radical is returned.
</Item>
</Row>

<Row>
<Item>
<Index> RadicalSeriesOfFpGModule</Index>
<C>RadicalSeriesOfFpGModule(M) </C>
 <P/>

Inputs an <M>FpG</M>-module <M>M</M> and
 returns a list of <M>FpG</M>-modules that constitute the radical
 series for <M>M</M>.
</Item>
</Row>



<Row>
<Item>
<Index> GeneratorsOfFpGModule</Index>
<C>GeneratorsOfFpGModule(M) </C>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and returns a matrix whose 
rows correspond to a  minimal generating set for <M>M</M>. 
</Item>
</Row>
<Row>
<Item>
<Index> ImageOfFpGModuleHomomorphism</Index>
<C>ImageOfFpGModuleHomomorphism(f) </C>
<P/>

Inputs an <M>FpG</M>-module homomorphism <M>f:M \longrightarrow N</M>
and returns its image <M>f(M)</M> as an <M>FpG</M>-module. 
</Item>
</Row>


<Row>
<Item>
<Index> GroupAlgebraAsFpGModule</Index>
<C>GroupAlgebraAsFpGModule(G) </C>
 <P/>

Inputs a <M>p</M>-group <M>G</M> and
 returns its mod <M>p</M> group algebra as an <M>FpG</M>-module.
</Item>
</Row>




<Row>
<Item>
<Index> IntersectionOfFpGModules</Index>
<C>IntersectionOfFpGModules(M,N) </C>
<P/>

Inputs two <M>FpG</M>-modules <M>M, N</M> arising as submodules in a 
common free module <M>(FG)^n</M> where <M>G</M> is a  finite group and 
<M>F</M> the field of <M>p</M>-elements. It returns the <M>FpG</M>-module
arising as the intersection of <M>M</M> and <M>N</M>.
</Item>
</Row>

<Row>
<Item>
<Index> IsFpGModuleHomomorphismData</Index>
<C>IsFpGModuleHomomorphismData(M,N,A) </C>
<P/>

Inputs <M>FpG</M>-modules <M>M</M> and <M>N</M> over a common <M>p</M>-group <M>G</M>. 
Also inputs a list <M>A</M> of vectors in the vector space spanned by 
<M>N!.matrix</M>. It returns true if the function
<P/>
<M> M!.generators[i] \longrightarrow A[i]</M>
<P/>
 extends to a homomorphism of <M>FpG</M>-modules. Otherwise it 
 returns false.
</Item>
</Row>

<Row>
<Item>
<Index> MaximalSubmoduleOfFpGModule</Index>
<C>MaximalSubmoduleOfFpGModule(M) </C>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and
 returns one maximal <M>FpG</M>-submodule of <M>M</M>.
</Item>
</Row>


<Row>
<Item>
<Index> MaximalSubmodulesOfFpGModule</Index>
<C>MaximalSubmodulesOfFpGModule(M) </C>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and
 returns the list of maximal <M>FpG</M>-submodules of <M>M</M>.
</Item>
</Row>



<Row>
<Item>
<Index> MultipleOfFpGModule </Index>
<C>MultipleOfFpGModule(w,M) </C>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> and a list 
<M>w:=[g_1 , ..., g_t]</M> of elements in the group <M>G=M!.group</M>. 
The list <M>w</M> can be thought of as representing the element 
<M>w=g_1 + \ldots + g_t</M> in the group algebra <M>FG</M>, 
and the function returns a semi-echelon matrix <M>B</M> 
which is a basis for the vector subspace <M>wM</M> .
</Item>
</Row>
<Row>
<Item>
<Index> ProjectedFpGModule</Index>
<C>ProjectedFpGModule(M,k) </C>
<P/>

Inputs an <M>FpG</M>-module <M>M</M> of ambient dimension <M>n|G|</M>, 
and an integer <M>k</M> between <M>1</M> and <M>n</M>. The module 
<M>M</M> is a submodule of the free module <M>(FG)^n</M> . Let 
<M>M_k</M> denote the  intersection of <M>M</M> with the last <M>k</M> 
summands of <M>(FG)^n</M> .  
The function returns the image of the 
projection of <M>M_k</M> onto the <M>k</M>-th summand of <M>(FG)^n</M> . This 
image is returned  an <M>FpG</M>-module with 
ambient dimension <M>|G|</M>.
</Item>
</Row>
<Row>
<Item>
<Index> RandomHomomorphismOfFpGModules</Index>
<C>RandomHomomorphismOfFpGModules(M,N) </C>
<P/>

Inputs two <M>FpG</M>-modules <M>M</M> and <M>N</M> over a common group 
<M>G</M>. It returns a random matrix <M>A</M> whose rows are vectors in 
<M>N</M> such that the function
<P/>
<M> M!.generators[i] \longrightarrow A[i]</M>
<P/>
 extends to a homomorphism <M>M \longrightarrow N</M> of <M>FpG</M>-modules.
 (There is a problem with this function at present.)
</Item>
</Row>
<Row>
<Item>
<Index> Rank </Index>
<C>Rank(f) </C>
<P/>

Inputs an <M>FpG</M>-module homomorphism <M>f:M \longrightarrow N</M>
and returns the dimension of the image of <M>f</M> as a vector 
space over the field <M>F</M> of <M>p</M> elements.
</Item>
</Row>
<Row>
<Item>
<Index> SumOfFpGModules</Index>
<C>SumOfFpGModules(M,N) </C>
<P/>

Inputs two <M>FpG</M>-modules <M>M, N</M> arising as submodules in 
a common free module <M>(FG)^n</M> where <M>G</M> is a finite group 
and <M>F</M> the field of <M>p</M>-elements. It returns the 
<M>FpG</M>-Module arising as the sum of <M>M</M> and <M>N</M>.
</Item>
</Row>
<Row>
<Item>
<Index> SumOp</Index>
<C>SumOp(f,g) </C>
<P/>

Inputs two <M>FpG</M>-module homomorphisms <M>f,g:M \longrightarrow N</M>
with common sorce and common target. It returns the sum <M>f+g:M \longrightarrow N</M> . (This operation is also available using "+".
</Item>
</Row>

<Row>
<Item>
<Index> VectorsToFpGModuleWords</Index>
<C>VectorsToFpGModuleWords(M,L) </C>
 <P/>


Inputs an <M>FpG</M>-module <M>M</M> and a list 
<M>L=[v_1,\ldots ,v_k]</M> of vectors in <M>M</M>. 
It returns a list <M>L'= [x_1,...,x_k]</M> . Each 
<M>x_j=[[W_1,G_1],...,[W_t,G_t]]</M> 
is a list of integer pairs corresponding to an expression of 
<M>v_j</M> as a word
 <P/>
<M>  v_j  = g_1*w_1 + g_2*w_1 + ... + g_t*w_t </M>

<P/>
where

<P/>

<M>g_i=Elements(M!.group)[G_i]</M>
<P/>
<M>w_i=GeneratorsOfFpGModule(M)[W_i]</M>
 .

	  
</Item>
</Row>

</Table>
</Chapter>


