<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<!-- --------------------HEADER------------------------ -->
  <title>HAP Data Types</title>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <link rel="Stylesheet" href="HAPpagestyles.css" type="text/css"
 media="screen,print">
  <style type="text/css"></style>
</head>
<body>
<a href="../index.html"><small>HAP home</small></a>
<h2> HAP REPRESENTATIONS AND DATA TYPES </h2>
<div id="content">
<p>Much of the HAP package is aimed at computations related to specific
instances of the following.</p>
</div>
<div id="content">
<h3>A General Algebraic Problem</h3>
<p>
Let Z be an integral domain. Let Z[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>t</sub>]
be the free associative ring over Z generated by x<sub>1</sub>,...,x<sub>t</sub>.
Let A=Z[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>t</sub>]/J be a quotient
algebra.
Let M and N be A-modules. How can we calculate the modules</p>
<center> Tor<sup>A</sup><sub>k</sub>(M,N) and Ext<sub>A</sub><sup>k</sup>(M,N)
</center>
<p> for integers k &gt;=0?</p>
<p>Recall that these modules are defined in terms of a sequence of
module homomorphisms</p>
<center> ... ---&gt; R<sub>4</sub> ---&gt; R<sub>2</sub> ---&gt; R<sub>1</sub>
---&gt; R<sub>0</sub> </center>
<p>such that</p>
<div>
<li>(Freeness) Each R<sub>n</sub> is a free A-module.<br>
</li>
<li>(Exactness) The image of R<sub>n+1</sub> ---&gt; R<sub>n </sub>equals
the kernel of R<sub>n</sub> ---&gt; R<sub>n-1</sub> for all n&gt;0.<br>
</li>
<li>(Augmentation) The cokernel of R<sub>1 </sub> ---&gt; R<sub>0</sub>
is isomorphic to the module M.</li>
</div>
<p>
Such a sequence of module homomorphisms is said to be a <em>free
A-resolution of the module</em> M.</p>
<p> Applying the functor Hom<sub>A</sub>(-,N) to each module in the
resolution R<sub>*</sub> we obtain a sequence of induced module
homomorphisms</p>
<center> d<sup>n</sup> : Hom<sub>A</sub>(R<sub>n</sub>,N) ---&gt; Hom<sub>A</sub>(R<sub>n+1</sub>,N)
(n&gt;=0).
</center>
<p> The module Ext<sub>A</sub><sup>k</sup>(M,N) is defined to be the <em>homology</em>
module</p>
<center>Ext<sub>A</sub><sup>k</sup>(M,N) = ker (d<sup>k</sup>) / image
(d<sup>k-1</sup>)
</center>
<p> with the convention d<sup>-1</sup>=0. It can be shown that the
isomorphism type of the module Ext<sub>A</sub><sup>k</sup>(M,N) is
unchanged if we change the choice of free resolution R<sub>*</sub>.</p>
<p>The module Tor<sup>A</sup><sub>k</sub> is defined analogously by
tensoring each free module R<sub>n</sub> with the module N over A, and
taking homology of the resulting sequence of tensored modules.
</p>
</div>
<div id="content">
<p>In particular, HAP has functions aimed at the following.
</p>
<h3> Special Case. </h3>
<p> Let Z be the ring of integers. Let G be a group. Let A=ZG be the
group ring of G. Let M=Z be the ring of integers considered as a
trivial ZG-module. Let N be an arbitrary ZG-module. The cohomology and
homology of the group G are defined as
</p>
<center>H<sup>k</sup>(G,N) = Ext<sub>ZG</sub><sup>k</sup>(Z,N) ,</center>
<center>H<sub>k</sub>(G,N) = Tor<sup>ZG</sup><sub>k</sub>(Z,N) .</center>
<p>
The <em> integral (co)homology</em> of G is of particular interest and
is defined to be the case where N equals the trivial module Z. The <em>
mod p (co)homology</em> is a useful approximation to integral
(co)homology and corresponds to letting N be the field Z<sub>p</sub> of
p elements with trivial action of G. </p>
</div>
<div id="content">
<p>HAP also contains some functions aimed at the following.</p>
<h3>A General Topological Problem</h3>
<p> Let X be a bounded subspace of Euclidean space <span
 style="font-weight: bold;">R</span><sup>n</sup> arising as a union of
unit n-cubes whose vertices have integer coordinates. The subspace X
might arise as a topological model of experimental data (such as a
medical image) or it might be the more traditional kind of CW-complex
studied in classical algebraic topology. How can we efficiently compute
the cohomology groups (and possibly even some homotopy groups) of X ?<br>
</p>
</div>
<div id="content">
<h3> Representations</h3>
<p>
The typical HAP user does not need to know the precise details of how
mathematical concepts are represented in HAP. However, a user who
wishes to extend the HAP package will
need such details. </p>
<p>
Some of the concepts from homological algebra are represented in HAP
using existing GAP data types (first table). Other concepts are
represented using
new gap data types (second table). For each of the new data types there
is a boolean valued function <tt> IsHapNameOfDataType(X) </tt>. </p>
</div>
<div>
<br>
<br>
<h3> HAP Representations using existing GAP data types</h3>
<br>
<table style="width: 100%;" cellspacing="10">
  <tbody>
    <tr>
      <td>Free
ZG-module <br>
      <br>
(words) </td>
      <td>Let
eltsG be a (partial) listing of elements in some group G (which could
be finite or infinite).&nbsp; In order
to represent a word w in a free ZG-module M of rank n we use a
list of integer pairs w=[ [i<sub>1</sub>,g<sub>1</sub>], [i<sub>2</sub>,g<sub>2</sub>],
..., [i<sub>k</sub>,g<sub>k</sub>] ]. The
integers i<sub>j</sub> lie in the range between -n and n and correspond
to the
free ZG-generators of M and their additive inverses. The integers g<sub>j</sub>
are positive and correspond to the group element eltsG[g<sub>j</sub>].
The (partial) listing eltsG may contain duplicate copies of
elements of G. <br>
      </td>
    </tr>
    <tr>
      <td>Additive
Functor <br>
      <br>
(Additive
Contravariant
Functor) </td>
      <td>A
functor T(X) is a function which inputs either a ZG-resolution X=R,
or else an equivariant chain map between resolutions X=(f: ---&gt; S) .
      <br>
      <br>
      <li>If&nbsp; X=R then T(R) is a chain complex.</li>
      <li>If X=(f:R ---&gt; S) then T(X) is a chain map T(R) ---&gt;
T(S).</li>
      <br>
(A contavariant functor is similar, except that T(R) is a cochain
complex and T(R---&gt;S) is a cochain map T(S) ---&gt; T(R). ) </td>
    </tr>
    <tr>
      <td>Homology
group <br>
      <br>
(Cohomology
group) </td>
      <td>An homology group H<sub>n</sub>(C) is a finitely generated
abelian
group and is
represented by a list whose integer entries are the torsion
coefficients of the group. <br>
      <br>
A homomorphism H<sub>n</sub>(C) ---&gt; H<sub>n</sub>(D) of homology
groups is represented as a group homomorphism between finitely
presented groups. <br>
      <br>
(Cohomology groups and homomorphisms of cohomology groups are
represented similarly.) </td>
    </tr>
    <tr>
      <td>Homology
vector
space<br>
      <br>
(Cohomology
vector
space) </td>
      <td>When the ground ring Z is the field of p-elements or the
rationals, then
an homology group H<sub>n</sub>(C) is actually a vector space and is
thus represented by a single integer - the dimension of the vector
space.
(The prime p is omitted in this representation.)<br>
      <br>
A homomorphism H<sub>n</sub>(C) ---&gt; H<sub>n</sub>(D) of homology
vector spaces is however represented as a group homomorphism between
finitely presented groups. <br>
      <br>
(Mod p cohomology groups and homomorphisms of cohomology groups are
represented similarly.) </td>
    </tr>
    <tr>
    </tr>
    <tr>
      <td>Mtx-module </td>
      <td>A module over the mod p group ring FG of a finite group G can
be
represented using the standard GAP notion of "meat-axe" module. Such a
module consists of a record M with components <br>
      <br>
      <li><tt>M.generators</tt> is a list of matrices over the field of
p elements that generates a homomorphic image of G.</li>
      <li><tt>M.gens</tt> is a list of generators of G corresponding to
the matrices in <tt>M.generators</tt>. (This component is optional. In
its abscence it is assumed that <tt>M.gens </tt> = <tt>M.generators</tt>).
      </li>
      <li><tt>M.dimension</tt> is the dimension of the underlying
vector space.</li>
      <li><tt>M.field</tt> is the field F=GF(p) .</li>
      <li><tt>M.isMTXModule<tt> is the boolean <tt>true</tt>.</tt></tt></li>
      <br>
All modules in HAP are assumed to act on the left. (So care is needed
because in GAP's standard meataxe functions the matrix action is
assumed to be on the right. A left meataxe module can be converted to a
right module by replacing generators with their transposes.) </td>
    </tr>
    <tr>
      <td>Coxeter
diagram <br>
      </td>
      <td>A
Coxeter diagram is a finite graph (with at most one edge between a pair
of vertices) whose edges are labelled by integers n&gt;2 or
n = infinity. The graph is represented as a list D = [L<sub>1</sub>,
... L<sub>t</sub>] in which each term is itself a list L<sub>k</sub> =
[v<sub>k</sub>, [u<sub>k1</sub>,n<sub>k1</sub>], [u<sub>k2</sub>,n<sub>k2</sub>],
... [u<sub>km</sub>,n<sub>km</sub>]] such that vertex v<sub>k</sub> is
conneconcatenationted to vertex u<sub>kj</sub> by an edge with label n<sub>kj</sub>.
It is necessary and sufficient to list just those vertices u<sub>kj</sub>
&gt; v<sub>k</sub>. We set n<sub>kj</sub>=0 when the edge label is
infinity. <br>
      </td>
    </tr>
    <tr>
      <td>Graph of Groups <br>
      </td>
      <td>A
graph of groups is a finite graph (with at most one edge between a pair
of vertices) whose vertices are labelled by groups and whose edges are
labelled by pairs [f,g] of group monomorphisms f:S ---&gt;G, g:S
---&gt; H with common
source and with ranges G and H equal to the labels of the boundary
vertices of the edge.<br>
      <br>
Such a graph is represented as a list D = [L<sub>1</sub>, ... L<sub>t</sub>]
where each L<sub>i</sub> is either a group G or a pair of group
monomorphisms [f,g]. Each group G arising as a term in the list, or as
the range or source of a monomorphism in the list, must be such that
HasName(G) is true. Furthermore, distinct groups must have dirrerent
names.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Array<br>
      </td>
      <td style="vertical-align: top;">An array is defined recursively
to be a list A=[A<sub>1</sub>,...,A<sub>n</sub>] of arrays with equal
dimension and array size. A no entry A<sub>i</sub> is a list then the
array is said to have dimension 1 and&nbsp; array size n. In general:<br>
      <ul>
        <li>Dimension(A) =1 + Dimension(A<sub>i</sub>).</li>
        <li>Array_Size(A) = Concatenation(Array_size(A<sub>i</sub>),[n]).</li>
      </ul>
      </td>
    </tr>
  </tbody>
</table>
</div>
<div>
<br>
<br>
<h3> HAP Representations involving new GAP data types</h3>
<table style="width: 100%;" cellspacing="10">
  <tbody>
    <tr>
      <td>ZG-resolution </td>
      <td>A <em>ZG-resolution</em> means a <span
 style="font-weight: bold;">free</span>
ZG-resolution of the trivial
ZG-module Z, where G is a group and Z is the ring of integers (or the
ring of integers modulo p, or the ring of rationals). <br>
      <br>
A
ZG-resolution&nbsp; ... ---&gt; M<sub>n</sub> ---&gt; M<sub>n-1</sub>
---&gt; ... ---&gt; M<sub>1</sub>
---&gt; M<sub>0</sub> &#8594; Z<big> </big>is represented by a component
object R
with the
following components.<br>
      <br>
      <li> <tt>R!.dimension(k)</tt> is a function which returns the
ZG-rank of the module M<sub>k</sub>.</li>
      <li> <tt>R!.boundary(k,j)</tt>
is a function which returns
the image in M<sub>k-1</sub> of the j-th free generator of M<sub>k</sub>.</li>
      <li> <tt>R!.homotopy(k,[i,g]) </tt>is a function which returns
the
image in M<sub>k+1</sub>,
under a contracting homotopy M<sub>k</sub> ---&gt; M<sub>k+1</sub>, of
the element [[i,g]]&nbsp; in M<sub>k</sub>. (The elements [[i,g]]
freely generate M<sub>k</sub> as an abelian group.) For some
resolutions a contracting homotopy is not constructed, in which case <tt>R!.homotopy</tt>
is set equal to "fail". (For some resolutions a component <tt>R!.partialHomotopy(k,w)</tt>
is available. This is a function which returns the preimage in M<sub>k+1</sub>
of an arbitrary word w in the kernel of&nbsp; M<sub>k</sub> ---&gt; M<sub>k-1&nbsp;</sub>
.)<br>
      </li>
      <li> <tt>R!.elts</tt> is a (partial) list of (possibly
duplicate)
elements in G. In some cases <tt>R!.elts</tt> is a pseudo list (see
below) and not a list.<br>
      </li>
      <li><tt>R!.group</tt> is the group in question (and could be a
permutation group, matrix group, finitely presented group etc.).</li>
      <li><tt>R!.properties</tt> is a list of pairs ["name", value]
where "name" is a string and value is a numerical or boolean value.
Example pairs are:&nbsp; ["length", n] which records that there are n
terms in the resolution; ["characteristic", p] which records the
characteristic of Z; ["reduced", true] which record that M<sub>0</sub>
is isomorphic to ZG; ["type","resolution"] which records the type of
the object R.</li>
      <br>
The operation <tt>IsHapResoluton(R)</tt>
returns "true" for a resolution.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Non-free ZG-resolution<br>
      </td>
      <td style="vertical-align: top;">A non-free ZG-resolution is an
exact sequence of ZG-modules ... ---&gt; A<sub>n</sub> ---&gt; A<sub>n-1</sub>
---&gt; ... ---&gt; A<sub>1</sub>
---&gt; A<sub>0</sub> &#8594; Z in which the modules are not necessarily
free. We can represent such a sequence (non-uniquely) by first choosing
free modules M<sub>k</sub> mapping onto the A<sub>k</sub>&nbsp; and
then lifting the homomorphisms to a sequence ... ---&gt; M<sub>n</sub>
---&gt; M<sub>n-1</sub>
---&gt; ... ---&gt; M<sub>1</sub>
---&gt; M<sub>0</sub>&nbsp; of homomorphisms of free ZG-modules. Note
that in the lifted&nbsp; sequence homomorphisms will not in general
square to zero.<br>
      <br>
      <br>
A
non-free ZG-resolution&nbsp; ... ---&gt; M<sub>n</sub> ---&gt; M<sub>n-1</sub>
---&gt; ... ---&gt; M<sub>1</sub>
---&gt; M<sub>0</sub> &#8594; Z<big> </big>is represented by a component
object R
with the
following components.<br>
      <br>
      <li> <tt>R!.dimension(k)</tt> is a function which returns the
ZG-rank of the module M<sub>k</sub>.</li>
      <li> <tt>R!.boundary(k,j)</tt>
is a function which returns
the image in M<sub>k-1</sub> of the j-th free generator of M<sub>k</sub>.</li>
      <li> <tt>R!.homotopy(k,[i,g]) </tt>is a function which returns
the
image in M<sub>k+1</sub>,
under a contracting homotopy M<sub>k</sub> ---&gt; M<sub>k+1</sub>, of
the element [[i,g]]&nbsp; in M<sub>k</sub>. (The elements [[i,g]]
freely generate M<sub>k</sub> as an abelian group.) For most
non-free resolutions a contracting homotopy is not constructed, in
which case <tt>R!.homotopy</tt>
is set equal to "fail". <br>
      </li>
      <li> <tt>R!.elts</tt> is a (partial) list of (possibly
duplicate)
elements in G. In some cases <tt>R!.elts</tt> is a pseudo list (see
below) and not a list.<br>
      </li>
      <li><tt>R!.group</tt> is the group in question (and could be a
permutation group, matrix group, finitely presented group etc.).</li>
      <li><tt>R!.stabilizer(k,j)</tt> returns the subgroup of G
consisting of those elements that fix, up to sign, the i-th free
generator of M<sub>k</sub>.</li>
      <li><tt>R!.action(k,j,g)</tt> is a function which returns +1 or
-1
according to how the group element Elts[g] acts on the "orientation" of
the j-th
free generator in dimension k.<br>
      </li>
      <li><tt>R!.properties</tt> is a list of pairs ["name", value]
where "name" is a string and value is a numerical or boolean value.
Example pairs are:&nbsp; ["length", n] which records that there are n
terms in the resolution; ["characteristic", p] which records the
characteristic of Z; ["reduced", true] which record that M<sub>0</sub>
is isomorphic to ZG; ["type","resolution"] which records the type of
the object R.</li>
      <br>
The operation <tt>IsHapNonFreeResoluton(R)</tt>
returns "true" for a non-free resolution.<br>
&nbsp;&nbsp; <br>
      </td>
    </tr>
    <tr>
      <td>Equivariant
chain
map </td>
      <td>An
equivariant
chain mapping f : R ---&gt; S from a ZG-resolution to a ZG'-resolution
is
represented by a component object F with the following components.<br>
      <br>
      <li><tt>F!.source</tt> is the ZG-resolution R.</li>
      <li><tt>F!.target</tt> is the ZG'-resolution S.</li>
      <li><tt>F!.mapping(w,k) </tt>
is a
function which
returns the image in S<sub>k</sub>,
under the chain map, of
the element w=[ [i<sub>1</sub>,g<sub>1</sub>], [i<sub>2</sub>,g<sub>2</sub>],
..., [i<sub>k</sub>,g<sub>k</sub>] ]&nbsp; in R<sub>k</sub>.</li>
      <li><tt>F!.properties</tt>
is a list of pairs such as ["type", "equivariantChainMap"].</li>
      <br>
The operation <tt>IsHapEquivariantChainMap(F)</tt> returns "true" for
an equivariant chain map F.<br>
      </td>
    </tr>
    <tr>
      <td>Chain
complex <br>
      <br>
(Cochain
complex) </td>
      <td>A <em>chain complex </em>means
a chain complex of free Z-modules.<br>
      <br>
A chain complex&nbsp; ... ---&gt; C<sub>n</sub> ---&gt; C<sub>n-1</sub>
---&gt; ... ---&gt; C<sub>1</sub>
---&gt; C<sub>0&nbsp; </sub>is represented by a record C with the
following components.<br>
      <br>
      <li><tt>C!.dimension(k)</tt> is a function which returns the
Z-rank of the module C<sub>k</sub>.</li>
      <li><tt>C!.boundary(k,j) </tt>is a function which returns the
image in C<sub>k-1</sub> of the j-th free generator of C<sub>k</sub>.
(Elements in C<sub>k-1</sub> are represented in the obvious was as
vectors of length equal to the rank of C<sub>k-1</sub>.)<br>
      </li>
      <li><tt>C!.properties</tt> is a list of pairs ["name",value]
where "name" is a string and value is a numerical or boolean value.
Example pairs are:&nbsp; ["length", n] which would record that there
are n terms in the chain complex; ["characteristic", p] which would
record the characteristic of Z.</li>
      <br>
The operation <tt>IsHapChainComplex(C)</tt>
returns "true" for a chain complex C.<br>
      <br>
(A cochain complex&nbsp; ... &lt;--- C<sub>n</sub> &lt;--- C<sub>n-1</sub>
&lt;--- ... &lt;--- C<sub>1</sub>
&lt;--- C<sub>0&nbsp; </sub>is represented by a similar record
C.&nbsp; The difference is that <tt>C!.boundary(k,j)</tt> returns an
element in C<sub>k+1</sub>.) </td>
    </tr>
    <tr>
      <td>Chain
map <br>
      <br>
(Cochain
map) </td>
      <td>A
chain mapping f : C ---&gt; D between chain complexes is a component
object F
with the
following components.<br>
      <br>
      <li><tt>F!.source</tt> is the chain complex C.</li>
      <li><tt>F!.target</tt> is the chain complex D.</li>
      <li><tt>F!.mapping(v,k)</tt> is a
function which
returns the image in D<sub>k</sub>,
under the chain map, of
a vector v in C<sub>k</sub>.</li>
      <li><tt>F!.properties</tt>
is a list of pairs such as ["type", "chainMap"].</li>
      <br>
The operation <tt>IsHapEquivariantChainMap(F)</tt>
returns "true" for a chain map F.<br>
      <br>
(A cochain mapping is represented by a similar record.) </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Filtered chain compex<br>
      </td>
      <td style="vertical-align: top;">A <span
 style="font-style: italic;">filtered chain complex</span> means a
sequence F<sub>0</sub>C &lt; ... &lt; F<sub>t-1</sub>C &lt; F<sub>t</sub>C
of inclusions of chain complexes. We call the integer t the <span
 style="font-style: italic;">filtration length</span>. <br>
      <br>
A filtered chain complex is represented as a chain complex C with an
additional component and property:<br>
      <ul>
        <li><span style="font-family: monospace;">C!.filteredDimension(r,n)</span>
is a function which gives the number of free generators in degree n of
the chain complex F<sub>r</sub>C. Generators are usually ordered such
that the
first k generators of F<sub>r</sub>C<sub>n</sub> are also the first k
generators of&nbsp; F<sub>s</sub>C<sub>n</sub> for all s&gt;r and all
k; in this case <span style="font-family: monospace;">C!.properties</span>
contains the pair ["initial_inclusion",true]. Sometimes generators are
ordered such that the last k generators of F<sub>r</sub>C<sub>n</sub>
are also the last k
generators of&nbsp; F<sub>s</sub>C<sub>n</sub> for all s&gt;r and all
k; in this case <span style="font-family: monospace;">C!.properties</span>
contains the pair ["initial_inclusion",false]. <br>
        </li>
        <li><span style="font-family: monospace;">C!.properties</span>
contains the pair ["filtration_length",t] .</li>
      </ul>
The operations <span style="font-family: monospace;">IsHapFilteredChainComplex(C)</span>
and <span style="font-family: monospace;">IsHapChainComplex(C)</span>
both return "true".<br>
      </td>
    </tr>
    <tr>
      <td>FpG-module </td>
      <td>For
a finite group G, and the field F of p elements, a submodule of the
free FG-module FG<sup>n</sup> is represented by a component object M
with the following components:<br>
      <br>
      <li><tt>M!.group</tt> is the finite group G,</li>
      <li><tt>M!.characteristic</tt> is the prime p,</li>
      <li><tt>M!.matrix</tt>
is an echelon matrix whose rows form a basis for the underlying vector
space,</li>
      <li><tt>M!.action(g,M)</tt>
is a function that inputs an element g in G and a matrix M whose rows
are vectors in the vector space F<sup>n|G|</sup> of dimenion any
multiple of |G|. It returns the matrix got from M by letting g act on
columns.</li>
      <li><tt>M!.dimension</tt> is the dimension of the underlying
vector space.</li>
      <li><tt>M!.ambientDimension</tt>
is n|G| .</li>
      <br>
The operation <tt>IsHapFPGModule(M)</tt> returns "true" for an
FpG-module M. </td>
    </tr>
    <tr>
      <td>FpG-module
homomorphism </td>
      <td>A
homomorphism Phi:M ---&gt; N of FpG-modules (over a common group G and
field
F)&nbsp; is a component object with the following components:<br>
      <br>
      <li><tt>Phi!.source</tt> is the source module M.</li>
      <li><tt>Phi!.target</tt>
is the target module N.</li>
      <li><tt>Phi!.matrix</tt>
is a matrix A over the field F whose rows are
the images in N of those minimal generators of M produced using the
function <tt>GeneratorsOfFpGModule(M)</tt>.</li>
      <br>
The operation <tt>IsHapFPGModuleHomomorphism(Phi)</tt> returns "true"
for an
FpG-module homomorphism Phi. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">G-outer group</td>
      <td style="vertical-align: top;">We'll say that a group N is a
G-outer group if there is an associated function alpha:G
---&gt; Aut(N) which<span style="font-style: italic;"></span> induces a
homomorphism G
---&gt; Out(N).&nbsp; <br>
      <br>
A G-outer group is represented as a component
object A with the following components:
      <ul>
        <li><tt>A!.ActingGroup</tt>
is the group G.</li>
        <li><tt>A!.ActedGroup</tt> is the group N.</li>
        <li><tt>A!.OuterAction</tt> is a function which, to each g in G
and
each n in N,
returns an element <tt>A!.OuterAction(g,n) </tt>in N. The following
two
mathematical properties hold. (1) For each g in G the function <tt>A!.OuterAction(g,_)</tt>:N
---&gt; N is an automorphism. (2)
The function g---&gt; <tt>A!.OuterAction(g,_)</tt> induces a
homomorphism G
---&gt;
Out(N).&nbsp;</li>
      </ul>
The operation <span style="font-family: monospace;">IsGOuterGroup(M)</span>
returns "true" for a G-outer group M.<br>
      <br>
Note that a G-module N can be viewed as a G-outer group N for which <tt>IsAbelian(N)</tt>
returns the value <tt>True</tt>. For
conveninece we'll often refer to an abelian G-outer group as a G-module.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">G-outer group homomorphism<br>
      </td>
      <td style="vertical-align: top;">A
homomorphism Phi:M ---&gt; N of G-outer groups (over a common group
G)&nbsp; is a component object with the following components:<br>
      <br>
      <ul>
        <li><span style="font-family: monospace;">Phi!.Source</span> is
the source G-outer group.</li>
        <li><span style="font-family: monospace;">Phi!.Target</span> is
the target G-outer group.</li>
        <li><span style="font-family: monospace;">Phi!. Mapping </span>is
a GAP group homomorphism from the underlying group of M to the
underlying group of N.</li>
      </ul>
      <br>
The operation <span style="font-family: monospace;">IsGOuterGroupHomomorphism(Phi)</span>
returns "true" for a G-outer group homomorphism Phi.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">G-complex<br>
      <br>
(G-cocomplex)<br>
      </td>
      <td style="vertical-align: top;">A G-complex is a sequence ...
---&gt; C<sub>n</sub> ---&gt; C<sub>n-1</sub>
---&gt; ... ---&gt; C<sub>1</sub>
---&gt; C<sub>0</sub> of G-outer group homomorphisms over a common
group G such that Image(C<sub>n</sub> ---&gt; C<sub>n-1</sub>) is&nbsp;
a normal G-invariant subgroup of Kernel(C<sub>n-1</sub> ---&gt; C<sub>n-2</sub>).
In particular, when each C<sub>n</sub> is abelian it is a chain complex
of G-modules. <br>
      <br>
It is represented by a component object C with the following components:<br>
      <ul>
        <li><span style="font-family: monospace;">C!.boundary(n)</span>
is a function which returns the homomorphism C<sub>n</sub> ---&gt; C<sub>n-1</sub>
for n&gt;0.</li>
        <li><tt>C!.properties</tt> is a list of pairs ["name",value]
where "name" is a string and value is a numerical or boolean value.
Example pairs are:&nbsp; ["length", n] which would record that there
are n terms in the chain complex.</li>
      </ul>
The operation <span style="font-family: monospace;">IsHapGComplex(C)</span>
returns "true" for a G-complex C.<br>
      <br>
(A G-cocomplex&nbsp; ... &lt;--- C<sub>n</sub> &lt;--- C<sub>n-1</sub>
&lt;--- ... &lt;--- C<sub>1</sub>
&lt;--- C<sub>0&nbsp; </sub>is represented by a similar record
C.&nbsp; The difference is that <tt>C!.boundary(n)</tt> is a map C<sub>n</sub>
--&gt; C<sub>n+1</sub>.)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Simplicial Group<br>
      </td>
      <td style="vertical-align: top;">A simplicial group is
represented by a component object G with the following components:<br>
      <ul>
        <li><span style="font-family: monospace;">G!.groupsList</span>
is a list [G<sub>0</sub>, G<sub>1</sub>, ...] of the groups in each
degree up to some given degree n.</li>
        <li><span style="font-family: monospace;">G!.boundariesList</span>
is a list [D<sub>1</sub>, D<sub>2</sub>, ...] where D<sub>k</sub> is a
list of the k+1 boundary homomorphisms G<sub>k</sub> --&gt; G<sub>k-1</sub>.</li>
        <li><span style="font-family: monospace;">G!.degeneraciesList</span>
is a list [S<sub>0</sub>, S<sub>1</sub>, ...] where S<sub>k</sub>
is a list of the k+1 degeneracy homomorphisms G<sub>k</sub> --&gt; G<sub>k+1</sub>.</li>
        <li><span style="font-family: monospace;">G!.properties</span>
is a list of pairs ["name",value]
where "name" is a string and value is a numerical or boolean
value.&nbsp;</li>
      </ul>
The operation <span style="font-family: monospace;">IsHapSimplicialGroup(G)</span>
returns "true" for a simplicial group G.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Standard N-cocycle<br>
      </td>
      <td style="vertical-align: top;">A standard N-cocycle
f:G&times;G&times;...&times;G
---&gt; M of a group G with coefficients in an abelian G-outer group M
(i.e. a G-module M) is represented
as a component object F with the following components:<br>
      <ul>
        <li><tt>F!.Module</tt> is the G-module M.</li>
        <li><span style="font-family: monospace;">F!.Arity</span> is
the integer N.<br>
        </li>
        <li><tt>F!.Mapping</tt> is a function
which, for all g<sub>1</sub> ,...,, g<sub>N</sub> in G, returns an
element <tt>F!.Mapping(g<sub>1</sub>,g<sub>2</sub>,...,g<sub>N</sub>) </tt>in
M. The function
satisfies the N-cocycle condition.</li>
      </ul>
The operation <span style="font-family: monospace;">IsStandardNCocycle(F)</span>
returns "true" for a standard N-cocycle.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Cat-1-group<br>
      </td>
      <td style="vertical-align: top;">A cat-1-group is a group endowed
with a compatible category composition. It can be viewed as a group G
with endomorphisms s,t:G--&gt;G satisfying ss=s, ts=s, tt=t, st=t and
[Ker(s),Ker(t)]=1. It is represented as a component object C with the
following components.<br>
      <ul>
        <li><span style="font-family: monospace;">C!.sourceMap</span>
is
the group homomorphism s:G--&gt;G.</li>
        <li><span style="font-family: monospace;">C!.targetMap</span>
is
the group homomorphism t:G-&gt;G.</li>
      </ul>
The operation <span style="font-family: monospace;">IsHapCatOneGroup(C)</span>
returns "true" for a cat-1-group C. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Pure Cubical Complex <br>
      </td>
      <td style="vertical-align: top;">In HAP we use the term
"pure cubical complex" to mean a subspace of Euclidean n-space <span
 style="font-weight: bold;">R</span><sup>n</sup> arising as a union of
unit n-cubes whose vertices have integer coordinates. Such a space is
represented by a component object T having two components:<br>
      <ul>
        <li><span style="font-family: monospace;">T!.binaryArray</span>
is a list [b<sub>1</sub>, ... ,b<sub>n</sub>]
where the b<sub>i</sub> are <span style="font-style: italic;">binary
array</span> with common&nbsp; dimension and <span
 style="font-style: italic;">array size</span><span
 style="font-style: italic;"></span>.
(See below for the definition of these terms.)</li>
        <li><span style="font-family: monospace;">T!.properties</span>
is a list of pairs such as
["dimension",2], ["arraySize",[256,512] .</li>
      </ul>
A <span style="font-style: italic;">binary array</span> of <span
 style="font-style: italic;">dimension</span> 1 is just a list
b=[x<sub>1</sub>, ..., x<sub>n</sub>] where each x<sub>i</sub> is
either 0 or 1. The <span style="font-style: italic;">array size</span>
of b is defined to be&nbsp; [n] . <br>
      <br>
A <span style="font-style: italic;">binary array</span> of <span
 style="font-style: italic;">dimension</span> d&gt;1 is a list
b=[x<sub>1</sub>, ..., x<sub>n</sub>] where each x<sub>i</sub> is a
binary array of dimension d-1 and all x<sub>i</sub> have the
same array size. The <span style="font-style: italic;">array size</span>
of b is defined to be the list of integers got by appending n to the
array size of any x<sub>i</sub>.<br>
      <br>
The operation <span style="font-family: monospace;">IsHapPureCubicalComplex(T)</span>
returns "true" for a pure cubical complex T. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Filtered pure cubical complex<br>
      </td>
      <td style="vertical-align: top;">A filtered pure cubical complex
is a pure cubical complex M with an additional component<br>
      <ul>
        <li><span style="font-family: monospace;">M!.filtration</span>
is an array of non-negative integers of the same dimension as <span
 style="font-family: monospace;">M!.binaryArray</span>. The entry
M!.filtration[x] is less than or equal to t if and only if the t-th
term Mt of the filtration on M has Mt!.binaryArray[x]=1 .</li>
      </ul>
The operations <span style="font-family: monospace;">IsHapPureCubicalComplex(M)
and&nbsp;</span><span style="font-family: monospace;">IsHapFilteredPureCubicalComplex(M)</span>
returns "true" for a pure cubical complex M.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Cubical Complex </td>
      <td style="vertical-align: top;">In HAP we use the term
"cubical complex" to mean a cellular subspace of Euclidean n-space <span
 style="font-weight: bold;">R</span><sup>n</sup> arising as a union of
open unit m-cubes of varying degrees whose centres have integer
coordinates. Such a space is
represented by a component object T having two components:<br>
      <ul>
        <li><span style="font-family: monospace;">T!.binaryArray</span>
is a list [b<sub>1</sub>, ... ,b<sub>n</sub>]
where the b<sub>i</sub> are <span style="font-style: italic;">binary
array</span> with common&nbsp; dimension and <span
 style="font-style: italic;">array size</span><span
 style="font-style: italic;"></span>.
(See above for the definition of these terms.)</li>
        <li><span style="font-family: monospace;">T!.properties</span>
is a list of pairs such as
["dimension",2], ["arraySize",[256,512] .</li>
      </ul>
Each entry "1" in the array corresponds to a cell with centre
represented by the entry's coordinates. If all coordinates are odd then
the cell is a vertex. If all coordinates are even then the cell is an
n-cube.<br>
      <br>
The operation <span style="font-family: monospace;">IsHapCubicalComplex(T)</span>
returns "true" for a cubical complex T. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Filtered cubical complex</td>
      <td style="vertical-align: top;">A filtered cubical complex
is a cubical complex M with an additional component<br>
      <ul>
        <li><span style="font-family: monospace;">M!.filtration</span>
is an array of non-negative integers of the same dimension as <span
 style="font-family: monospace;">M!.binaryArray</span>. The entry
M!.filtration[x] is less than or equal to t if and only if the t-th
term Mt of the filtration on M has Mt!.binaryArray[x]=1 .</li>
      </ul>
The operations <span style="font-family: monospace;">IsHapCubicalComplex(M)
and&nbsp;</span><span style="font-family: monospace;">IsHapFilteredCubicalComplex(M)</span>
returns "true" for a cubical complex M.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Cubical Complex&nbsp; with
Vector Field<br>
      </td>
      <td style="vertical-align: top;">A discret vector field on a
cubical complex T is represented by adding the following two components
to T:<br>
      <ul>
        <li><span style="font-family: monospace;">T!.vectors</span> is
an array with the same dimensions as T!.binaryArray. Let x be&nbsp; the
coordinate vector of an array position. We set T!.vectors[x]=0 iif the
cell with coordinate vector x is critical.&nbsp; We set T!.vectors[x]=y
if there is a vector starting at the cell with coordinates x and ending
at the cell with coordinates y.<br>
        </li>
        <li><span style="font-family: monospace;">T!.rewrite</span>(w)
is a function which inputs a list w=[x<sub>1</sub>, ..., x<sub>k</sub>]
of coordinate vectors of cells. It returns a list [y<sub>1</sub>, ..., y<sub>m</sub>]
of the coordinate vectors of those critical cells to which the input
cells w get&nbsp; homotopied. <br>
        </li>
      </ul>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Simplicial Complex </td>
      <td style="vertical-align: top;">A simplicial complex is
represented by a component object T with the following components:<br>
      <ul>
        <li><span style="font-family: monospace;">T!.vertices </span>is
the list of vertices.</li>
        <li><span style="font-family: monospace;">T!.simplices(n,i)</span>
is a function that returns the list of vertices in the i-th n-simplex.</li>
        <li><span style="font-family: monospace;">T!.nrSimplices(n)</span>
is a function which returns the number of n-dimensional simplices.</li>
        <li><span style="font-family: monospace;">T!.enumeratedSimplex(v)</span>
is a function which inputs a list v of vertices representing an
n-simplex and returns the position of this simplex in the list of all
n-simplices.</li>
        <li><span style="font-family: monospace;">T!.properties</span>&nbsp;
is a list of pairs such as
["dimension",2] .</li>
      </ul>
The operation <span style="font-family: monospace;">IsHapSimplicialComplex(T)</span>
returns "true" for a simplicial complex T.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Regular CW-Complex<br>
      </td>
      <td style="vertical-align: top;">A regular CW-complex is
represented by a component object Y with the following components:<br>
      <ul>
        <li><span style="font-family: monospace;">Y!.boundaries[n+1][k]</span>
is a list of integers [t,a<sub>1</sub>,...,a<sub>t</sub>]
where a<sub>i</sub> denote the (n-1)-dimensional cells in the boundary
of the k-th cell of dimension n. <br>
        </li>
        <li><span style="font-family: monospace;">Y!.coboundaries[n+1][k]</span>
is a list of integers [t,a<sub>1</sub>,...,a<sub>t</sub>]
where a<sub>i</sub> denote the (n+1)-dimensional cells in the
coboundary
of the k-th cell of dimension n. <br>
        </li>
        <li><span style="font-family: monospace;">Y!.nrCells(n)</span>
is a function returning the number of cells in dimension n.<br>
        </li>
        <li><span style="font-family: monospace;">Y!.properties</span>
is a list of properties.</li>
      </ul>
The following optional components may also be present (or else present
but set equal to fail):<br>
      <ul>
        <li><span style="font-family: monospace;">Y!.vectorField[n][k]</span>
is either unbound or equal to an
integer k' . The latter case represents a "flow" from the k-th cell of
dimension n to the k'-th cell of dimension n-1. <br>
        </li>
        <li><span style="font-family: FreeMono;"><span
 style="font-family: monospace;">Y!.inverseVectorField[n][k']</span> </span>is
either unbound or equal
to an integer k . The latter case represents
a "flow" from the k-th cell of dimension n to the k'-th cell of
dimension n-1.</li>
        <li><span style="font-family: monospace;">Y!.criticalCells</span>
is a list of pairs [n,k] representing the fact that the k-th cell in
dimension n is <span style="font-style: italic;">critical</span> (i.e.
is not involved in any flow).</li>
        <li><span style="font-family: monospace;">Y!.orientation[n][k]</span>
is a list of the incidence numbers of the cells in the boundary of the
k-th cell of dimension n. So Y!.orientation[n][k][j] is the incidence
number (+1 or -1) of the j-th cell in the boundary.<br>
        </li>
      </ul>
The operation <span style="font-family: monospace;">IsHapRegularCWComplex(Y)</span>
returns "true" for a regular CW-complex Y.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Pseudo list<br>
      </td>
      <td style="vertical-align: top;">A pseudolist L has the same
basic
functionality as that of a list except that:<br>
      <br>
      <li>Position(L,x) uses a binary search rather than a linear
search.</li>
      <li>The elements in L must be distinct.<br>
      </li>
      <li>Add(L,x) returns a pseudolist with last entry equal to x.</li>
      <li>Not all list functions and methods apply to L. <br>
      </li>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Sparse matrix<br>
      <br>
      </td>
      <td style="vertical-align: top;">A sparse matrix is a component
object M with the following components:<br>
      <ul>
        <li><span style="font-family: monospace;">M!.mat</span> is a
list of lists. The entries in <span style="font-family: monospace;">M!.mat[i]</span>
are pairs of integers [j,k] denoting that the represented matrix has
entry k in the i-th row and j-th column.</li>
        <li><span style="font-family: monospace;">M!.characteristic</span>
denotes the characteristic of the field from which the matrix entries
are taken</li>
        <li><span style="font-family: monospace;">M!.rows</span> is the
integer number of rows in the matrix.</li>
        <li><span style="font-family: monospace;">M!.cols</span> is the
integer number of columns in the matrix.</li>
      </ul>
The operation <span style="font-family: monospace;">IsHapSparseMat(M)</span>
returns "true" for a sparse matrix M.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Sparse chain complex<br>
      </td>
      <td style="vertical-align: top;">A <em>sparse chain complex </em>means
a chain complex of free Z-modules.<br>
      <br>
A sparse chain complex&nbsp; ... ---&gt; C<sub>n</sub> ---&gt; C<sub>n-1</sub>
---&gt; ... ---&gt; C<sub>1</sub>
---&gt; C<sub>0&nbsp; </sub>is represented by a record C with the
following components.<br>
      <br>
      <li><tt>C!.dimension(k)</tt> is a function which returns the
Z-rank of the module C<sub>k</sub>.</li>
      <li><tt>C!.boundary(k,j) </tt>is a function which returns the
image in C<sub>k-1</sub> of the j-th free generator of C<sub>k</sub>.
(Elements in C<sub>k-1</sub> are represented in the obvious way as
sparse vectors of length equal to the rank of C<sub>k-1</sub>.)<br>
      </li>
      <li><tt>C!.properties</tt> is a list of pairs ["name",value]
where "name" is a string and value is a numerical or boolean value.
Example pairs are:&nbsp; ["length", n] which would record that there
are n terms in the chain complex; ["characteristic", p] which would
record the characteristic of Z.</li>
      <br>
The operation <tt>IsHapSparseChainComplex(C)</tt>
returns "true" for a sparse chain complex C.<br>
      </td>
    </tr>
  </tbody>
</table>
</div>
</body>
</html>
