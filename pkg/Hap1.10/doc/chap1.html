<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (HAP) - Chapter 1: Resolutions of the ground ring</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body><a href="../www/index.html"><small>HAP home</small></a>



<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap0.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap2.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X8735FC5E7BB5CE3A" name="X8735FC5E7BB5CE3A"></a></p>
<div class="ChapSects"><a href="chap1.html#X8735FC5E7BB5CE3A">1 <span class="Heading">Resolutions of the ground ring</span></a>
</div>

<h3>1 <span class="Heading">Resolutions of the ground ring</span></h3>

<div class="pcenter"><table cellspacing="10"  class="GAPDocTable">
<tr>
<td class="tdleft"><code class="code">TietzeReducedResolution(R)</code></p>

<p>Inputs a ZG-resolution R and returns a ZG-resolution S which is obtained from R by applying "Tietze like operations" in each dimension. The hope is that S has fewer free generators than R.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionArithmeticGroup("PSL(4,Z)",n)</code></p>

<p>Inputs a positive integer n and one of the following strings: <br /> <br /> "SL(2,Z)" , "SL(3,Z)" , "PGL(3,Z[i])" , "PGL(3,Eisenstein_Integers)" , "PSL(4,Z)" , "PSL(4,Z)_b" , "PSL(4,Z)_c" , "PSL(4,Z)_d" , "Sp(4,Z)" <br /> <br /> or one of the following strings <br /> <br /> "SL(2,Z[sqrt(-2)])" , "SL(2,Z[sqrt(-7)])" , "SL(2,Z[sqrt(-11)])" , "SL(2,Z[sqrt(-19)])" , "SL(2,Z[sqrt(-43)])" , "SL(2,Z[sqrt(-67)])" , "SL(2,Z[sqrt(-163)])" <br /> <br /> It returns n terms of a free ZG-resolution for the group G described by the string. (Subscripts _b , _c , _d denote alternative non-free ZG-resolutions for a given group G.)<br /> <br /> Data for the first list of resolutions was provided provided by <strong class="button">Mathieu Dutour</strong>. Data for the second list was provided by <strong class="button">Alexander Rahm</strong>.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">FreeGResolution(P,n)</code> <code class="code">FreeGResolution(P,n,p)</code></p>

<p>Inputs a non-free ZG-resolution P with finite stabilizer groups, and a positive integer n. It returns a free ZG-resolution of length equal to the minimum of n and the length of P. If one requires only a mod p resolution then the prime p can be entered as an optional third argument.</p>

<p>The free resolution is returned without a contracting homotopy.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionGTree(P,n)</code></p>

<p>Inputs a non-free ZG-resolution P of dimension 1 (i.e. a G-tree) with finite stabilizer groups, and a positive integer n. It returns a free ZG-resolution of length equal to n.</p>

<p>If P has a contracting homotopy then the free resolution is returned with a contracting homotopy.</p>

<p>This function was written by <strong class="button"> Bui Anh Tuan</strong>.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionSL2Z(p,n)</code></p>

<p>Inputs positive integers m, n and returns n terms of a ZG-resolution for the group G=SL(2,Z[1/m]) .</p>

<p>This function is joint work with <strong class="button">Bui Anh Tuan</strong>.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionAbelianGroup(L,n)</code> <code class="code">ResolutionAbelianGroup(G,n)</code></p>

<p>Inputs a list L:=[m_1,m_2, ..., m_d] of nonnegative integers, and a positive integer n. It returns n terms of a ZG-resolution for the abelian group G=Z_L[1]+Z_L[2]+···+Z_L[d] .</p>

<p>If G is finite then the first argument can also be the abelian group G itself.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionAlmostCrystalGroup(G,n)</code></p>

<p>Inputs a positive integer n and an almost crystallographic pcp group G. It returns n terms of a free ZG-resolution. (A group is almost crystallographic if it is nilpotent-by-finite and has no non-trivial finite normal subgroup. Such groups can be constructed using the ACLIB package.)</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionAlmostCrystalQuotient(G,n,c)</code> <code class="code">ResolutionAlmostCrystalQuotient(G,n,c,false)</code></p>

<p>An almost crystallographic group G is an extension of a finite group P by a nilpotent group T, and has no non-trivial finite normal subgroup. We define the relative lower central series by setting T_1=T and T_i+1=[T_i,G].</p>

<p>This function inputs an almost crystallographic group G together with positive integers n and c. It returns n terms of a free ZQ-resolution R for the group Q=G/T_c .</p>

<p>In addition to the usual components, the resolution R has the component R.quotientHomomorphism which gives the quotient homomorphism G --&gt; Q.</p>

<p>If a fourth optional variable is set equal to "false" then the function omits to test whether Q is finite and a "more canonical" resolution is constructed.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionArtinGroup(D,n)</code></p>

<p>Inputs a Coxeter diagram D and an integer n&gt;1. It returns n terms of a free ZG-resolution R where G is the Artin monoid associated to D. It is conjectured that R is also a free resolution for the Artin group G. The conjecture is known to hold in <span class="URL"><a href="../www/SideLinks/About/aboutArtinGroups.html">certain cases</a></span>.</p>

<p>G=R.group is infinite and returned as a finitely presented group. The list R.elts is a partial listing of the elements of G which grows as R is used. Initially R.elts is empty and then, any time the boundary of a resolution generator is called, R.elts is updated to include elements of G involved in the boundary.</p>

<p>The contracting homotopy on R has not yet been implemented! Furthermore, the group G is currently returned only as a finitely presented group (without any method for solving the word problem).</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionAsphericalPresentation(F,R,n)</code></p>

<p>Inputs a free group F, a set R of words in F which constitute an aspherical presentation for a group G, and a positive integer n. (Asphericity can be a difficult property to verify. The function IsAspherical(F,R) could be of help.)</p>

<p>The function returns n terms of a free ZG-resolution R which has generators in dimensions &lt; 3 only. No contracting homotopy on R will be returned.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionBieberbachGroup( G ) </code> <code class="code">ResolutionBieberbachGroup( G, v ) </code></p>

<p>Inputs a torsion free crystallographic group G, also known as a Bieberbach group, represented using AffineCrystGroupOnRight as in the GAP package Cryst. It also optionally inputs a choice of vector v in the euclidean space R^n on which G acts freely. The function returns n+1 terms of the free ZG-resolution of Z arising as the cellular chain complex of the tesselation of R^n by the Dirichlet-Voronoi fundamental domain determined by v.</p>

<p>This function is part of the HAPcryst package written by <strong class="button">Marc Roeder</strong> and thus requires the HAPcryst package to be loaded.</p>

<p>The function requires the use of Polymake software.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionCoxeterGroup(D,n)</code></p>

<p>Inputs a Coxeter diagram D and an integer n&gt;1. It returns k terms of a free ZG-resolution R where G is the Coxeter group associated to D. Here k is the maximum of n and the number of vertices in the Coxeter diagram. At present the implementation is only for finite Coxeter groups and the group G is returned as a permutation group. The contracting homotopy on R has not yet been implemented!</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionDirectProduct(R,S) </code> <code class="code">ResolutionDirectProduct(R,S,"internal")</code></p>

<p>Inputs a ZG-resolution R and ZH-resolution S. It outputs a ZD-resolution for the direct product D=G x H.</p>

<p>If G and H lie in a common group K, and if they commute and have trivial intersection, then an optional third variable "internal" can be used. This will force D to be the subgroup GH in K.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionExtension(g,R,S) </code> <code class="code">ResolutionExtension(g,R, S,"TestFiniteness")</code> <code class="code">ResolutionExtension(g,R,S,"NoTest",GmapE)</code></p>

<p>Inputs a surjective group homomorphism g:E --&gt; G with kernel N. It also inputs a ZN-resolution R and a ZG-resolution S. It returns a ZE-resolution. The groups E and G can be infinite.</p>

<p>If an optional fourth argument is set equal to "TestFiniteness" then the groups N and G will be tested to see if they are finite. If they are finite then some speed saving routines will be invoked.</p>

<p>If the homomorphism g is such that the GAP function PreImagesElement(g,x) doesn't work, then a function GmapE() should be included as a fifth input. For any x in G this function should return an element GmapE(x) in E which gets mapped onto x by g.</p>

<p>The contracting homotopy on the ZE-resolution has not yet been fully implemented for infinite groups!</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionFiniteDirectProduct(R,S) </code> <code class="code">ResolutionFiniteDirectProduct(R,S, "internal")</code></p>

<p>Inputs a ZG-resolution R and ZH-resolution S where G and H are finite groups. It outputs a ZD-resolution for the direct product D=G×H.</p>

<p>If G and H lie in a common group K, and if they commute and have trivial intersection, then an optional third variable "internal" can be used. This will force D to be the subgroup GH in K.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionFiniteExtension(gensE,gensG,R,n)</code> <code class="code">ResolutionFiniteExtension(gensE,gensG,R,n,true) </code> <code class="code">ResolutionFiniteExtension(gensE,gensG,R,n,false,S) </code></p>

<p>Inputs: a set gensE of generators for a finite group E; a set gensG equal to the image of gensE in a quotient group G of E; a ZG-resolution R up to dimension at least n; a positive integer n. It uses the TwistedTensorProduct() construction to return n terms of a ZE-resolution.</p>

<p>The function has an optional fourth argument which, when set equal to "true", invokes tietze reductions in the construction of a resolution for the kernel of E --&gt; G.</p>

<p>If a ZN-resolution S is available, where N is the kernel of the quotient E --&gt; G, then this can be incorporated into the computations using an optional fifth argument.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionFiniteGroup(gens,n)</code> <code class="code">ResolutionFiniteGroup(gens,n,true)</code> <code class="code">ResolutionFiniteGroup(gens,n,false,p) </code> <code class="code">ResolutionFiniteGroup(gens,n,false,0,"extendible") </code></p>

<p>Inputs a set gens of generators for a finite group G and a positive integer n. It outputs n terms of a ZG-resolution.</p>

<p>The function has an optional third argument which, when set equal to true, invokes tietze reductions in the construction of the resolution.</p>

<p>The function has an optional fourth argument which, when set equal to a prime p, records the fact that the resolution will only be used for mod p calculations. This could speed up subsequent constructions.</p>

<p>The function has an optional fifth argument which, when set equal to "extendible", returns a resolution whose length can be increased using the command R!.extend() .</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionFiniteSubgroup(R,K)</code> <code class="code">ResolutionFiniteSubgroup(R,gensG,gensK)</code></p>

<p>Inputs a ZG-resolution for a finite group G and a subgroup K of index |G:K|. It returns a free ZK-resolution whose ZK-rank is |G:K| times the ZG-rank in each dimension.</p>

<p>Generating sets gensG, gensK for G and K can also be input to the function (though the method does not depend on a choice of generators).</p>

<p>This ZK-resolution is not reduced. ie. it has more than one generator in dimension 0.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionGraphOfGroups(D,n) </code> <code class="code">ResolutionGraphOfGroups(D,n,L) </code></p>

<p>Inputs a graph of groups D and a positive integer n. It returns n terms of a free ZG-resolution for the fundamental group G of D.</p>

<p>An optional third argument L=[R_1 , ... , R_t] can be used to list (in any order) free resolutions for some/all of the vertex and edge groups in D. If for some vertex or edge group no resolution is listed in L then the function ResolutionFiniteGroup() will be used to try to construct the resolution.</p>

<p>The ZG-resolution is usually not reduced. i.e. it has more than one generator in dimension 0.</p>

<p>The contracting homotopy on the ZG-resolution has not yet been implemented! Furthermore, the group G is currently returned only as a finitely presented group (without any method for solving the word problem).</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionNilpotentGroup(G,n) </code> <code class="code">ResolutionNilpotentGroup(G,n,"TestFiniteness")</code></p>

<p>Inputs a nilpotent group G and positive integer n. It returns n terms of a free ZG-resolution. The resolution is computed using a divide-and-conquer technique involving the lower central series.</p>

<p>This function can be applied to infinite groups G. For finite groups the function ResolutionNormalSeries() probably gives better results.</p>

<p>If an optional third argument is set equal to "TestFiniteness" then the groups N and G will be tested to see if they are finite. If they are finite then some speed saving routines will be invoked.</p>

<p>The contracting homotopy on the ZE-resolution has not yet been fully implemented for infinite groups.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionNormalSeries(L,n) </code> <code class="code">ResolutionNormalSeries(L,n,true)</code> <code class="code">ResolutionNormalSeries(L,n,false,p)</code></p>

<p>Inputs a positive integer n and a list L = [L_1 , ..., L_k] of normal subgroups L_i of a finite group G satisfying G = L_1 &gt; L2 &gt;... &gt;L_k. Alternatively, L = [gensL_1, ... gensL_k] can be a list of generating sets for the L_i (and these particular generators will be used in the construction of resolutions). It returns a ZG-resolution by repeatedly using the function ResolutionFiniteExtension().</p>

<p>The function has an optional third argument which, if set equal to true, invokes tietze reductions in the construction of resolutions.</p>

<p>The function has an optional fourth argument which, if set equal to p &gt; 0, produces a resolution which is only valid for mod p calculations.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionPrimePowerGroup(P,n) </code> <code class="code">ResolutionPrimePowerGroup(G,n,p)</code></p>

<p>Inputs a p-group P and integer n&gt;0. It uses GAP's standard linear algebra functions over the field F of p elements to construct a free FP-resolution for mod p calculations only. The resolution is minimal - meaning that the number of generators of R_n equals the rank of H_n(P,F).</p>

<p>The function can also be used to obtain a free non-minimal FG-resolution of a small group G of non-prime-power order. In this case the prime p must be entered as the third input variable. (In the non-prime-power case the algorithm is naive and not very good.)</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionSmallFpGroup(G,n) </code> <code class="code">ResolutionSmallFpGroup(G,n,p) </code></p>

<p>Inputs a small finitely presented group G and an integer n&gt;0. It returns n terms of a ZG-resolution which, in dimensions 1 and 2, corresponds to the given presentation for G. The method returns no contracting homotopy for the resolution.</p>

<p>The function has an optional fourth argument which, when set equal to a prime p, records the fact that the resolution will only be used for mod p calculations. This could speed up subsequent constructions.</p>

<p>This function was written by Irina Kholodna.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionSubgroup(R,K)</code></p>

<p>Inputs a ZG-resolution for an (infinite) group G and a subgroup K of finite index |G:K|. It returns a free ZK-resolution whose ZK-rank is |G:K| times the ZG-rank in each dimension.</p>

<p>If G is finite then the function ResolutionFiniteSubgroup(R,G,K) will probably work better. In particular, resolutions from this function probably won't work with the function EquivariantChainMap(). This ZK-resolution is not reduced. i.e. it has more than one generator in dimension 0.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ResolutionSubnormalSeries(L,n) </code></p>

<p>Inputs a positive integer n and a list L = [L_1 , ... , L_k] of subgroups L_i of a finite group G=L_1 such that L_1 &gt; L2 ... &gt; L_k is a subnormal series in G (meaning that each L_i+1 must be normal in L_i). It returns a ZG-resolution by repeatedly using the function ResolutionFiniteExtension().</p>

<p>If L is a series of normal subgroups in G then the function ResolutionNormalSeries(L,n) will possibly work more efficiently.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">TwistedTensorProduct(R,S,EhomG,GmapE,NhomE,NEhomN,EltsE,Mult,InvE)</code></p>

<p>Inputs a ZG-resolution R, a ZN-resolution S, and other data relating to a short exact sequence 1 --&gt; N --&gt; E --&gt; G --&gt; 1. It uses a perturbation technique of CTC Wall to construct a ZE-resolution F. Both G and N could be infinite. The "length" of F is equal to the minimum of the "length"s of R and S. The resolution R needs no contracting homotopy if no such homotopy is requied for F.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ConjugatedResolution(R,x)</code></p>

<p>Inputs a ZG-resoluton R and an element x from some group containing G. It returns a ZG^x-resolution S where the group G^x is the conjugate of G by x. (The component S!.elts will be a pseudolist rather than a list.)</td>
</tr>
<tr>
<td class="tdleft"><code class="code">RecalculateIncidenceNumbers(R)</code></p>

<p>Inputs a ZG-resoluton R which arises as the cellular chain complex of a regular CW-complex. (Thus the boundary of any cell is a list of distinct cells.) It recalculates the incidence numbers for R. If it is applied to a resolution that is not regular then a wrong answer may be returned.</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap0.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap2.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
