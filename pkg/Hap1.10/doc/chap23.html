<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (HAP) - Chapter 23: Cubical Complexes</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body><a href="../www/index.html"><small>HAP home</small></a>



<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap22.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap24.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X7D67D5F3820637AD" name="X7D67D5F3820637AD"></a></p>
<div class="ChapSects"><a href="chap23.html#X7D67D5F3820637AD">23 <span class="Heading">Cubical Complexes</span></a>
</div>

<h3>23 <span class="Heading">Cubical Complexes</span></h3>

<div class="pcenter"><table cellspacing="10"  class="GAPDocTable">
<tr>
<td class="tdleft"><code class="code">ArrayToPureCubicalComplexA,n)</code></p>

<p>Inputs an integer array A of dimension d and an integer n. It returns a d-dimensional pure cubical complex corresponding to the black/white "image" determined by the threshold n and the values of the entries in A. (Integers below the threshold correspond to a black pixel, and higher integers correspond to a white pixel.)</td>
</tr>
<tr>
<td class="tdleft"><code class="code">PureCubicalComplexA,n)</code></p>

<p>Inputs a binary array A of dimension d. It returns the corresponding d-dimensional pure cubical complex.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">PureCubicalComplexIntersection(S,T)</code></p>

<p>Inputs two pure cubical complexes with common dimension and array size. It returns the intersection of the two complexes. (An entry in the binary array of the intersection has value 1 if and only if the corresponding entries in the binary arrays of S and T both have value 1.)</td>
</tr>
<tr>
<td class="tdleft"><code class="code">PureCubicalComplexUnion(S,T)</code></p>

<p>Inputs two pure cubical complexes with common dimension and array size. It returns the union of the two complexes. (An entry in the binary array of the union has value 1 if and only if at least one of the corresponding entries in the binary arrays of S and T has value 1.)</td>
</tr>
<tr>
<td class="tdleft"><code class="code">PureCubicalComplexDifference(S,T)</code></p>

<p>Inputs two pure cubical complexes with common dimension and array size. It returns the difference S-T. (An entry in the binary array of the difference has value 1 if and only if the corresponding entry in the binary array of S is 1 and the corresponding entry in the binary array of T is 0.)</td>
</tr>
<tr>
<td class="tdleft"><code class="code"> ReadImageAsPureCubicalComplex("file.png",n)</code></p>

<p>Reads an image file ("file.png", "file.eps", "file.bmp" etc) and an integer n between 0 and 765. It returns a 2-dimensional pure cubical complex based on the black/white version of the image determined by the threshold n.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ReadImageSequenceAsPureCubicalComplex("directory",n)</code></p>

<p>Reads the name of a directory containing a sequence of image files (ordered alphanumerically), and an integer n between 0 and 765. It returns a 3-dimensional pure cubical complex based on the black/white version of the images determined by the threshold n.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">Size(T)</code></p>

<p>This returns the number of non-zero entries in the binary array of the cubical complex, or pure cubical complex T.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">Dimension(T)</code></p>

<p>This returns the dimension of the cubical complex, or pure cubical complex T.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">WritePureCubicalComplexAsImage(T,"filename","ext")</code></p>

<p>Inputs a 2-dimensional pure cubical complex T, and a filename followed by its extension (e.g. "myfile" followed by "png"). A black/white image is saved to the file.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ViewPureCubicalComplex(T)</code> <code class="code">ViewPureCubicalComplex(T,"mozilla")</code></p>

<p>Inputs a 2-dimensional pure cubical complex T, and optionally a command such as "mozilla" for viewing image files. A black/white image is displayed.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">Homology(T,n)</code> <code class="code">Homology(T)</code></p>

<p>Inputs a pure cubical complex, or cubical complex, or simplicial complex T and a non-negative integer n. It returns the n-th integral homology of T as a list of torsion integers. If no value of n is input then the list of all homologies of T in dimensions 0 to Dimension(T) is returned .</td>
</tr>
<tr>
<td class="tdleft"><code class="code">Bettinumbers(T,n)</code> <code class="code">Bettinumbers(T)</code></p>

<p>Inputs a pure cubical complex, or cubical complex, simplicial complex or chain complex T and a non-negative integer n. The rank of the n-th rational homology group H_n(T, Q) is returned. If no value for n is input then the list of Betti numbers in dimensions 0 to Dimension(T) is returned .</td>
</tr>
<tr>
<td class="tdleft"><code class="code">DirectProductOfPureCubicalComplexes(M,N)</code></p>

<p>Inputs two pure cubical complexes M,N and returns their direct product D as a pure cubical complex. The dimension of D is the sum of the dimensions of M and N.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">SuspensionOfPureCubicalComplex(M)</code></p>

<p>Inputs a pure cubical complex M and returns a pure cubical complex with the homotopy type of the suspension of M.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">EulerCharacteristic(T)</code></p>

<p>Inputs a pure cubical complex, or cubical complex, or simplicial complex T and returns its Euler characteristic.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">PathComponentOfPureCubicalComplex(T,n)</code></p>

<p>Inputs a pure cubical complex T and an integer n in the rane 1, ..., Bettinumbers(T)[1] . It returns the n-th path component of T as a pure cubical complex. The value n=0 is also allowed, in which case the number of path components is returned.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ChainComplex(T)</code></p>

<p>Inputs a pure cubical complex, or cubical complex, or simplicial complex T and returns the (often very large) cellular chain complex of T.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ChainComplexOfPair(T,S)</code></p>

<p>Inputs a pure cubical complex or cubical complex T and subcomplex S. It returns the quotient C(T)/C(S) of cellular chain complexes.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ExcisedPureCubicalPair(T,S)</code></p>

<p>Inputs a pure cubical complex T and subcomplex S. It returns the pair [T\ intS, S\ intS]) of pure cubical complexes where intS is the pure cubical complex obtained from S by removing its boundary.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ChainInclusionOfPureCubicalPair(S,T)</code></p>

<p>Inputs a pure cubical complex T and subcomplex S. It returns the chain inclusion C(S) -&gt; C(T) of cellular chain complexes.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ChainMapOfPureCubicalPairs(M,S,N,T)</code></p>

<p>Inputs a pure cubical complex N and subcomplexes M, T and S in T. It returns the chain map C(M/S) -&gt; C(N/T) of quotient cellular chain complexes.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ContractPureCubicalComplex(T)</code></p>

<p>Inputs a pure cubical complex T of dimension d and removes d-dimensional cells from T without changing the homotopy type of T. When the function has been applied, no further d-cells can be removed from T without changing its homotopy type. This function modifies T.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ContractedComplex(T)</code></p>

<p>Inputs a pure cubical complex T and returns a structural copy of the complex obtained from T by applying the function ContractPureCubicalComplex(T).</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ZigZagContractedPureCubicalComplex(T)</code></p>

<p>Inputs a pure cubical complex T and returns a homotopy equivalent pure cubical complex S. The aim is for S to involve fewer cells than T and certainly to involve no more cells than T.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ContractCubicalComplex(T)</code></p>

<p>Inputs a cubical complex T and removes cells without changing the homotopy type of T. It changes T. In particular, it adds the components T.vectors and T.rewrite of a discrete vector field.</p>

<p>At present this function only works for cubical complexes of dimension 2 or 3.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">DVFReducedCubicalComplex(T)</code></p>

<p>Inputs a cubical complex T and returns a non-regular cubical complex R by constructing a discrete vector field. The vector field is designed to minimize the number of critical cells in R at the cost of allowing cell attaching maps that are not homeomorphisms on boundaries.</p>

<p>At present this function works only for 2- and 3-dimensional cubical complexes.</p>

<p>The function ChainComplex(R) can be used to obtain the cellular chain complex of R.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">SkeletonOfCubicalComplex(T,n)</code></p>

<p>Inputs a cubical complex, or pure cubical complex T and positive integer n. It returns the n-skeleton of T as a cubical complex.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ContractibleSubomplexOfPureCubicalComplex(T)</code></p>

<p>Inputs a pure cubical complex T and returns a maximal contractible pure cubical subcomplex.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">AcyclicSubomplexOfPureCubicalComplex(T)</code></p>

<p>Inputs a pure cubical complex T and returns a (not necessarily connected) pure cubical subcomplex having trivial homology in all degrees greater than 0.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">HomotopyEquivalentMaximalPureCubicalSubcomplex(T,S)</code></p>

<p>Inputs a pure cubical complex T together with a pure cubical subcomplex S. It returns a pure cubical subcomplex H of T which contains S and is maximal with respect to the property that it is homotopy equivalent to S.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">HomotopyEquivalentMinimalPureCubicalSubcomplex(T,S)</code></p>

<p>Inputs a pure cubical complex T together with a pure cubical subcomplex S. It returns a pure cubical subcomplex H of T which contains S and is minimal with respect to the property that it is homotopy equivalent to T.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">BoundaryOfPureCubicalComplex(T)</code></p>

<p>Inputs a pure cubical complex T and returns its boundary as a pure cubical complex. The boundary consists of all cubes which have one or more facets that lie in just the one cube.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">SingularitiesOfPureCubicalComplex(T,radius,tolerance)</code></p>

<p>Inputs a pure cubical complex T together with a positive integer "radius" and an integer "tolerance" in the range 1..100. It returns the pure cubical subcomplex of those cells in the boundary where the boundary is not differentiable. (The method for deciding differentiability at a point is crude/discrete, prone to errors and depends on the radius and tolerance.)</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ThickenedPureCubicalComplex(T)</code></p>

<p>Inputs a pure cubical complex T and returns a pure cubical complex S. If a euclidean cube is in T then this cube and all its neighbouring cubes are included in S.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">CropPureCubicalComplex(T)</code></p>

<p>Inputs a pure cubical complex T and returns a pure cubical complex S obtained from T by removing any "zero boundary sheets" of the binary array. Thus S and T are isometric as euclidean spaces but there may be fewer zero entries in the binary array for S.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">BoundingPureCubicalComplex(T)</code></p>

<p>Inputs a pure cubical complex T and returns a contractible pure cubical complex S containing T.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">MorseFiltration(M,i,t,bool)</code> <code class="code">MorseFiltration(M,i,t)</code></p>

<p>Inputs a pure cubical complex M of dimension d, an integer i between 1 and d, a positive integer t and a boolean value True or False. The function returns a list [M_1, M_2, ..., M_t] of pure cubical complexes with M_k a subcomplex of M_k+1. The list is constructed by setting all slices of M perpendicular to the i-th axis equal to zero if they meet the ith axis at a sufficiently high coordinate (if bool=True) or sufficiently low coordinate (if bool=False).</p>

<p>If the variable bool is not specified then it is assumed to have the value True.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ComplementOfPureCubicalComplex(T)</code></p>

<p>Inputs a pure cubical complex T and returns a pure cubical complex S. A euclidean cube is in S precisely when the cube is not in T.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">PureCubicalComplexToTextFile(file,M)</code></p>

<p>Inputs a pure cubical complex M and a string containing the address of a file. A representation of this complex is written to the file in a format that can be read by the CAPD (Computer Assisted Proofs in Dynamics) software developed by Marian Mrozek and others.</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap22.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap24.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
