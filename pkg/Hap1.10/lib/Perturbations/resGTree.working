#(C) Bui Anh Tuan

InstallGlobalFunction(ResolutionGTree,
function(arg)
local 
	R,n,EltsG,G,i,L,
	StabRes,StabGrps,Triple2Pair,Quad2One,GrpsRes,Pair2Quad,Quad2Pair,
	Dimension,Hmap,pos,Mult,AlgRed,AppendList,CorrectList,Boundary,
	ChangeSign,Homotopy,FinalHomotopy,
	StRes,hmap;
R:=arg[1];
n:=arg[2];
EltsG:=R!.elts;
G:=R!.group;

#############################################
pos:=function(g)
if Position(R!.elts,g)=fail then 
	Add(R!.elts,g); 
fi;
return Position(R!.elts,g);
end;
#############################################
AlgRed:=function(g)
local l,x;
l:=[];
for x in g do
	if Position(l,[-x[1],x[2]])=fail then Add(l,x); 
	else 
		Remove(l,Position(l,[-x[1],x[2]]));
	fi;
od;
return l;
end;
#############################################
AppendList:=function(a,b)
Append(a,b);
return a;
end;
#############################################
Mult:=function(g,w)
local 
	l,x;
l:=[];
if R!.elts[g]=[] then return [];fi;
Append(l,List(w,y->[y[1],pos(R!.elts[g]*R!.elts[y[2]])]));
return AlgRed(l);
end;
##############################################
GrpsRes:=function(G,n)
local 
	iso,Q,res;
iso:=RegularActionHomomorphism(G);
Q:=Image(iso);
res:=ResolutionFiniteGroup(Q,n);
res!.group:=G;
res!.elts:=List(res!.elts,x->PreImagesRepresentative(iso,x));
return res;
end;
#############################################
StabGrps:= List([0..Length(R)],n->
           List([1..R!.dimension(n)], k->R!.stabilizer(n,k))); 
StabRes:=[];
for L in StabGrps do
Add(StabRes,List(L,	
g->ExtendScalars(GrpsRes(g,n),G,EltsG))
);
od;
#############################################
CorrectList:=function(list)
local 
	l,i;
if list=[] then return [];fi;
l:=StructuralCopy(list[1]);
for i in [2..Length(list)] do
		Append(l,StructuralCopy(list[i]));
	od;
return l;
end;
##############################################
ChangeSign:=function(list)
return List(list,x->[-x[1],x[2]]);
end;
############################################
Quad2One:=function(p,q,r,s)
local
	n,d,i;
n:=0;
i:=SignInt(s);
s:=AbsInt(s);
d:=List([1..R!.dimension(p)],x->StabRes[p+1][x]!.dimension(q));
for i in [1..r-1] do
	n:=n+d[i];
od;
n:=n+s;
return i*n;
end;
############################################
Triple2Pair:=function(p,q,n)
local 
	r,s,d,i;
r:=0;
d:=List([1..R!.dimension(p)],x->StabRes[p+1][x]!.dimension(q));
i:=SignInt(n);
n:=AbsInt(n);
while n>0 do
	r:=r+1;
	s:=n;
	n:=n-d[r];
od;
return [r,i*s];
end;
############################################
Hmap:=function(p,q,r,s)     #Hmap:A(p,q)->A(p-1,q), acts on the (r,s) th-generator of A(p,q)
local 
	i,l,d0,m;
if p<>1 then return [];
else
	if q=0 then return R!.boundary(1,Quad2One(p,q,r,s));
	else
		l:=[];m:=[];
		d0:=List(StabRes[p+1][r]!.boundary(q,s),x->[R!.action(p,r,x[2])*x[1],x[2]]);
		return AlgRed(CorrectList(AppendList(l,List(List(AlgRed(CorrectList(List(d0,x->Mult(x[2],Hmap(p,q-1,r,x[1]))))),x->[Triple2Pair(p-1,q-1,x[1]),x[2]]),x->List(StabRes[p][x[1][1]]!.homotopy(q-1,[x[1][2],x[2]]),y->[Quad2One(p-1,q-1,x[1][1],y[1]),y[2]])))));
	fi;
fi;
end;
##############################################
Pair2Quad:=function(k,n)
local 
	p,q,r,s,i,temp,j1,j2;
temp:=0;
for j1 in [0..k] do
	for j2 in [1..R!.dimension(j1)] do
		temp:=temp+StabRes[j1+1][j2]!.dimension(k-j1);
	od;
od;
if n>temp then return "generator does not exist";fi;
p:=-1;
i:=SignInt(n);
n:=AbsInt(n);
while n>0 do;
	p:=p+1;
	r:=0;
	while (n>0 and r<R!.dimension(p)) do
		r:=r+1;
		s:=n;
		n:=n-StabRes[p+1][r]!.dimension(k-p);
	od;
od;
q:=k-p;
return [p,q,r,i*s];
end;
##############################################
Quad2Pair:=function(p,q,r,s)
local
	k,n,i,j;
k:=p+q;
n:=0;
for i in [0..p-1] do
	for j in [1..R!.dimension(i)] do
		n:=n+StabRes[i+1][j]!.dimension(k-i);
	od;
od;	
for i in [1..r-1] do
	n:=n+StabRes[p+1][i]!.dimension(k-p);
od;
n:=n+AbsInt(s);
return [k,SignInt(s)*n];
end;
##############################################
Boundary:=function(k,n)
local
	d,l,p,q,r,s,w;
w:=Pair2Quad(k,n);
p:=w[1];q:=w[2];r:=w[3];s:=w[4];
d:=[];
if q<>0 then 
	l:=StructuralCopy(List(StabRes[p+1][r]!.boundary(q,s),x->[Quad2Pair(p,q-1,r,R!.action(p,r,x[2])*x[1])[2],x[2]]));
	Append(d,StructuralCopy(l));
fi;
if IsEvenInt(q) then 
	Append(d,StructuralCopy(Hmap(p,q,r,s)));
else
	Append(d,StructuralCopy(ChangeSign(Hmap(p,q,r,s))));
fi;
return AlgRed(d);	
end;
##############################################
Dimension:=function(n)
local
	dim,p,i;
dim:=0;
for p in [0..n] do
	for i in [1..R!.dimension(p)] do
		dim:=dim+StabRes[p+1][i]!.dimension(n-p);
	od;
od;
return dim;
end;
##############################################
Homotopy:=function(n,w)
local 
	t,g,h0,h1,e,h,dh,
	p,q,r,s,v,m;
#if w=[] then return [];fi;
t:=w[1];
g:=w[2];
e:=[];
h:=[];
v:=Pair2Quad(n,t);#Print(v);
p:=v[1];q:=v[2];r:=v[3];s:=v[4];
if n=0 then
	#Print(R!.homotopy(n,w));
	#Print(List(R!.homotopy(n,w),x->Mult(x[2],Hmap(p,q,r,x[1]))));
	#Print(CorrectList(List(R!.homotopy(n,w),x->Mult(x[2],Hmap(p,q,r,x[1])))));
	#Print(Hmap(p,q,r,1));
	#Print(R!.homotopy(n,w));
	#Print(CorrectList(List(R!.homotopy(n,w),x->Mult(x[2],Hmap(p,q,r,x[1])))));
	e:=AlgRed(CorrectList(List(AlgRed(CorrectList(List(R!.homotopy(n,w),x->Mult(x[2],Hmap(p+1,q,r,x[1]))))),y->StabRes[Pair2Quad(n,y[1])[1]+1][Pair2Quad(n,y[1])[3]]!.homotopy(q,[Pair2Quad(n,y[1])[4],y[2]]))));
	#Print(e);
	h0:=StabRes[p+1][r]!.homotopy(0,[s,g]);
	#Print(h0);
	h1:=List(R!.homotopy(n,w),x->[Quad2Pair(p+1,q,Triple2Pair(p+1,q,x[1])[1],Triple2Pair(p+1,q,x[1])[2])[2],x[2]]);
	Append(h,ChangeSign(e));
	Append(h,h0);
	Append(h,h1);
	return AlgRed(h);
else
	if p=0 then 
	  h0:=StabRes[p+1][r]!.homotopy(q,[s,g]);
	  Append(h,h0);
	else
	s:=R!.action(1,1,g)*s;
	#Print("(p,q,r,t)",[p,q,r,s],"\n");
	m:=StabRes[p+1][r]!.homotopy(q,[s,g]);
	#Print("m",m,"\n");
	
	#Print("H01",h0,"\n");
	#Print("action",R!.action(1,1,g),"\n");
	#if R!.action(1,1,g)=-1 then Print("abc"); h0:=NegateWord(h0);fi;
	m:=List(m,x->[R!.action(1,1,x[2])*x[1],x[2]]);
	h0:=List(m,x->[2*x[1],x[2]]);
	#Print("h0= ",h0,"\n");
	Append(h,h0);
	dh:=AlgRed(CorrectList(List(m,x->Mult(x[2],Hmap(p,q+1,r,x[1])))));
	#Print("Hmap",List(m,x->Mult(x[2],Hmap(p,q+1,r,x[1]))),"\n");
	#Print("h",List(AlgRed(CorrectList(List(m,x->Mult(x[2],Hmap(p,q+1,r,x[1]))))),y->StabRes[Pair2Quad(n,y[1])[1]+1][Pair2Quad(n,y[1])[3]]!.homotopy(q,[Pair2Quad(n,y[1])[4],y[2]])),"\n");
	#e:=AlgRed(CorrectList(List(AlgRed(CorrectList(List(m,x->Mult(x[2],Hmap(p,q+1,r,x[1]))))),y->StabRes[Pair2Quad(n,y[1])[1]+1][Pair2Quad(n,y[1])[3]]!.homotopy(q,[Pair2Quad(n,y[1])[4],y[2]]))));
	e:=AlgRed(CorrectList(List(dh,x->StabRes[1][1]!.homotopy(q+1,x))));
	#Print("e",e,"\n");	
	if IsEvenInt(q) then 
	  Append(h,e);
	else Append(h,ChangeSign(e));fi;
	fi;
	return AlgRed(h);
fi;
end;
##############################################
FinalHomotopy:=function(n,w)
if R!.group=SL(2,Integers) then return Homotopy(n,w);
else return fail;
fi;
end;
##############################################
StRes:=function(n,k)
return StabRes[n+1][k];
end;

##############################################
return Objectify(HapResolution,
                rec(
                dimension:=Dimension,
                boundary:=Boundary,
                homotopy:=FinalHomotopy,
                elts:=R!.elts,
                group:=R!.group,
		stres:=StRes,
		hmap:=Hmap,
                properties:=
                   [["length",n],
                    ["initial_inclusion",true],
                    ["type","resolution"],
                    ["characteristic",EvaluateProperty(R,"characteristic")]  ]	));
end);
