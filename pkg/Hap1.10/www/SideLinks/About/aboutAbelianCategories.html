<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
  <title>AboutHap</title>
</head>
<body
 style="color: rgb(0, 0, 153); background-color: rgb(204, 255, 255);"
 alink="#000066" link="#000066" vlink="#000066">
<br>
<table
 style="text-align: left; margin-left: auto; margin-right: auto; color: rgb(0, 0, 102);"
 border="0" cellpadding="20" cellspacing="10">
  <tbody>
    <tr align="center">
      <th style="vertical-align: top;">
      <table style="width: 100%; text-align: left;" cellpadding="2"
 cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><a
 href="aboutParallel.html"><small style="color: rgb(0, 0, 102);">Previous</small></a><br>
            </td>
            <td
 style="text-align: center; vertical-align: top; color: rgb(0, 0, 102);"><big><span
 style="font-weight: bold;">About HAP: Towards programming in abelian
categories<br>
            </span></big></td>
            <td style="text-align: right; vertical-align: top;"><span
 style="text-decoration: underline;"></span> <small><a
 href="aboutPerformance.html"><small style="color: rgb(0, 0, 102);">Next</small></a></small></td>
          </tr>
        </tbody>
      </table>
      </th>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); text-align: left;">
      <div style="text-align: center;"></div>
      <h3 style="text-align: center;">Motivation</h3>
Category Theory is a
ubiquitous and well-tested framework for relating different algebraic
theories. Some categories (such as Vector Spaces or ZG-Modules or
Abelian groups) are abelian and thus admit all of the general
constructions of homological algebra (such as chain complexs, mapping
cones, spectral sequences and so forth). Other categories (such as
Groups) are not abelian but do admit some important categorical
properties (such as the existence of an initial object and a terminal
object). In a given category some object may have special properties
(such as being projective); some arrows may also have special
properties (such as being normal or being an epimorphism). These
special properties are relative to the category (e.g. a ZG-module may
be projective in the category of Abelian Groups but not in the category
of ZG-Modules). Different algebraic theories can be related via
Functors (such as the forgetful functor from ZG-Modules to Abelian
Groups, or the functorial equivalence between Crossed Modules and
Cat-1-Groups). Functors can also be used to describe certain algebraic
constructions (such as group cohomology). Functors are themselves
arrows and can have properties (such as that of being an equivalence or
an isomorphism). Some mathematical properties are actually properties
of functors. (For example, "freeness" is a property of an adjoint pair
of functors.)<br>
      <br>
Although (small) categories are interesting algebraic structures in
their own right, this page is interested in Category Theory as
a language for moving objects between algebraic structures and as a
language for implementing general algorithms/constructions in such a
way that they can be applied in a range of different algebraic
situations. We need to distinguish between algebraic properties (such
as "the group A is an abelian group") and categorical properties (such
as "the group A is an object in the category of abelian groups"). If we
have a method that works for all permutation groups, then it also
works for all abelian permutation groups.&nbsp; However, if we have an
implementation of a construction that works for all permutation groups
in the category of groups, it does not follow that it works correctly
for permutation groups in the category of abelian groups. For instance,
coproducts are different in these two categories.<br>
      <br>
We are aiming at a hierarchical tree in which any function in a higher
setting
can be applied (indirectly) to all lower settings in the tree. A
piece of the tree is as follows.<br>
      <br>
      <div style="text-align: center;"><img
 style="width: 779px; height: 507px;" alt="" src="cats.png"><br>
      </div>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">
      <div style="text-align: center;"></div>
      <h3 style="text-align: center;">Implementation</h3>
We introduce Eilenberg and Mac Lane's notion into GAP using the
following table. We choose our terminology so that it is consistent
with the standard mathematical notion of "category" yet does not clash
with GAP's existing use of the word "category".<br>
      <br>
      <br>
      <table
 style="text-align: left; width: 80%; margin-left: auto; margin-right: auto;"
 border="5" cellpadding="15" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">
            <h3>Eilenberg-Mac Lane Concept</h3>
            </td>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">
            <h3>&nbsp;Our GAP implementation</h3>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Name
of a category&nbsp;&nbsp; <br>
            </td>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Immutable
global variable such as Category_Of_Groups<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Properties
of a category<br>
            <br>
            </td>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Property
of the category name such as IsAbelian(Category_Of_Groups)<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">An
object X in the category C<br>
            </td>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Component
object X with attributes:<br>
            <ul>
              <li>CategoryName(X)</li>
              <li>Object(X) has a value such as a group or an FpGModule.</li>
            </ul>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">For
each object X in C there is an identity arrow.<br>
            </td>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Operation
IdentityArrow(X) which returns the identity 1:X--&gt;X.<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">An
arrow f in the category C<br>
            </td>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Component
object f with attributes<br>
            <ul>
              <li>CategoryName(f)</li>
              <li>Source(f)&nbsp; a category object</li>
              <li>Target(f)&nbsp; a category object</li>
              <li>Mapping(f) such that something like
IsGroupHomomorphism() is true</li>
            </ul>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Categorical
property of an object or arrow X<br>
            </td>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">A
GAP property of X<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Functors
and Natural Transformations<br>
            </td>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Yet
to be added. Functors are functions&nbsp; with attributes such as
HasFunctorName(X).<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">Composition
of arrows f:A-&gt;B and g:B-&gt;C and, in an additive category,
addition of&nbsp; arrows g,h:B-&gt;C <br>
            </td>
            <td style="vertical-align: top; color: rgb(0, 0, 102);">g*f<br>
and <br>
g+h<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      <br>
We plan to implement general homological constructions such as "total
complex of a multi-complex" using a small and portable language. This
language will apply to "diagrams in a category" enabling one, for
example, to transform a multi-complex into its total chain complex. A
"diagram" will be a function D with an indexing set S and category C;
for each s in S the function will yield an arrow D(s) in C.<br>
      <br>
      <br>
The following HAP session is a start in this direction.<br>
      </td>
    </tr>
    <tr>
      <td
 style="background-color: rgb(255, 255, 204); vertical-align: top;">gap&gt;
#This session illustrates a start on the category theory approach for
CHA. <br>
      <br>
gap&gt; G:=Group((1,2),(4,5),(6,7,8));;<br>
gap&gt; phi:=GroupHomomorphismByImages(G,G,<br>
&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[(1,2),(4,5),(6,7,8)],[(4,5),(1,2),(7,8,6)]);;<br>
      <br>
gap&gt; CG:=CategoricalEnrichment(G,Category_Of_Groups);;<br>
gap&gt; PHI:=CategoricalEnrichment(phi,Category_Of_Groups);;<br>
      <br>
gap&gt; #So CG is an object in the category of groups and PHI is<br>
gap&gt; #an arrow in the category of groups.<br>
      <br>
gap&gt; #The idea is that in ANY category the following general<br>
gap&gt; #notation should work. (There is currently no implementation of<br>
gap&gt; # "pull-back", "push-out", "terminal object" etc. etc.)<br>
      <br>
gap&gt; PHI*PHI=PHI;<br>
false<br>
      <br>
gap&gt; PHI+PHI-PHI=PHI;<br>
true<br>
      <br>
gap&gt; (PHI + PHI)*PHI = (PHI*PHI) + (PHI+PHI);<br>
false<br>
      <br>
gap&gt; (PHI + PHI)*PHI = (PHI*PHI) + (PHI*PHI);<br>
true<br>
      <br>
gap&gt; #The last line is essentially a commutative diagram. The<br>
gap&gt; #line before it is a diagram which does not commute.<br>
      <br>
gap&gt; #Suppose that we need to know if PHI belongs to a category<br>
gap&gt; #in which there is an initial object.<br>
      <br>
gap&gt; HasInitialObject(CategoryName(PHI));<br>
true<br>
      <br>
gap&gt; #Suppose we need to know if some power of the endomorphism PHI<br>
gap&gt; #is equal to the identity<br>
      <br>
gap&gt; PHI=IdentityArrow(Source(PHI));<br>
false<br>
gap&gt; PHI*PHI=IdentityArrow(Source(PHI));<br>
true<br>
      <br>
gap&gt; #Suppose we want to know if THETA*PHI is the trivial arrow,<br>
gap&gt; #where THETA is defined as follows<br>
gap&gt; Q:=Group((6,7,8));;<br>
gap&gt; theta:=GroupHomomorphismByImages(G,Q,[(1,2),(4,5),(6,7,8)],<br>
&gt; [(), (), (6,7,8)]);;<br>
gap&gt; THETA:=CategoricalEnrichment(theta,Category_Of_Groups);;<br>
      <br>
gap&gt; #To test if THETA*PHI is trivial we do the following.<br>
      <br>
gap&gt;
THETA*PHI=InitialArrow(Target(THETA))*TerminalArrow(Source(PHI));<br>
false<br>
      <br>
gap&gt; #Suppose we want to access the source of PHI as a group.<br>
gap&gt; #This won't give categorical information but it will<br>
gap&gt; #yield algebraic properties such as its order. The command
"Order"<br>
gap&gt; #won't be in the categorical programming language.<br>
      <br>
gap&gt; Object(Source(PHI));<br>
Group([ (1,2), (4,5), (6,7,8) ])<br>
gap&gt; Order(Object(Source(PHI)));<br>
12<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <table
 style="margin-left: auto; margin-right: auto; width: 100%; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;"><a
 style="color: rgb(0, 0, 102);" href="aboutParallel.html">Previous
Page</a><br>
            </td>
            <td style="text-align: center; vertical-align: top;"><a
 href="aboutContents.html"><span style="color: rgb(0, 0, 102);">Contents</span></a><br>
            </td>
            <td style="text-align: right; vertical-align: top;"><a
 href="aboutPerformance.html"><span style="color: rgb(0, 0, 102);">Next
page</span><br>
            </a> </td>
          </tr>
        </tbody>
      </table>
      <a href="aboutTopology.html"><br>
      </a> </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
