% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}
\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}
\definecolor{FuncColor}{rgb}{1.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,1.0}

\usepackage{fancyvrb}

\usepackage{pslatex}

\usepackage[pdftex=true,
        a4paper=true,bookmarks=false,pdftitle={Written with GAPDoc},
        pdfcreator={LaTeX with hyperref package / GAPDoc},
        colorlinks=true,backref=page,breaklinks=true,linkcolor=RoyalBlue,
        citecolor=RoyalGreen,filecolor=RoyalRed,
        urlcolor=RoyalRed,pagecolor=RoyalBlue]{hyperref}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\F}{\mathbb{F}}

\newcommand{\GAP}{\textsf{GAP}}

\begin{document}

\def\contentsname{Contents\logpage{[ 0, 0, 1 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Resolutions of the ground ring}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X8735FC5E7BB5CE3A}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{ResolutionAbelianGroup} \texttt{ ResolutionAbelianGroup(L,n)} {\nobreakspace} \texttt{ ResolutionAbelianGroup(G,n)} 

 Inputs a list $L:=[m_1,m_2, ..., m_d]$ of nonnegative integers, and a positive integer $n$. It returns $n$ terms of a $ZG$-resolution for the abelian group $G=Z_L[1]+Z_L[2]+···+Z_L[d]$ . 

 If $G$ is finite then the first argument can also be the abelian group $G$ itself. \\
 \index{ResolutionAlmostCrystalGroup} \texttt{ ResolutionAlmostCrystalGroup(G,n)} 

 Inputs a positive integer $n$ and an almost crystallographic pcp group $G$. It returns $n$ terms of a free $ZG$-resolution. (A group is almost crystallographic if it is nilpotent-by-finite
and has no non-trivial finite normal subgroup. Such groups can be constructed
using the ACLIB package.) \\
 \index{ResolutionAlmostCrystalQuotient} \texttt{ ResolutionAlmostCrystalQuotient(G,n,c)} {\nobreakspace} \texttt{ ResolutionAlmostCrystalQuotient(G,n,c,false)} 

 An almost crystallographic group $G$ is an extension of a finite group $P$ by a nilpotent group $T$, and has no non-trivial finite normal subgroup. We define the relative lower
central series by setting $T_1=T$ and $T_{i+1}=[T_i,G]$.

 This function inputs an almost crystallographic group $G$ together with positive integers $n$ and $c$. It returns $n$ terms of a free $ZQ$-resolution $R$ for the group $Q=G/T_c$ .

 In addition to the usual components, the resolution $R$ has the component $R.quotientHomomorphism$ which gives the quotient homomorphism $G \longrightarrow Q $.

 If a fourth optional variable is set equal to "false" then the function omits
to test whether $Q$ is finite and a "more canonical" resolution is constructed. \\
 \index{ResolutionArtinGroup} \texttt{ ResolutionArtinGroup(D,n)} 

 Inputs a Coxeter diagram $D$ and an integer $n>1$. It returns $n$ terms of a free $ZG$-resolution $R$ where $G$ is the Artin monoid associated to $D$. It is conjectured that $R$ is also a free resolution for the Artin group $G$. The conjecture is known to hold in \href{About/aboutArtinGroups.html} {certain cases}.

 $G=R.group$ is infinite and returned as a finitely presented group. The list $R.elts$ is a partial listing of the elements of $G$ which grows as $R$ is used. Initially $R.elts$ is empty and then, any time the boundary of a resolution generator is called, $R.elts$ is updated to include elements of $G$ involved in the boundary.

 The contracting homotopy on $R$ has not yet been implemented! Furthermore, the group $G$ is currently returned only as a finitely presented group (without any method
for solving the word problem). \\
 \index{ResolutionAsphericalPresentation} \texttt{ ResolutionAsphericalPresentation(F,R,n)} 

 Inputs a free group $F$, a set $R$ of words in $F$ which constitute an aspherical presentation for a group $G$, and a positive integer $n$. (Asphericity can be a difficult property to verify. The function $IsAspherical(F,R)$ could be of help.)

 The function returns n terms of a free $ZG$-resolution $R$ which has generators in dimensions {\textless} 3 only. No contracting homotopy
on $R$ will be returned. \\
 \index{ResolutionBieberbachGroup (HAPcryst)} \texttt{ ResolutionBieberbachGroup( G ) } \\
 \texttt{ ResolutionBieberbachGroup( G, v ) } 

 Inputs a Bieberbach group $G$ (represented using AffineCrystGroupOnRight as in the GAP package Cryst). It
also optionally inputs a choice of vector $v$ in the euclidean space $R^n$ on which $G$ acts freely. The function returns $n+1$ terms of the free $ZG$-resolution of $Z$ arising as the cellular chain complex of the tesselation of $R^n$ by the Dirichlet-Voronoi fundamental domain determined by $v$. 

 This is a HAPcryst function and is thus only available if HAPcryst is loaded. 

 The function requires the use of Polymake software. \\
 \index{ResolutionDirectProduct} \texttt{ ResolutionDirectProduct(R,S) } {\nobreakspace} \texttt{ ResolutionDirectProduct(R,S,"internal")} 

 Inputs a $ZG$-resolution $R$ and $ZH$-resolution $S$. It outputs a $ZD$-resolution for the direct product $D=G x H$.

 If $G$ and $H$ lie in a common group $K$, and if they commute and have trivial intersection, then an optional third
variable "internal" can be used. This will force $D$ to be the subgroup $GH$ in $K$. \\
 \index{ResolutionExtension} \texttt{ ResolutionExtension(g,R,S) } {\nobreakspace} \texttt{ ResolutionExtension(g,R, S,"TestFiniteness")} {\nobreakspace} \texttt{ ResolutionExtension(g,R,S,"NoTest",GmapE)} 

 Inputs a surjective group homomorphism $g:E \longrightarrow G$ with kernel $N$. It also inputs a $ZN$-resolution $R$ and a $ZG$-resolution $S$. It returns a $ZE$-resolution. The groups $E$ and $G$ can be infinite.

 If an optional fourth argument is set equal to "TestFiniteness" then the
groups $N$ and $G$ will be tested to see if they are finite. If they are finite then some speed
saving routines will be invoked.

 If the homomorphism $g$ is such that the GAP function $PreImagesElement(g,x)$ doesn't work, then a function $GmapE()$ should be included as a fifth input. For any $x$ in $G$ this function should return an element $GmapE(x)$ in $E$ which gets mapped onto $x$ by $g$.

 The contracting homotopy on the $ZE$-resolution has not yet been fully implemented for infinite groups! \\
 \index{ResolutionFiniteDirectProduct} \texttt{ ResolutionFiniteDirectProduct(R,S) } {\nobreakspace} \texttt{ ResolutionFiniteDirectProduct(R,S, "internal")} 

 Inputs a $ZG$-resolution $R$ and $ZH$-resolution $S$ where $G$ and $H$ are finite groups. It outputs a $ZD$-resolution for the direct product $D=G×H$.

 If $G$ and $H$ lie in a common group $K$, and if they commute and have trivial intersection, then an optional third
variable "internal" can be used. This will force $D$ to be the subgroup $GH$ in $K$. \\
 \index{ResolutionFiniteExtension} \texttt{ ResolutionFiniteExtension(gensE,gensG,R,n)} {\nobreakspace} \texttt{ ResolutionFiniteExtension(gensE,gensG,R,n,true) } {\nobreakspace} \texttt{ ResolutionFiniteExtension(gensE,gensG,R,n,false,S) } 

 Inputs: a set $gensE$ of generators for a finite group $E$; a set $gensG$ equal to the image of $gensE$ in a quotient group $G$ of $E$; a $ZG$-resolution $R$ up to dimension at least $n$; a positive integer $n$. It uses the $TwistedTensorProduct()$ construction to return $n$ terms of a $ZE$-resolution.

 The function has an optional fourth argument which, when set equal to "true",
invokes tietze reductions in the construction of a resolution for the kernel
of $E \longrightarrow G$.

 If a $ZN$-resolution $S$ is available, where $N$ is the kernel of the quotient $E \longrightarrow G$, then this can be incorporated into the computations using an optional fifth
argument. \\
 \index{ResolutionFiniteGroup} \texttt{ ResolutionFiniteGroup(gens,n)} {\nobreakspace} \texttt{ ResolutionFiniteGroup(gens,n,true)} {\nobreakspace} \texttt{ ResolutionFiniteGroup(gens,n,false,p) }

 Inputs a set $gens$ of generators for a finite group $G$ and a positive integer $n$. It outputs $n$ terms of a $ZG$-resolution.

 The function has an optional third argument which, when set equal to $true$, invokes tietze reductions in the construction of the resolution. 

 The function has an optional fourth argument which, when set equal to a prime $p$, records the fact that the resolution will only be used for mod $p$ calculations. This could speed up subsequent constructions. 

 \\
 \index{ResolutionFiniteSubgroup} \texttt{ ResolutionFiniteSubgroup(R,K)} {\nobreakspace} \texttt{ ResolutionFiniteSubgroup(R,gensG,gensK)} 

 Inputs a $ZG$-resolution for a finite group $G$ and a subgroup $K$ of index $|G:K|$. It returns a free $ZK$-resolution whose $ZK$-rank is $|G:K|$ times the $ZG$-rank in each dimension.

 Generating sets $gensG$, $gensK$ for $G$ and $K$ can also be input to the function (though the method does not depend on a
choice of generators).

 This $ZK$-resolution is not reduced. ie. it has more than one generator in dimension $0$. \\
 \index{ResolutionGraphOfGroups} \texttt{ ResolutionGraphOfGroups(D,n) } {\nobreakspace} \texttt{ ResolutionGraphOfGroups(D,n,L) } 

 Inputs a graph of groups $D$ and a positive integer $n$. It returns $n$ terms of a free $ZG$-resolution for the fundamental group $G$ of $D$.

 An optional third argument $L=[R_1 , \ldots , R_t]$ can be used to list (in any order) free resolutions for some/all of the vertex
and edge groups in $D$. If for some vertex or edge group no resolution is listed in $L$ then the function $ResolutionFiniteGroup()$ will be used to try to construct the resolution. 

 The $ZG$-resolution is usually not reduced. i.e. it has more than one generator in
dimension 0.

 The contracting homotopy on the $ZG$-resolution has not yet been implemented! Furthermore, the group $G$ is currently returned only as a finitely presented group (without any method
for solving the word problem). \\
 \index{ResolutionNilpotentGroup} \texttt{ ResolutionNilpotentGroup(G,n) } {\nobreakspace} \texttt{ ResolutionNilpotentGroup(G,n,"TestFiniteness")} 

 Inputs a nilpotent group $G$ and positive integer $n$. It returns $n$ terms of a free $ZG$-resolution. The resolution is computed using a divide-and-conquer technique
involving the lower central series.

 This function can be applied to infinite groups $G$. For finite groups the function $ResolutionNormalSeries()$ probably gives better results.

 If an optional third argument is set equal to "TestFiniteness" then the groups $N$ and $G$ will be tested to see if they are finite. If they are finite then some speed
saving routines will be invoked.

 The contracting homotopy on the $ZE$-resolution has not yet been fully implemented for infinite groups. \\
 \index{ResolutionNormalSeries} \texttt{ ResolutionNormalSeries(L,n) } {\nobreakspace} \texttt{ ResolutionNormalSeries(L,n,true)} {\nobreakspace} \texttt{ ResolutionNormalSeries(L,n,false,p)} 

 Inputs a positive integer $n$ and a list $L = [L_1 , ..., L_k]$ of normal subgroups $L_i$ of a finite group $G$ satisfying $G = L_1$ {\textgreater} $L2$ {\textgreater}$ \ldots $ {\textgreater}$ L_k$. Alternatively, $L = [gensL_1, ... gensL_k]$ can be a list of generating sets for the $L_i$ (and these particular generators will be used in the construction of
resolutions). It returns a $ZG$-resolution by repeatedly using the function $ResolutionFiniteExtension()$.

 The function has an optional third argument which, if set equal to true,
invokes tietze reductions in the construction of resolutions.

 The function has an optional fourth argument which, if set equal to p
{\textgreater} 0, produces a resolution which is only valid for mod $p$ calculations. \\
 \index{ResolutionPrimePowerGroup} \texttt{ ResolutionPrimePowerGroup(P,n) } {\nobreakspace} \texttt{ ResolutionPrimePowerGroup(G,n,p)} 

 Inputs a $p$-group $P$ and integer $n${\textgreater}$0$. It uses GAP's standard linear algebra functions over the field $F$ of p elements to construct a free $FP$-resolution for mod $p$ calculations only. The resolution is minimal - meaning that the number of
generators of $R_n$ equals the rank of $H_n(P,F)$. 

 The function can also be used to obtain a free non-minimal $FG$-resolution of a small group $G$ of non-prime-power order. In this case the prime $p$ must be entered as the third input variable. (In the non-prime-power case the
algorithm is naive and not very good.) \\
 \index{ResolutionSmallFpGroup} \texttt{ ResolutionSmallFpGroup(G,n) } {\nobreakspace} \texttt{ ResolutionSmallFpGroup(G,n,p) } 

 Inputs a small finitely presented group $G$ and an integer $n${\textgreater}$0$. It returns $n$ terms of a $ZG$-resolution which, in dimensions 1 and 2, corresponds to the given
presentation for $G$. The method returns no contracting homotopy for the resolution.

 The function has an optional fourth argument which, when set equal to a prime $p$, records the fact that the resolution will only be used for mod $p$ calculations. This could speed up subsequent constructions. 

 This function was written by Irina Kholodna. \\
 \index{ResolutionSubgroup} \texttt{ ResolutionSubgroup(R,K)} 

 Inputs a $ZG$-resolution for an (infinite) group $G$ and a subgroup $K$ of finite index $|G:K|$. It returns a free $ZK$-resolution whose $ZK$-rank is $|G:K|$ times the $ZG$-rank in each dimension.

 If $G$ is finite then the function $ResolutionFiniteSubgroup(R,G,K)$ will probably work better. In particular, resolutions from this function
probably won't work with the function $EquivariantChainMap()$. This $ZK$-resolution is not reduced. i.e. it has more than one generator in dimension
0. \\
 \index{ResolutionSubnormalSeries} \texttt{ ResolutionSubnormalSeries(L,n) } 

 Inputs a positive integer n and a list $L = [L_1 , \ldots , L_k]$ of subgroups $L_i$ of a finite group $G=L_1$ such that $L_1$ {\textgreater} $L2 \ldots $ {\textgreater} $L_k$ is a subnormal series in $G$ (meaning that each $L_{i+1}$ must be normal in $L_i$). It returns a $ZG$-resolution by repeatedly using the function $ResolutionFiniteExtension()$.

 If $L$ is a series of normal subgroups in $G$ then the function $ResolutionNormalSeries(L,n)$ will possibly work more efficiently. \\
 \index{TwistedTensorProduct} \texttt{ TwistedTensorProduct(R,S,EhomG,GmapE,NhomE,NEhomN,EltsE,Mult,InvE)} 

 Inputs a $ZG$-resolution $R$, a $ZN$-resolution $S$, and other data relating to a short exact sequence $1 \longrightarrow N \longrightarrow E \longrightarrow G \longrightarrow 1$. It uses a perturbation technique of CTC Wall to construct a $ZE$-resolution $F$. Both $G$ and $N$ could be infinite. The "length" of $F$ is equal to the minimum of the "length"s of $R$ and $S$. The resolution $R$ needs no contracting homotopy if no such homotopy is requied for $F$. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Resolutions of modules}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X841673BA782D0D1D}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{ResolutionFpGModule} \texttt{ ResolutionFpGModule(M,n)} 

 Inputs an $FpG$-module $M$ and a positive integer $n$. It returns $n$ terms of a minimal free $FG$-resolution of the module $M$ (where $G$ is a finite group and $F$ the field of $p$ elements). \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Induced equivariant chain maps}}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7E91068780486C3A}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{EquivariantChainMap} \texttt{ EquivariantChainMap(R,S,f)} 

 Inputs a $ZG$-resolution $R$, a $ZG'$-resolution $S$, and a group homomorphism $f : G \longrightarrow G'$. It outputs a component object $M$ with the following components. 

 
\begin{itemize}
\item  $M!.source$ is the resolution $R$.
\item  $M!.target$ is the resolution $S$.
\item $M!.mapping(w,n)$ is a function which gives the image in $S_n$, under a chain map induced by $f$, of a word $w$ in $R_n$. (Here $R_n$ and $S_n$ are the $n$-th modules in the resolutions $R$ and $S$.)
\item  $F!.properties$ is a list of pairs such as ["type", "equivariantChainMap"].
\end{itemize}
 

 The resolution $S$ must have a contracting homotopy. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Functors}}\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X78D1062D78BE08C1}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{HomToIntegers} \texttt{ HomToIntegers(X) } 

 Inputs either a $ZG$-resolution $X=R$, or an equivariant chain map $X = (F:R \longrightarrow S)$. It returns the cochain complex or cochain map obtained by applying $HomZG( _ , Z)$ where $Z$ is the trivial module of integers (characteristic 0). \\
 \index{HomToIntegersModP} \texttt{ HomToIntegersModP(R) } 

 Inputs a $ZG$-resolution $R$ and returns the cochain complex obtained by applying $HomZG( _ , Z_p)$ where $Z_p$ is the trivial module of integers mod $p$. (At present this functor does not handle equivariant chain maps.) \\
 \index{HomToIntegralModule} \texttt{ HomToIntegralModule(R,f) } 

 Inputs a $ZG$-resolution $R$ and a group homomorphism $f:G \longrightarrow GL_n(Z)$ to the group of $n×n$ invertible integer matrices. Here $Z$ must have characteristic 0. It returns the cochain complex obtained by
applying $HomZG( _ , A)$ where $A$ is the $ZG$-module $Z_n$ with $G$ action via $f$. (At present this function does not handle equivariant chain maps.) \\
 \index{HomToGModule} \texttt{ HomToGModule(R,A) } 

 Inputs a $ZG$-resolution $R$ and an abelian G-outer group A. It returns the G-cocomplex obtained by
applying $HomZG( _ , A)$. (At present this function does not handle equivariant chain maps.) \\
 \index{LowerCentralSeriesLieAlgebra} \texttt{ LowerCentralSeriesLieAlgebra(G) } {\nobreakspace} \texttt{ LowerCentralSeriesLieAlgebra(f) } 

 Inputs a pcp group $G$. If each quotient $G_c/G_{c+1}$ of the lower central series is free abelian or p-elementary abelian (for fixed
prime p) then a Lie algebra $L(G)$ is returned. The abelian group underlying $L(G)$ is the direct sum of the quotients $G_c/G_{c+1}$ . The Lie bracket on $L(G)$ is induced by the commutator in $G$. (Here $G_1=G$, $G_{c+1}=[G_c,G]$ .) 

 The function can also be applied to a group homomorphism $f: G \longrightarrow G'$ . In this case the induced homomorphism of Lie algebras $L(f):L(G) \longrightarrow L(G')$ is returned.

 If the quotients of the lower central series are not all free or p-elementary
abelian then the function returns fail.

 This function was written by Pablo Fernandez Ascariz \\
 \index{TensorWithIntegers} \texttt{ TensorWithIntegers(X) } 

 Inputs either a $ZG$-resolution $X=R$, or an equivariant chain map $X = (F:R \longrightarrow S)$. It returns the chain complex or chain map obtained by tensoring with the
trivial module of integers (characteristic 0). \\
 \index{TensorWithIntegersModP} \texttt{ TensorWithIntegersModP(X,p) } 

 Inputs either a $ZG$-resolution $X=R$, or an equivariant chain map $X = (F:R \longrightarrow S)$, and a prime $p$. It returns the chain complex or chain map obtained by tensoring with the
trivial module of integers modulo $p$. \\
 \index{TensorWithRationals} \texttt{ TensorWithRationals(R) } 

 Inputs a $ZG$-resolution $R$ and returns the chain complex obtained by tensoring with the trivial module of
rational numbers. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Chain complexes}}\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X7A06103979B92808}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{ChevalleyEilenbergComplex} \texttt{ ChevalleyEilenbergComplex(X,n) } 

 Inputs either a Lie algebra $X=A$ (over the ring of integers $Z$ or over a field $K$) or a homomorphism of Lie algebras $X=(f:A \longrightarrow B)$, together with a positive integer $n$. It returns either the first $n$ terms of the Chevalley-Eilenberg chain complex $C(A)$, or the induced map of Chevalley-Eilenberg complexes $C(f):C(A) \longrightarrow C(B)$. 

 (The homology of the Chevalley-Eilenberg complex $C(A)$ is by definition the homology of the Lie algebra $A$ with trivial coefficients in $Z$ or $K$). 

 This function was written by Pablo Fernandez Ascariz \\
 \index{LeibnizComplex} \texttt{ LeibnizComplex(X,n) } 

 Inputs either a Lie or Leibniz algebra $X=A$ (over the ring of integers $Z$ or over a field $K$) or a homomorphism of Lie or Leibniz algebras $X=(f:A \longrightarrow B)$, together with a positive integer $n$. It returns either the first $n$ terms of the Leibniz chain complex $C(A)$, or the induced map of Leibniz complexes $C(f):C(A) \longrightarrow C(B)$. 

 (The Leibniz complex $C(A)$ was defined by J.-L.Loday. Its homology is by definition the Leibniz homology
of the algebra $A$). 

 This function was written by Pablo Fernandez Ascariz \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Homology and cohomology groups}}\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X782177107A5D6D19}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{Cohomology} \texttt{Cohomology(X,n) } 

 Inputs either a cochain complex $X=C$ (or G-cocomplex C) or a cochain map $X=(C \longrightarrow D)$ over the integers $Z$ together with a non-negative intereg $n$. 
\begin{itemize}
\item If $X=C$ then the torsion coefficients of $H^n(C)$ are retuned.
\item If $X=(C \longrightarrow D)$ then the induced homomorphism $H^n(C)\longrightarrow H^n(D)$ is returned as a homomorphism of finitely presented groups. 
\end{itemize}
 \\
 \index{CohomologyModule} \texttt{CohomologyModule(C,n) } 

 Inputs a $G$-cocomplex $C$ together with a non-negative integer $n$. It returns the cohomology $H^n(C)$ as a $G$-outer group. If $C$ was constructed from a resolution $R$ by homing to an abelian $G$-outer group $A$ then, for each x in H:=CohomologyModule(C,n), there is a function
f:=H!.representativeCocycle(x) which is a standard n-cocycle corresponding to
the cohomology class x. (At present this works only for n=1,2,3.) \\
 \index{CohomologyPrimePart} \texttt{CohomologyPrimePart(C,n,p)} 

 Inputs a cochain complex $C$ in characteristic 0, a positive integer $n$, and a prime $p$. It returns a list of those torsion coefficients of $H^n(C)$ that are positive powers of $p$. The function uses the EDIM package by Frank Luebeck. \\
 \index{GroupCohomology} \texttt{GroupCohomology(X,n) } {\nobreakspace} \texttt{GroupCohomology(X,n,p)} 

 Inputs a positive integer $n$ and either a finite group $X=G$ or a Coxeter diagram $X=D$ representing an infinite Artin group $G$. It returns the torsion coefficients of the integral cohomology $H^n(G,Z)$. 

 There is an optional third argument which, when set equal to a prime $p$, causes the function to return the the mod $p$ cohomology $H^n(G,Z_p)$ as a list of length equal to its rank. 

 This function is a composite of more basic functions, and makes choices for a
number of parameters. For a particular group you would almost certainly be
better using the more basic functions and making the choices yourself! \\
 \index{GroupHomology} \texttt{GroupHomology(X,n)} \\
 \texttt{GroupHomology(X,n,p)} 

 Inputs a positive integer $n$ and either a finite group $X=G$ or a Coxeter diagram $X=D$ representing an infinite Artin group $G$. It returns the torsion coefficients of the integral homology $H_n(G,Z)$. 

 There is an optional third argument which, when set equal to a prime $p$, causes the function to return the mod $p$ homology $H_n(G,Z_p)$ as a list of lenth equal to its rank. 

 This function is a composite of more basic functions, and makes choices for a
number of parameters. For a particular group you would almost certainly be
better using the more basic functions and making the choices yourself! \\
 \index{Homology} \texttt{Homology(X,n)} 

 Inputs either a chain complex $X=C$ or a chain map $X=(C \longrightarrow D)$. 
\begin{itemize}
\item If $X=C$ then the torsion coefficients of $H_n(C)$ are retuned.
\item  If $X=(C \longrightarrow D)$ then the induced homomorphism $H_n(C) \longrightarrow H_n(D)$ is returned as a homomorphism of finitely presented groups. 
\end{itemize}
 \\
 \index{HomologyPb} \texttt{HomologyPb(C,n)} 

 This is a back-up function which might work in some instances where $Homology(C,n)$ fails. It is most useful for chain complexes whose boundary homomorphisms are
sparse. 

 It inputs a chain complex $C$ in characteristic $0$ and returns the torsion coefficients of $H_n(C)$ . There is a small probability that an incorrect answer could be returned. The
computation relies on probabilistic Smith Normal Form algorithms implemented
in the Simplicial Homology GAP package. This package therefore needs to be
loaded. The computation is stored as a component of $C$ so, when called a second time for a given $C$ and $n$, the calculation is recalled without rerunning the algorithm. 

 The choice of probabalistic algorithm can be changed using the command 

 SetHomologyAlgorithm(HomologyAlgorithm[i]);

 where i = 1,2,3 or 4. The upper limit for the probability of an incorrect
answer can be set to any rational number $0${\textless}$e${\textless}= $1$ using the following command. 

SetUncertaintyTolerence(e);

 See the Simplicial Homology package manual for further details. \\
 \index{HomologyPrimePart} \texttt{HomologyPrimePart(C,n,p)} 

 Inputs a chain complex $C$ in characteristic 0, a positive integer $n$, and a prime $p$. It returns a list of those torsion coefficients of $H_n(C)$ that are positive powers of $p$. The function uses the EDIM GAP package by Frank Luebeck. \\
 \index{LeibnizAlgebraHomology} \texttt{LeibnizAlgebraHomology(A,n)} 

 Inputs a Lie or Leibniz algebra $X=A$ (over the ring of integers $Z$ or over a field $K$), together with a positive integer $n$. It returns the $n$-dimensional Leibniz homology of $A$. \\
 \index{LieAlgebraHomology} \texttt{LieAlgebraHomology(A,n)} 

 Inputs a Lie algebra $A$ (over the integers or a field) and a positive integer $n$. It returns the homology $H_n(A,k)$ where $k$ denotes the ground ring. \\
 \index{PrimePartDerivedFunctor} \texttt{PrimePartDerivedFunctor(G,R,F,n)} 

 Inputs a finite group $G$, a positive integer $n$, at least $n+1$ terms of a $ZP$-resolution for a Sylow subgroup $P${\textless}$G$ and a "mathematically suitable" covariant additive functor $F$ such as TensorWithIntegers . It returns the abelian invariants of the $p$-component of the homology $H_n(F(R))$ . 

 Warning: All calculations are assumed to be in characteristic 0. The function
should not be used if the coefficient module is over the field of $p$ elements. 

 "Mathematically suitable" means that the Cartan-Eilenberg double coset formula
must hold. \\
 \index{RankHomologyPGroup} \texttt{RankHomologyPGroup(G,n)} {\nobreakspace} \texttt{RankHomologyPGroup(R,n)} {\nobreakspace} \texttt{RankHomologyPGroup(G,n,"empirical")} 

 Inputs a (smallish) $p$-group $G$, or $n$ terms of a minimal $Z_pG$-resolution $R$ of $Z_p$ , together with a positive integer $n$. It returns the minimal number of generators of the integral homology group $H_n(G,Z)$. 

 If an option third string argument "empirical" is included then an empirical
algorithm will be used. This is one which always seems to yield the right
answer but which we can't prove yields the correct answer. \\
 \index{RankPrimeHomology} \texttt{RankPrimeHomology(G,n)} 

 Inputs a (smallish) $p$-group $G$ together with a positive integer $n$. It returns a function $dim(k)$ which gives the rank of the vector space $H_k(G,Z_p)$ for all $0$ {\textless}= $k$ {\textless}= $n$. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Poincare series}}\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X850CDAFE801E2B2A}{}
{
 \begin{center}
\begin{tabular}{|l|} \texttt{EfficientNormalSubgroups(G)} \\
 \texttt{EfficientNormalSubgroups(G,k)} 

 Inputs a prime-power group $G$ and, optionally, a positive integer $k$. The default is $k=4$. The function returns a list of normal subgroups $N$ in $G$ such that the Poincare series for $G$ equals the Poincare series for the direct product $(N \times (G/N))$ up to degree $k$. \\
 \index{ExpansionOfRationalFunction} \texttt{ExpansionOfRationalFunction(f,n)} 

 Inputs a positive integer $n$ and a rational function $f(x)=p(x)/q(x)$ where the degree of the polynomial $p(x)$ is less than that of $q(x)$. It returns a list $[a_0 , a_1 , a_2 , a_3 , \ldots ,a_n]$ of the first $n+1$ coefficients of the infinite expansion 

 $f(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + \ldots $ . \\
 \index{PoincareSeries} \texttt{ PoincareSeries(G,n) } {\nobreakspace} \texttt{ PoincareSeries(R,n) } \\
 \texttt{ PoincareSeries(L,n) } \\
 \texttt{ PoincareSeries(G) } 

 Inputs a finite $p$-group $G$ and a positive integer $n$. It returns a quotient of polynomials $f(x)=P(x)/Q(x)$ whose coefficient of $x^k$ equals the rank of the vector space $H_k(G,Z_p)$ for all $k$ in the range $k=1$ to $k=n$. (The second input variable can be omitted, in which case the function tries
to choose a "reasonable" value for $n$.) 

 In place of the group $G$ the function can also input (at least $n$ terms of) a minimal mod $p$ resolution $R$ for $G$. 

 Alternatively, the first input variable can be a list $L$ of integers. In this case the coefficient of $x^k$ in $f(x)$ is equal to the $(k+1)$st term in the list. \\
 \index{PoincareSeriesPrimePart} \texttt{PoincareSeriesPrimePart(G,p,n) } 

 Inputs a finite group $G$, a prime $p$, and a positive integer $n$. It returns a quotient of polynomials $f(x)=P(x)/Q(x)$ whose coefficient of $x^k$ equals the rank of the vector space $H_k(G,Z_p)$ for all $k$ in the range $k=1$ to $k=n$. 

 The efficiency of this function needs to be improved. \\
 \index{Prank} \texttt{ Prank(G) } 

 Inputs a $p$-group $G$ and returns the rank of the largest elementary abelian subgroup. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Cohomology ring structure}}\logpage{[ 8, 0, 0 ]}
\hyperdef{L}{X7A9561E47A4994F5}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{IntegralCupProduct} \texttt{IntegralCupProduct(R,u,v,p,q) } \\
 \texttt{ IntegralCupProduct(R,u,v,p,q,P,Q,N) } 

 (Various functions used to construct the cup product are also \href{ CR_functions.html} {available}.) 

 Inputs a $ZG$-resolution $R$, a vector $u$ representing an element in $H^p(G,Z)$, a vector $v$ representing an element in $H^q(G,Z)$ and the two integers $p,q$ {\textgreater}$ 0$. It returns a vector $w$ representing the cup product $u\cdot v$ in $H^{p+q}(G,Z)$. This product is associative and $u\cdot v = (-1)pqv\cdot u$ . It provides $H^\ast(G,Z)$ with the structure of an anti-commutative graded ring. This function
implements the cup product for characteristic 0 only. 

 The resolution $R$ needs a contracting homotopy. 

 To save the function from having to calculate the abelian groups $H^n(G,Z)$ additional input variables can be used in the form $IntegralCupProduct(R,u,v,p,q,P,Q,N)$ , where 
\begin{itemize}
\item  $P$ is the output of the command $CR_CocyclesAndCoboundaries(R,p,true)$ 
\item  $Q$ is the output of the command $CR_CocyclesAndCoboundaries(R,q,true)$
\item $N$ is the output of the command $CR_CocyclesAndCoboundaries(R,p+q,true)$ . 
\end{itemize}
 \\
 \index{IntegralRingGenerators} \texttt{ IntegralRingGenerators(R,n) } 

 Inputs at least $n+1$ terms of a $ZG$-resolution and integer $n${\textgreater} $0$. It returns a minimal list of cohomology classes in $H^n(G,Z)$ which, together with all cup products of lower degree classes, generate the
group $H^n(G,Z)$ . 

 (Let $a_i$ be the $i$-th canonical generator of the $d$-generator abelian group $H^n(G,Z)$. The cohomology class $n_1a_1 + ... +n_da_d$ is represented by the integer vector $u=(n_1, ..., n_d)$. ) \\
 \index{ModPCohomologyGenerators} \texttt{ ModPCohomologyGenerators(G,n) } \\
 \texttt{ ModPCohomologyGenerators(R) } 

 Inputs either a $p$-group $G$ and positive integer $n$, or else $n$ terms of a minimal $Z_pG$-resolution $R$ of $Z_p$. It returns a pair whose first entry is a minimal set of homogeneous
generators for the cohomology ring $A=H^*(G,Z_p)$ modulo all elements in degree greater than $n$. The second entry of the pair is a function $deg$ which, when applied to a minimal generator, yields its degree. 

 WARNING: the following rule must be applied when multiplying generators $x_i$ together. Only products of the form $x_1*(x_2*(x_3*(x_4*...)))$ with $deg(x_i) \le deg(x_{i+1})$ should be computed (since the $x_i$ belong to a structure constant algebra with only a partially defined structure
constants table). \\
 \index{ModPCohomologyRing} \texttt{ ModPCohomologyRing(G,n) } \\
 \texttt{ ModPCohomologyRing(G,n,level) } \\
 \texttt{ ModPCohomologyRing(R) } \\
 \texttt{ ModPCohomologyRing(R,level) } 

 Inputs either a $p$-group $G$ and positive integer $n$, or else $n$ terms of a minimal $Z_pG$-resolution $R$ of $Z_p$. It returns the cohomology ring $A=H^*(G,Z_p)$ modulo all elements in degree greater than $n$. 

 The ring is returned as a structure constant algebra $A$. 

 The ring $A$ is graded. It has a component $A!.degree(x)$ which is a function returning the degree of each (homogeneous) element $x$ in $GeneratorsOfAlgebra(A)$. 

 An optional input variable "level" can be set to one of the strings "medium"
or "high". These settings determine parameters in the algorithm. The default
setting is "medium". 

 When "level" is set to "high" the ring $A$ is returned with a component $A!.niceBasis$. This component is a pair $[Coeff,Bas]$. Here $Bas$ is a list of integer lists; a "nice" basis for the vector space $A$ can be constructed using the command $List(Bas,x->Product(List(x,i->Basis(A)[i]))$. The coefficients of the canonical basis element $Basis(A)[i]$ are stored as $Coeff[i]$. 

 If the ring $A$ is computed using the setting "level"="medium" then the component $A!.niceBasis$ can be added to $A$ using the command $ A:=ModPCohomologyRing_part_2(A) $. \\
 \index{ModPRingGenerators} \texttt{ ModPRingGenerators(A) } 

 Inputs a mod $p$ cohomology ring $A$ (created using the preceeding function). It returns a minimal generating set
for the ring $A$. Each generator is homogeneous. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Commutator and nonabelian tensor computations}}\logpage{[ 9, 0, 0 ]}
\hyperdef{L}{X86DE968B7B20BD48}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{BaerInvariant} \texttt{ BaerInvariant(G,c) } 

 Inputs a nilpotent group $G$ and integer $c${\textgreater}$0$. It returns the Baer invariant $M^(c)(G)$ defined as follows. For an arbitrary group $G$ let $L^*_{c+1}(G)$ be the $(c+1)$-st term of the upper central series of the group $U=F/[[[R,F],F]...]$ (with $c$ copies of $F$ in the denominator) where $F/R$ is any free presentation of $G$. This is an invariant of $G$ and we define $M^{(c)}(G)$ to be the kernel of the canonical homomorphism $M^{(c)}(G) \longrightarrow G$. For $c=1$ the Baer invariant $M^(1)(G)$ is isomorphic to the second integral homology $H_2(G,Z)$. 

 This function requires the NQ package. \\
 \index{Coclass} \texttt{ Coclass(G) } 

 Inputs a group $G$ of prime-power order $p^n$ and nilpotency class $c$ say. It returns the integer $r=n-c$ . \\
 \index{EpiCentre} \texttt{ EpiCentre(G,N) } \\
 \texttt{ EpiCentre(G)} 

 Inputs a finite group $G$ and normal subgroup $N$ and returns a subgroup $Z^\ast(G,N)$ of the centre of $N$. The group $Z^\ast(G,N)$ is trivial if and only if there is a crossed module $d:E \longrightarrow G$ with $N=Image(d)$ and with $Ker(d)$ equal to the subgroup of $E$ consisting of those elements on which $G$ acts trivially. 

 If no value for $N$ is entered then it is assumed that $N=G$. In this case the group $Z^\ast(G,G)$ is trivial if and only if $G$ is isomorphic to a quotient $G=E/Z(E)$ of some group $E$ by the centre of $E$. (See also the command $UpperEpicentralSeries(G,c)$. ) \\
 \index{NonabelianExteriorProduct} \texttt{ NonabelianExteriorProduct(G,N) } 

 Inputs a finite group $G$ and normal subgroup $N$. It returns a record $E$ with the following components. 
\begin{itemize}
\item  $E.homomorphism$ is a group homomorphism $µ : (G \wedge N) \longrightarrow G$ from the nonabelian exterior product $(G \wedge N)$ to $G$. The kernel of $µ$ is the relative Schur multiplier. 
\item  $E.pairing(x,y)$ is a function which inputs an element $x$ in $G$ and an element $y$ in $N$ and returns $(x \wedge y)$ in the exterior product $(G \wedge N)$ . 
\end{itemize}
 This function should work for reasonably small nilpotent groups or extremely
small non-nilpotent groups. \\
 \index{NonabelianSymmetricKernel} \texttt{ NonabelianSymmetricKernel(G) } \\
 \texttt{ NonabelianSymmetricKernel(G,m) } 

 Inputs a finite or nilpotent infinite group $G$ and returns the abelian invariants of the Fourth homotopy group $SG$ of the double suspension $SSK(G,1)$ of the Eilenberg-Mac Lane space $K(G,1)$. 

 For non-nilpotent groups the implementation of the function $NonabelianSymmetricKernel(G)$ is far from optimal and will soon be improved. As a temporary solution to this
problem, an optional second variable $m$ can be set equal to $0$, and then the function efficiently returns the abelian invariants of groups $A$ and $B$ such that there is an exact sequence $0 \longrightarrow B \longrightarrow SG \longrightarrow A \longrightarrow 0$. 

 Alternatively, the optional second varible $m$ can be set equal to a positive multiple of the order of the symmetric square $(G \tilde\otimes G)$. In this case the function returns the abelian invariants of $SG$. This might help when $G$ is solvable but not nilpotent (especially if the estimated upper bound $m$ is reasonable accurate). \\
 \index{NonabelianSymmetricSquare} \texttt{ NonabelianSymmetricSquare(G) } \\
 \texttt{ NonabelianSymmetricSquare(G,m) } 

 Inputs a finite or nilpotent infinite group $G$ and returns a record $T$ with the following components. 
\begin{itemize}
\item  $T.homomorphism$ is a group homomorphism $µ : (G \tilde\otimes G) \longrightarrow G$ from the nonabelian symmetric square of $G$ to $G$. The kernel of $µ$ is isomorphic to the fourth homotopy group of the double suspension $SSK(G,1)$ of an Eilenberg-Mac Lane space. 
\item  $T.pairing(x,y)$ is a function which inputs two elements $x, y$ in $G$ and returns the tensor $(x \otimes y)$ in the symmetric square $(G \otimes G)$ . 
\end{itemize}
 An optional second varible $m$ can be set equal to a multiple of the order of the symmetric square $(G \tilde\otimes G)$. This might help when $G$ is solvable but not nilpotent (especially if the estimated upper bound $m$ is reasonable accurate) as the bound is used in the solvable quotient
algorithm. 

 The optional second variable $m$ can also be set equal to $0$. In this case the Todd-Coxeter procedure will be used to enumerate the
symmetric square even when $G$ is solvable. 

 This function should work for reasonably small solvable groups or extremely
small non-solvable groups. \\
 \index{NonabelianTensorProduct} \texttt{ NonabelianTensorProduct(G,N) } 

 Inputs a finite group $G$ and normal subgroup $N$. It returns a record $E$ with the following components. 
\begin{itemize}
\item  $E.homomorphism$ is a group homomorphism $µ : (G \otimes N ) \longrightarrow G$ from the nonabelian exterior product $(G \otimes N)$ to $G$. 
\item  $E.pairing(x,y)$ is a function which inputs an element $x$ in $G$ and an element $y$ in $N$ and returns $(x \otimes y)$ in the tensor product $(G \otimes N)$ . 
\end{itemize}
 This function should work for reasonably small nilpotent groups or extremely
small non-nilpotent groups. \\
 \index{NonabelianTensorSquare} \texttt{ NonabelianTensorSquare(G) } \\
 \texttt{ NonabelianTensorSquare(G,m) } 

 Inputs a finite or nilpotent infinite group $G$ and returns a record $T$ with the following components. 
\begin{itemize}
\item  $T.homomorphism$ is a group homomorphism $µ : (G \otimes G) \longrightarrow G$ from the nonabelian tensor square of $G$ to $G$. The kernel of $µ$ is isomorphic to the third homotopy group of the suspension $SK(G,1)$ of an Eilenberg-Mac Lane space. 
\item  $T.pairing(x,y)$ is a function which inputs two elements $x, y$ in $G$ and returns the tensor $(x \otimes y)$ in the tensor square $(G \otimes G)$ . 
\end{itemize}
 An optional second varible $m$ can be set equal to a multiple of the order of the tensor square $(G \otimes G)$. This might help when $G$ is solvable but not nilpotent (especially if the estimated upper bound $m$ is reasonable accurate) as the bound is used in the solvable quotient
algorithm. 

 The optional second variable $m$ can also be set equal to $0$. In this case the Todd-Coxeter procedure will be used to enumerate the tensor
square even when $G$ is solvable. 

 This function should work for reasonably small solvable groups or extremely
small non-solvable groups. \\
 \index{RelativeSchurMultiplier} \texttt{ RelativeSchurMultiplier(G,N) } 

 Inputs a finite group $G$ and normal subgroup $N$. It returns the homology group $H_2(G,N,Z)$ that fits into the exact sequence 

 $\ldots\longrightarrow H_3(G,Z) \longrightarrow H_3(G/N,Z) \longrightarrow
H_2(G,N,Z) \longrightarrow H_3(G,Z) \longrightarrow H_3(G/N,Z) \longrightarrow
\ldots. $ 

 This function should work for reasonably small nilpotent groups $G$ or extremely small non-nilpotent groups. \\
 \index{TensorCentre} \texttt{ TensorCentre(G) } 

 Inputs a group $G$ and returns the largest central subgroup $N$ such that the induced homomorphism of nonabelian tensor squares $(G \otimes G) \longrightarrow (G/N \otimes G/N)$ is an isomorphism. Equivalently, $N$ is the largest central subgroup such that $\pi_3(SK(G,1)) \longrightarrow \pi_3(SK(G/N,1))$ is injective. \\
 \index{ThirdHomotopyGroupOfSuspensionB} \texttt{ ThirdHomotopyGroupOfSuspensionB(G) } \\
 \texttt{ ThirdHomotopyGroupOfSuspensionB(G,m) } 

 Inputs a finite or nilpotent infinite group $G$ and returns the abelian invariants of the third homotopy group $JG$ of the suspension $SK(G,1)$ of the Eilenberg-Mac Lane space $K(G,1)$. 

 For non-nilpotent groups the implementation of the function $ThirdHomotopyGroupOfSuspensionB(G)$ is far from optimal and will soon be improved. As a temporary solution to this
problem, an optional second variable $m$ can be set equal to $0$, and then the function efficiently returns the abelian invariants of groups $A$ and $B$ such that there is an exact sequence $0 \longrightarrow B \longrightarrow JG \longrightarrow A \longrightarrow 0$. 

 Alternatively, the optional second varible $m$ can be set equal to a positive multiple of the order of the tensor square $(G \otimes G)$. In this case the function returns the abelian invariants of $JG$. This might help when $G$ is solvable but not nilpotent (especially if the estimated upper bound $m$ is reasonable accurate). \\
 \index{UpperEpicentralSeries} \texttt{ UpperEpicentralSeries(G,c) } 

 Inputs a nilpotent group $G$ and an integer $c$. It returns the $c$-th term of the upper epicentral series $1$ {\textless} $ Z_1^\ast(G)$ {\textless} $Z_2^\ast(G)$ {\textless} $ \ldots $. 

 The upper epicentral series is defined for an arbitrary group $G$. The group $Z_c^\ast (G)$ is the image in $G$ of the $c$-th term $Z_c(U)$ of the upper central series of the group $U=F/[[[R,F],F] \ldots ]$ (with $c$ copies of $F$ in the denominator) where $F/R$ is any free presentation of $G$. 

 This functions requires the NQ package. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Lie commutators and nonabelian Lie tensors}}\logpage{[ 10, 0, 0 ]}
\hyperdef{L}{X7A3DC9327EE1BE6C}{}
{
 \begin{center}
\begin{tabular}{|l|} Functions on this page are joint work with Hamid Mohammadzadeh, and
implemented by him. \\
 \index{LieCoveringHomomorphism} \texttt{ LieCoveringHomomorphism(L)} 

 Inputs a finite dimensional Lie algebra $L$ over a field, and returns a surjective Lie homomorphism $phi : C\rightarrow L$ where: 
\begin{itemize}
\item the kernel of $phi$ lies in both the centre of $C$ and the derived subalgebra of $C$, 
\item  the kernel of $phi$ is a vector space of rank equal to the rank of the second Chevalley-Eilenberg
homology of $L$. 
\end{itemize}
 \\
 \index{LeibnizQuasiCoveringHomomorphism} \texttt{ LeibnizQuasiCoveringHomomorphism(L)} 

 Inputs a finite dimensional Lie algebra $L$ over a field, and returns a surjective homomorphism $phi : C\rightarrow L$ of Leibniz algebras where: 
\begin{itemize}
\item the kernel of $phi$ lies in both the centre of $C$ and the derived subalgebra of $C$, 
\item  the kernel of $phi$ is a vector space of rank equal to the rank of the kernel $J$ of the homomorphism $L \otimes L \rightarrow L$ from the tensor square to $L$. (We note that, in general, $J$ is NOT equal to the second Leibniz homology of $L$.) 
\end{itemize}
 \\
 \index{LieEpiCentre} \texttt{ LieEpiCentre(L)} 

 Inputs a finite dimensional Lie algebra $L$ over a field, and returns an ideal $Z^\ast(L)$ of the centre of $L$. The ideal $Z^\ast(L)$ is trivial if and only if $L$ is isomorphic to a quotient $L=E/Z(E)$ of some Lie algebra $E$ by the centre of $E$. \\
 \index{LieExteriorSquare} \texttt{ LieExteriorSquare(L) } 

 Inputs a finite dimensional Lie algebra $L$ over a field. It returns a record $E$ with the following components. 
\begin{itemize}
\item  $E.homomorphism$ is a Lie homomorphism $µ : (L \wedge L) \longrightarrow L$ from the nonabelian exterior square $(L \wedge L)$ to $L$. The kernel of $µ$ is the Lie multiplier. 
\item  $E.pairing(x,y)$ is a function which inputs elements $x, y$ in $L$ and returns $(x \wedge y)$ in the exterior square $(L \wedge L)$ . 
\end{itemize}
 \\
 \index{LieTensorSquare} \texttt{ LieTensorSquare(L) } 

 Inputs a finite dimensional Lie algebra $L$ over a field and returns a record $T$ with the following components. 
\begin{itemize}
\item  $T.homomorphism$ is a Lie homomorphism $µ : (L \otimes L) \longrightarrow L$ from the nonabelian tensor square of $L$ to $L$. 
\item  $T.pairing(x,y)$ is a function which inputs two elements $x, y$ in $L$ and returns the tensor $(x \otimes y)$ in the tensor square $(L \otimes L)$ . 
\end{itemize}
 \\
 \index{LieTensorCentre} \texttt{ LieTensorCentre(L) } 

 Inputs a finite dimensional Lie algebra $L$ over a field and returns the largest ideal $N$ such that the induced homomorphism of nonabelian tensor squares $(L \otimes L) \longrightarrow (L/N \otimes L/N)$ is an isomorphism. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Generators and relators of groups}}\logpage{[ 11, 0, 0 ]}
\hyperdef{L}{X7A2144518112F830}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{CayleyGraphDisplay} \texttt{ CayleyGraphDisplay(G,X) } \\
 \texttt{ CayleyGraphDisplay(G,X,"mozilla") } 

 Inputs a finite group $G$ together with a subset $X$ of $G$. It displays the corresponding Cayley graph as a .gif file. It uses the
Mozilla web browser as a default to view the diagram. An alternative browser
can be set using a second argument. 

 The argument $G$ can also be a finite set of elements in a (possibly infinite) group containing $X$. The edges of the graph are coloured according to which element of $X$ they are labelled by. The list $X$ corresponds to the list of colours [blue, red, green, yellow, brown, black] in
that order. 

 This function requires Graphviz software. \\
 \index{IdentityAmongRelatorsDisplay} \texttt{ IdentityAmongRelatorsDisplay(R,n) } \texttt{ IdentityAmongRelatorsDisplay(R,n,"mozilla") } 

 Inputs a free $ZG$-resolution $R$ and an integer $n$. It displays the boundary R!.boundary(3,n) as a tessellation of a sphere. It
displays the tessellation as a .gif file and uses the Mozilla web browser as a
default display mechanism. An alternative browser can be set using a second
argument. (The resolution $R$ should be reduced and, preferably, in dimension 1 it should correspond to a
Cayley graph for $G$. ) 

This function uses GraphViz software. \\
 \index{IsAspherical} \texttt{ IsAspherical(F,R) } 

 Inputs a free group $F$ and a set $R$ of words in $F$. It performs a test on the 2-dimensional CW-space $K$ associated to this presentation for the group $G=F/${\textless}$R${\textgreater}$^F$. 

 The function returns "true" if $K$ has trivial second homotopy group. In this case it prints: Presentation is
aspherical. 

 Otherwise it returns "fail" and prints: Presentation is NOT piece-wise
Euclidean non-positively curved. (In this case $K$ may or may not have trivial second homotopy group. But it is NOT possible to
impose a metric on K which restricts to a Euclidean metric on each 2-cell.) 

 The function uses Polymake software. \\
 \index{PresentationOfResolution} \texttt{ PresentationOfResolution(R) } 

 Inputs at least two terms of a reduced $ZG$-resolution $R$ and returns a record $P$ with components 
\begin{itemize}
\item  $P.freeGroup$ is a free group $F$, 
\item  $P.relators$ is a list $S$ of words in $F$, 
\end{itemize}
 where $G$ is isomorphic to $F$ modulo the normal closure of $S$. This presentation for $G$ corresponds to the 2-skeleton of the classifying CW-space from which $R$ was constructed. The resolution $R$ requires no contracting homotopy. \\
 \index{TorsionGeneratorsAbelianGroup} \texttt{ TorsionGeneratorsAbelianGroup(G) } 

 Inputs an abelian group $G$ and returns a generating set $[x_1, \ldots ,x_n]$ where no pair of generators have coprime orders. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Orbit polytopes and fundamental domains}}\logpage{[ 12, 0, 0 ]}
\hyperdef{L}{X7CD67FEA7A1B6345}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{Fundamental domains (HAPcryst)} \texttt{ FundamentalDomainAffineCrystGroupOnRight(v,G)} 

 Inputs a crystallographic group G (represented using AffineCrystGroupOnRight
as in the GAP package Cryst). It also inputs a choice of vector v in the
euclidean space $R^n$ on which $G$ acts. It returns the Dirichlet-Voronoi fundamental cell for the action of $G$ on euclidean space corresponding to the vector $v$. The fundamental cell is a fundamental domain if $G$ is Bieberbach. The fundamental cell/domain is returned as a ``Polymake object''. Currently the function only applies to certain crystallographic groups. See
the manuals to HAPcryst and HAPpolymake for full details. 

 This is a HAPcryst function and is thus only available if HAPcryst is loaded. 

 The function requires the use of Polymake software. \\
 \index{OrbitPolytope} \texttt{ OrbitPolytope(G,v,L) } 

 Inputs a permutation group or matrix group $G$ of degree $n$ and a rational vector $v$ of length $n$. In both cases there is a natural action of $G$ on $v$. Let $P(G,v)$ be the convex polytope arising as the convex hull of the Euclidean points in
the orbit of $v$ under the action of $G$. The function also inputs a sublist $L$ of the following list of strings: 

 ["dimension","vertex{\textunderscore}degree", "visual{\textunderscore}graph",
"schlegel","visual"] 

 Depending on the sublist, the function: 
\begin{itemize}
\item  prints the dimension of the orbit polytope $P(G,v)$;
\item  prints the degree of a vertex in the graph of $P(G,v)$;
\item  visualizes the graph of $P(G,v)$;
\item  visualizes the Schlegel diagram of $P(G,v)$;
\item  visualizes $P(G,v)$ if the polytope is of dimension 2 or 3.
\end{itemize}
 The function uses Polymake software. \\
 \index{PolytopalComplex} \texttt{ PolytopalComplex(G,v) } \\
 \texttt{ PolytopalComplex(G,v,n) } 

 Inputs a permutation group or matrix group $G$ of degree $n$ and a rational vector $v$ of length $n$. In both cases there is a natural action of $G$ on $v$. Let $P(G,v)$ be the convex polytope arising as the convex hull of the Euclidean points in
the orbit of $v$ under the action of $G$. The cellular chain complex $C_*=C_*(P(G,v))$ is an exact sequence of (not necessarily free) $ZG$-modules. The function returns a component object $R$ with components: 
\begin{itemize}
\item  $R!.dimension(k)$ is a function which returns the number of $G$-orbits of the $k$-dimensional faces in $P(G,v)$. If each $k$-face has trivial stabilizer subgroup in $G$ then $C_k$ is a free $ZG$-module of rank $R.dimension(k)$. 
\item  $R!.stabilizer(k,n)$ is a function which returns the stabilizer subgroup for a face in the $n$-th orbit of $k$-faces. 
\item  If all faces of dimension {\textless}$k+1$ have trivial stabilizer group then the first $k$ terms of $C_*$ constitute part of a free $ZG$-resolution. The boundary map is described by the function $boundary(k,n)$ . (If some faces have non-trivial stabilizer group then $C_*$ is not free and no attempt is made to determine signs for the boundary map.) 
\item  $R!.elements$, $R!.group$, $R!.properties$ are as in a $ZG$-resolution. 
\end{itemize}
 If an optional third input variable $n$ is used, then only the first $n$ terms of the resolution $C_*$ will be computed. 

 The function uses Polymake software. \\
 \index{PolytopalGenerators} \texttt{ PolytopalGenerators(G,v) } 

 Inputs a permutation group or matrix group $G$ of degree $n$ and a rational vector $v$ of length $n$. In both cases there is a natural action of $G$ on $v$, and the vector $v$ must be chosen so that it has trivial stabilizer subgroup in $G$. Let $P(G,v)$ be the convex polytope arising as the convex hull of the Euclidean points in
the orbit of $v$ under the action of $G$. The function returns a record $P$ with components: 
\begin{itemize}
\item  $P.generators$ is a list of all those elements $g$ in $G$ such that $g\cdot v$ has an edge in common with $v$. The list is a generating set for $G$.
\item  $P.vector$ is the vector $v$.
\item $P.hasseDiagram$ is the Hasse diagram of the cone at $v$. 
\end{itemize}
 The function uses Polymake software. The function is joint work with Seamus
Kelly. \\
 \index{VectorStabilizer} \texttt{ VectorStabilizer(G,v) } 

 Inputs a permutation group or matrix group $G$ of degree $n$ and a rational vector of degree $n$. In both cases there is a natural action of $G$ on $v$ and the function returns the group of elements in $G$ that fix $v$. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Cocycles}}\logpage{[ 13, 0, 0 ]}
\hyperdef{L}{X85A9B66278AF63D9}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{CcGroup (HAPcocyclic)} \texttt{ CcGroup(A,f) } 

 Inputs a $G$-module $A$ (i.e. an abelian $G$-outer group) and a standard 2-cocycle f $G x G ---> A$. It returns the extension group determined by the cocycle. The group is
returned as a CcGroup. 

 This is a HAPcocyclic function and thus only works when HAPcocyclic is loaded. \\
 \index{CocycleCondition} \texttt{ CocycleCondition(R,n) } 

 Inputs a resolution $R$ and an integer $n${\textgreater}$0$. It returns an integer matrix $M$ with the following property. Suppose $d=R.dimension(n)$. An integer vector $f=[f_1, \ldots , f_d]$ then represents a $ZG$-homomorphism $R_n \longrightarrow Z_q$ which sends the $i$th generator of $R_n$ to the integer $f_i$ in the trivial $ZG$-module $Z_q$ (where possibly $q=0$ ). The homomorphism $f$ is a cocycle if and only if $M^tf=0$ mod $q$. \\
 \index{StandardCocycle} \texttt{ StandardCocycle(R,f,n) } \\
 \texttt{ StandardCocycle(R,f,n,q) } 

 Inputs a $ZG$-resolution $R$ (with contracting homotopy), a positive integer $n$ and an integer vector $f$ representing an $n$-cocycle $R_n \longrightarrow Z_q$ where $G$ acts trivially on $Z_q$. It is assumed $q=0$ unless a value for $q$ is entered. The command returns a function $F(g_1, ..., g_n)$ which is the standard cocycle $G_n \longrightarrow Z_q$ corresponding to $f$. At present the command is implemented only for $n=2$ or $3$. \\
 \index{Syzygy} \texttt{ Syzygy(R,g) } 

 Inputs a $ZG$-resolution $R$ (with contracting homotopy) and a list $g = [g[1], ..., g[n]]$ of elements in $G$. It returns a word $w$ in $R_n$. The word $w$ is the image of the $n$-simplex in the standard bar resolution corresponding to the $n$-tuple $g$. This function can be used to construct explicit standard $n$-cocycles. (Currently implemented only for n{\textless}4.) \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Words in free $ZG$-modules }}\logpage{[ 14, 0, 0 ]}
\hyperdef{L}{X8276B4377D092A80}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{AddFreeWords} \texttt{ AddFreeWords(v,w) } 

 Inputs two words $v,w$ in a free $ZG$-module and returns their sum $v+w$. If the characteristic of $Z$ is greater than $0$ then the next function might be more efficient. \\
 \index{AddFreeWordsModP} \texttt{ AddFreeWordsModP(v,w,p) } 

 Inputs two words $v,w$ in a free $ZG$-module and the characteristic $p$ of $Z$. It returns the sum $v+w$. If $p=0$ the previous function might be fractionally quicker. \\
 \index{AlgebraicReduction} \texttt{ AlgebraicReduction(w) } \\
 \texttt{ AlgebraicReduction(w,p) } 

 Inputs a word $w$ in a free $ZG$-module and returns a reduced version of the word in which all pairs of
mutually inverse letters have been cancelled. The reduction is performed in a
free abelian group unless the characteristic $p$ of $Z$ is entered. \\
 \index{MultiplyWord} \texttt{ Multiply Word(n,w) } 

 Inputs a word $w$ and integer $n$. It returns the scalar multiple $n\cdot w$. \\
 \index{Negate} \texttt{ Negate([i,j]) } 

 Inputs a pair $[i,j]$ of integers and returns $[-i,j]$. \\
 \index{NegateWord} \texttt{ NegateWord(w) } 

 Inputs a word $w$ in a free $ZG$-module and returns the negated word $-w$. \\
 \index{PrintZGword} \texttt{ PrintZGword(w,elts) } 

 Inputs a word $w$ in a free $ZG$-module and a (possibly partial but sufficient) listing elts of the elements
of $G$. The function prints the word $w$ to the screen in the form 

 $r_1E_1 + \ldots + r_nE_n$ 

 where $r_i$ are elements in the group ring $ZG$, and $E_i$ denotes the $i$-th free generator of the module. \\
 \index{TietzeReduction} \texttt{ TietzeReduction(S,w) } 

 Inputs a set $S$ of words in a free $ZG$-module, and a word $w$ in the module. The function returns a word $w'$ such that \texttt{\symbol{123}}$S,w'$\texttt{\symbol{125}} generates the same abelian group as
\texttt{\symbol{123}}$S,w$\texttt{\symbol{125}}. The word $w'$ is possibly shorter (and certainly no longer) than $w$. This function needs to be improved! \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ $FpG$-modules}}\logpage{[ 15, 0, 0 ]}
\hyperdef{L}{X81A2A3C97C09685E}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{DirectSumOfFpGModules} \texttt{ DirectSumOfFpGModules(M,N) } \\
 \texttt{ DirectSumOfFpGModules([ M[1], M[2], ..., M[k] ])) } 

 Inputs two $FpG$-modules $M$ and $N$ with common group and characteristic. It returns the direct sum of $M$ and $N$ as an $FpG$-Module. 

 Alternatively, the function can input a list of $FpG$-modules with common group $G$. It returns the direct sum of the list. \\
 \index{FpGModule} \texttt{ FpGModule(A,P) } \\
 \texttt{ FpGModule(A,G,p) } 

 Inputs a $p$-group $P$ and a matrix $A$ whose rows have length a multiple of the order of $G$. It returns the ``canonical'' $FpG$-module generated by the rows of $A$. 

 A small non-prime-power group $G$ can also be input, provided the characteristic $p$ is entered as a third input variable. \\
 \index{FpGModuleDualBasis} \texttt{ FpGModuleDualBasis(M) } 

 Inputs an $FpG$-module $M$. It returns a record $R$ with two components: 
\begin{itemize}
\item $R.freeModule$ is the free module $FG$ of rank one.
\item $R.basis$ is a list representing an $F$-basis for the module $Hom_{FG}(M,FG)$. Each term in the list is a matrix $A$ whose rows are vectors in $FG$ such that $M!.generators[i] \longrightarrow A[i]$ extends to a module homomorphism $M \longrightarrow FG$. 
\end{itemize}
 \\
 \index{FpGModuleHomomorphism} \texttt{ FpGModuleHomomorphism(M,N,A) } \\
 \texttt{ FpGModuleHomomorphismNC(M,N,A) } 

 Inputs $FpG$-modules $M$ and $N$ over a common $p$-group $G$. Also inputs a list $A$ of vectors in the vector space spanned by $N!.matrix$. It tests that the function 

 $ M!.generators[i] \longrightarrow A[i]$ 

 extends to a homomorphism of $FpG$-modules and, if the test is passed, returns the corresponding $FpG$-module homomorphism. If the test is failed it returns fail. 

 The "NC" version of the function assumes that the input defines a homomorphism
and simply returns the $FpG$-module homomorphism. \\
 \index{DesuspensionFpGModule} \texttt{ DesuspensionFpGModule(M,n)} \\
 \texttt{ DesuspensionFpGModule(R,n) } 

 Inputs a positive integer $n$ and and FpG-module $M$. It returns an FpG-module $D^nM$ which is mathematically related to $M$ via an exact sequence $ 0 \longrightarrow D^nM \longrightarrow R_n \longrightarrow \ldots
\longrightarrow R_0 \longrightarrow M \longrightarrow 0$ where $R_\ast$ is a free resolution. (If $G=Group(M)$ is of prime-power order then the resolution is minimal.) 

 Alternatively, the function can input a positive integer $n$ and at least $n$ terms of a free resolution $R$ of $M$. \\
 \index{RadicalOfFpGModule} \texttt{ RadicalOfFpGModule(M) } 

 Inputs an $FpG$-module $M$ with $G$ a $p$-group, and returns the Radical of $M$ as an $FpG$-module. (Ig $G$ is not a $p$-group then a submodule of the radical is returned. \\
 \index{GeneratorsOfFpGModule} \texttt{ GeneratorsOfFpGModule(M) } 

 Inputs an $FpG$-module $M$ and returns a matrix whose rows correspond to a minimal generating set for $M$. \\
 \index{ImageOfFpGModuleHomomorphism} \texttt{ ImageOfFpGModuleHomomorphism(f) } 

 Inputs an $FpG$-module homomorphism $f:M \longrightarrow N$ and returns its image $f(M)$ as an $FpG$-module. \\
 \index{IntersectionOfFpGModules} \texttt{ IntersectionOfFpGModules(M,N) } 

 Inputs two $FpG$-modules $M, N$ arising as submodules in a common free module $(FG)^n$ where $G$ is a finite group and $F$ the field of $p$-elements. It returns the $FpG$-module arising as the intersection of $M$ and $N$. \\
 \index{IsFpGModuleHomomorphismData} \texttt{ IsFpGModuleHomomorphismData(M,N,A) } 

 Inputs $FpG$-modules $M$ and $N$ over a common $p$-group $G$. Also inputs a list $A$ of vectors in the vector space spanned by $N!.matrix$. It returns true if the function 

 $ M!.generators[i] \longrightarrow A[i]$ 

 extends to a homomorphism of $FpG$-modules. Otherwise it returns false. \\
 \index{MultipleOfFpGModule} \texttt{ MultipleOfFpGModule(w,M) } 

 Inputs an $FpG$-module $M$ and a list $w:=[g_1 , ..., g_t]$ of elements in the group $G=M!.group$. The list $w$ can be thought of as representing the element $w=g_1 + \ldots + g_t$ in the group algebra $FG$, and the function returns a semi-echelon matrix $B$ which is a basis for the vector subspace $wM$ . \\
 \index{ProjectedFpGModule} \texttt{ ProjectedFpGModule(M,k) } 

 Inputs an $FpG$-module $M$ of ambient dimension $n|G|$, and an integer $k$ between $1$ and $n$. The module $M$ is a submodule of the free module $(FG)^n$ . Let $M_k$ denote the intersection of $M$ with the $k$-th summand of $(FG)^n$ . The function returns $M_k$ as an $FpG$-module with ambient dimension $n|G|$. \\
 \index{RandomHomomorphismOfFpGModules} \texttt{ RandomHomomorphismOfFpGModules(M,N) } 

 Inputs two $FpG$-modules $M$ and $N$ over a common group $G$. It returns a random matrix $A$ whose rows are vectors in $N$ such that the function 

 $ M!.generators[i] \longrightarrow A[i]$ 

 extends to a homomorphism $M \longrightarrow N$ of $FpG$-modules. (There is a problem with this function at present.) \\
 \index{Rank} \texttt{ Rank(f) } 

 Inputs an $FpG$-module homomorphism $f:M \longrightarrow N$ and returns the dimension of the image of $f$ as a vector space over the field $F$ of $p$ elements. \\
 \index{SumOfFpGModules} \texttt{ SumOfFpGModules(M,N) } 

 Inputs two $FpG$-modules $M, N$ arising as submodules in a common free module $(FG)^n$ where $G$ is a finite group and $F$ the field of $p$-elements. It returns the $FpG$-Module arising as the sum of $M$ and $N$. \\
 \index{SumOp} \texttt{ SumOp(f,g) } 

 Inputs two $FpG$-module homomorphisms $f,g:M \longrightarrow N$ with common sorce and common target. It returns the sum $f+g:M \longrightarrow N$ . (This operation is also available using "+". \\
 \index{VectorsToFpGModuleWords} \texttt{ VectorsToFpGModuleWords(M,L) } 

 Inputs an $FpG$-module $M$ and a list $L=[v_1,\ldots ,v_k]$ of vectors in $M$. It returns a list $L'= [x_1,...,x_k]$ . Each $x_j=[[W_1,G_1],...,[W_t,G_t]]$ is a list of integer pairs corresponding to an expression of $v_j$ as a word 

 $ v_j = g_1*w_1 + g_2*w_1 + ... + g_t*w_t $ 

 where 

 $g_i=Elements(M!.group)[G_i]$ 

 $w_i=GeneratorsOfFpGModule(M)[W_i]$ . \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Meataxe modules}}\logpage{[ 16, 0, 0 ]}
\hyperdef{L}{X85B05BBA78ED7BE2}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{DesuspensionMtxModule} \texttt{DesuspensionMtxModule(M)} 

 Inputs a meataxe module $M$ over the field of $p$ elements and returns an FpG-module DM. The two modules are related
mathematically by the existence of a short exact sequence $DM \longrightarrow FM \longrightarrow M$ with $FM$ a free module. Thus the homological properties of $DM$ are equal to those of $M$ with a dimension shift. 

 (If $G:=Group(M.generators)$ is a $p$-group then $FM$ is a projective cover of $M$ in the sense that the homomorphism $FM \longrightarrow M$ does not factor as $FM \longrightarrow P \longrightarrow M$ for any projective module $P$.) \\
 \index{FpG{\textunderscore}to{\textunderscore}MtxModule} \texttt{FpG{\textunderscore}to{\textunderscore}MtxModule(M)} 

 Inputs an FpG-module $M$ and returns an isomorphic meataxe module. \\
 \index{GeneratorsOfMtxModule} \texttt{ GeneratorsOfMtxModule(M)} 

 Inputs a meataxe module $M$ acting on, say, the vector space $V$. The function returns a minimal list of row vectors in $V$ which generate $V$ as a $G$-module (where G=Group(M.generators) ). \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ G-Outer Groups}}\logpage{[ 17, 0, 0 ]}
\hyperdef{L}{X7D02CE0A83211FB7}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{GOuterGroup} \texttt{GOuterGroup(E,N)} \\
 \texttt{GOuterGroup()} 

 Inputs a group $E$ and normal subgroup $N$. It returns $N$ as a $G$-outer group where $G=E/N$. 

 The function can be used without an argument. In this case an empty outer
group $C$ is returned. The components must be set using SetActingGroup(C,G),
SetActedGroup(C,N) and SetOuterAction(C,alpha). \\
 \index{GOuterGroupHomomorphismNC} \texttt{GOuterGroupHomomorphismNC(A,B,phi)} \\
 \texttt{GOuterGroupHomomorphismNC()} 

 Inputs G-outer groups $A$ and $B$ with common acting group, and a group homomorphism phi:ActedGroup(A)
--{\textgreater} ActedGroup(B). It returns the corresponding G-outer
homomorphism PHI:A--{\textgreater} B. No check is made to verify that phi is
actually a group homomorphism which preserves the G-action. 

 The function can be used without an argument. In this case an empty outer
group homomorphism $PHI$ is returned. The components must then be set. \\
 \index{GOuterHomomorphismTester} \texttt{GOuterHomomorphismTester(A,B,phi)} 

 Inputs G-outer groups $A$ and $B$ with common acting group, and a group homomorphism phi:ActedGroup(A)
--{\textgreater} ActedGroup(B). It tests whether phi is a group homomorphism
which preserves the G-action. 

 The function can be used without an argument. In this case an empty outer
group homomorphism $PHI$ is returned. The components must then be set. \\
 \index{Centre} \texttt{Centre(A)} 

 Inputs G-outer group $A$ and returns the group theoretic centre of ActedGroup(A) as a G-outer group. \\
 \index{DirectProductGog} \texttt{DirectProductGog(A,B)} \\
 \texttt{DirectProductGog(Lst)} 

 Inputs G-outer groups $A$ and $B$ with common acting group, and returns their group-theoretic direct product as
a G-outer group. The outer action on the direct product is the diagonal one. 

 The function also applies to a list Lst of G-outer groups with common acting
group. 

 For a direct product D constructed using this function, the embeddings and
projections can be obtained (as G-outer group homomorphisms) using the
functions Embedding(D,i) and Projection(D,i). \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Cat-1-groups}}\logpage{[ 18, 0, 0 ]}
\hyperdef{L}{X7B54B8CA841C517B}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{AutomorphismGroupAsCatOneGroup} \texttt{ AutomorphismGroupAsCatOneGroup(G)} 

 Inputs a group $G$ and returns the Cat-1-group $C$ corresponding th the crossed module $G\rightarrow Aut(G)$. \\
 \index{HomotopyGroup} \texttt{HomotopyGroup(C,n)} 

 Inputs a cat-1-group $C$ and an integer n. It returns the $n$th homotopy group of $C$. \\
 \index{HomotopyModule} \texttt{HomotopyModule(C,2)} 

 Inputs a cat-1-group $C$ and an integer n=2. It returns the second homotopy group of $C$ as a G-module (i.e. abelian G-outer group) where G is the fundamental group of
C. \\
 \index{ModuleAsCatOneGroup} \texttt{ ModuleAsCatOneGroup(G,alpha,M)} 

 Inputs a group $G$, an abelian group $M$ and a homomorphism $\alpha\colon G\rightarrow Aut(M)$. It returns the Cat-1-group $C$ corresponding th the zero crossed module $0\colon M\rightarrow G$. \\
 \index{MooreComplex} \texttt{ MooreComplex(C)} 

 Inputs a cat-1-group $C$ and returns its Moore complex $[M_1 \rightarrow M_0]$ as a list whose single entry is a homomorphism of groups. \\
 \index{NormalSubgroupAsCatOneGroup} \texttt{ NormalSubgroupAsCatOneGroup(G,N)} 

 Inputs a group $G$ with normal subgroup $N$. It returns the Cat-1-group $C$ corresponding th the inclusion crossed module $ N\rightarrow G$. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Coxeter diagrams and graphs of groups}}\logpage{[ 19, 0, 0 ]}
\hyperdef{L}{X79D0502085B6734A}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{CoxeterDiagramComponents} \texttt{ CoxeterDiagramComponents(D) } 

 Inputs a Coxeter diagram $D$ and returns a list $[D_1, ..., D_d]$ of the maximal connected subgraphs $D_i$. \\
 \index{CoxeterDiagramDegree} \texttt{ CoxeterDiagramDegree(D,v) } 

 Inputs a Coxeter diagram $D$ and vertex $v$. It returns the degree of $v$ (i.e. the number of edges incident with $v$). \\
 \index{CoxeterDiagramDisplay} \texttt{ CoxeterDiagramDisplay(D) } \\
 \texttt{ CoxeterDiagramDisplay(D,"web browser") } 

 Inputs a Coxeter diagram $D$ and displays it as a .gif file. It uses the Mozilla web browser as a default
to view the diagram. An alternative browser can be set using a second
argument. 

 This function requires Graphviz software. \\
 \index{CoxeterDiagramFpArtinGroup} \texttt{ CoxeterDiagramFpArtinGroup(D) } 

 Inputs a Coxeter diagram $D$ and returns the corresponding finitely presented Artin group. \\
 \index{CoxeterDiagramFpCoxeterGroup} \texttt{ CoxeterDiagramFpCoxeterGroup(D) } 

 Inputs a Coxeter diagram $D$ and returns the corresponding finitely presented Coxeter group. \\
 \index{CoxeterDiagramIsSpherical} \texttt{ CoxeterDiagramIsSpherical(D) } 

 Inputs a Coxeter diagram $D$ and returns "true" if the associated Coxeter groups is finite, and returns
"false" otherwise. \\
 \index{CoxeterDiagramMatrix} \texttt{ CoxeterDiagramMatrix(D) } 

 Inputs a Coxeter diagram $D$ and returns a matrix representation of it. The matrix is given as a function $DiagramMatrix(D)(i,j)$ where $i,j$ can range over the vertices. \\
 \index{CoxeterSubDiagram} \texttt{ CoxeterSubDiagram(D,V) } 

 Inputs a Coxeter diagram $D$ and a subset $V$ of its vertices. It returns the full sub-diagram of $D$ with vertex set $V$. \\
 \index{CoxeterDiagramVertices} \texttt{ CoxeterDiagramVertices(D) } 

 Inputs a Coxeter diagram $D$ and returns its set of vertices. \\
 \index{EvenSubgroup} \texttt{ EvenSubgroup(G) } 

 Inputs a group $G$ and returns a subgroup $G^+$. The subgroup is that generated by all products $xy$ where $x$ and $y$ range over the generating set for $G$ stored by GAP. The subgroup is probably only meaningful when $G$ is an Artin or Coxeter group. \\
 \index{GraphOfGroupsDisplay} \texttt{ GraphOfGroupsDisplay(D) } \\
 \texttt{ GraphOfGroupsDisplay(D,"web browser") } 

 Inputs a graph of groups $D$ and displays it as a .gif file. It uses the Mozilla web browser as a default
to view the diagram. An alternative browser can be set using a second
argument. 

 This function requires Graphviz software. \\
 \index{GraphOfGroupsTest} \texttt{ GraphOfGroupsTest(D) } 

 Inputs an object $D$ and itries to test whether it is a Graph of Groups. However, it DOES NOT test
the injectivity of any homomorphisms. It returns true if $D$ passes the test, and false otherwise. 

 Note that there is no function $IsHapGraphOfGroups()$ because no special data type has been created for these graphs. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Some functions for accessing basic data}}\logpage{[ 20, 0, 0 ]}
\hyperdef{L}{X7AE3B902812A10B0}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{BoundaryMap} \texttt{ BoundaryMap(C) } 

 Inputs a resolution, chain complex or cochain complex $C$ and returns the function $C!.boundary$. \\
 \index{BoundaryMatrix} \texttt{ BoundaryMatrix(C,n) } 

 Inputs a chain or cochain complex $C$ and integer $n${\textgreater}$0$. It returns the $n$-th boundary map of $C$ as a matrix. \\
 \index{Dimension} \texttt{ Dimension(C) } \\
 \texttt{ Dimension(M) } 

 Inputs a resolution, chain complex or cochain complex $C$ and returns the function $C!.dimension$ . 

 Alternatively, inputs an $FpG$-module $M$ and returns its dimension as a vector space over the field of $p$ elements. \\
 \index{EvaluateProperty} \texttt{ EvaluateProperty(X,"name") } 

 Inputs a component object $X$ (such as a $ZG$-resolution or chain map) and a string "name" (such as "characteristic" or
"type"). It searches $X.property$ for the pair ["name",value] and returns value. If $X.property$ does not exist, or if ["name",value] does not exist, it returns fail. \\
 \index{GroupOfResolution} \texttt{ GroupOfResolution(R) } 

 Inputs a $ZG$-resolution $R$ and returns the group $G$. \\
 \index{Length} \texttt{ Length(R) } 

 Inputs a resolution $R$ and returns its length (i.e. the number of terms of $R$ that HAP has computed). \\
 \index{Map} \texttt{ Map(f) } 

 Inputs a chain map, or cochain map or equivariant chain map $f$ and returns the mapping function (as opposed to the target or the source of $f$) . \\
 \index{Source} \texttt{ Source(f) } 

 Inputs a chain map, or cochain map, or equivariant chain map, or $FpG$-module homomorphism $f$ and returns it source. \\
 \index{Target} \texttt{ Target(f) } 

 Inputs a chain map, or cochain map, or equivariant chain map, or $FpG$-module homomorphism $f$ and returns its target. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Parallel Computation - Core Functions}}\logpage{[ 21, 0, 0 ]}
\hyperdef{L}{X85F9DF1985B88C37}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{ChildProcess} \texttt{ChildProcess()} \\
 \texttt{ChildProcess("computer.ac.wales")} 

 This starts a GAP session as a child process and returns a stream to the child
process. If no argument is given then the child process is created on the
local machine; otherwise the argument should be the address of a remote
computer for which ssh has been configured to require no password from the
user. 

 (To configure ssh so that the user can login without a password prompt from
"thishost" to "remotehost" either consult "man ssh" or \\
 \\
 - open a shell on thishost\\
 - cd .ssh\\
 - ls\\
 -{\textgreater} if id{\textunderscore}dsa, id{\textunderscore}rsa etc exists,
skip the next two steps!\\
 - ssh-keygen -t rsa\\
 - ssh-keygen -t dsa\\
 - scp *.pub user@remotehost:\texttt{\symbol{126}}/\\
 - ssh remotehost -l user\\
 - cat id{\textunderscore}rsa.pub {\textgreater}{\textgreater}
.ssh/authorized{\textunderscore}keys\\
 - cat id{\textunderscore}dsa.pub {\textgreater}{\textgreater}
.ssh/authorized{\textunderscore}keys\\
 - rm id{\textunderscore}rsa.pub id{\textunderscore}dsa.pub\\
 - exit\\
 \\
 You should now be able to connect from "thishost" to "remotehost" without a
password prompt.) \\
 \index{ChildClose} \texttt{ChildClose(s)} 

 This closes the stream s to a child GAP process. \\
 \index{ChildCommand} \texttt{ChildCommand("cmd;",s)} 

 This runs a GAP command "cmd;" on the child process accessed by the stream s.
Here "cmd;" is a string representing the command. \\
 \index{NextAvailableChild} \texttt{ NextAvailableChild(L)} 

 Inputs a list $L$ of child processes and returns a child in $L$ which is ready for computation (as soon as such a child is available). \\
 \index{IsAvailableChild} \texttt{ IsAvailableChild(s)} 

 Inputs a child process $s$ and returns true if s is currently available for computations, and false
otherwise. \\
 \index{ChildPut} \texttt{ ChildPut(A,"B",s)} 

 This copies a GAP object A on the parent process to an object B on the child
process s. (The copying relies on the function PrintObj(A); ) \\
 \index{ChildGet} \texttt{ ChildGet("A",s)} 

 This functions copies a GAP object A on the child process s and returns it on
the parent process. (The copying relies on the function PrintObj(A); ) \\
 \index{HAPPrintTo} \texttt{HAPPrintTo("file",R)} 

 Inputs a name "file" of a new text file and a HAP object R. It writes the
object R to "file". Currently this is only implemented for R equal to a
resolution. \\
 \index{HAPRead} \texttt{HAPRead("file",R)} 

 Inputs a name "file" containing a HAP object R and returns the object.
Currently this is only implemented for R equal to a resolution. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Parallel Computation - Extra Functions}}\logpage{[ 22, 0, 0 ]}
\hyperdef{L}{X85B21D56816A1B39}{}
{
  \begin{center}
\begin{tabular}{|l|} \index{ChildFunction} \texttt{ChildFunction("function(arg);",s)} 

 This runs the GAP function "function(arg);" on a child process accessed by the
stream s. The output from "func;" can be accessed via the stream. \\
 \index{ChildRead} \texttt{ChildRead(s)} 

 This returns, as a string, the output of the last application of $ChildFunction("function(arg);",s)$. \\
 \index{ChildReadEval} \texttt{ChildReadEval(s)} 

 This returns, as an evaluated string, the output of the last application of $ChildFunction("function(arg);",s)$. \\
 \index{ParallelList} \texttt{ParallelList(I,fn,L)} 

 Inputs a list $I$, a function $fn$ such that $fn(x)$ is defined for all $x$ in $I$, and a list of children $L$. It uses the children in $L$ to compute $List(I,x->fn(x))$. (Obviously the function $fn$ must be defined on all child processes in $L$.) \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Topological Data Analysis}}\logpage{[ 23, 0, 0 ]}
\hyperdef{L}{X7B7E077887694A9F}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{MatrixToTopologicalSpace} \texttt{ MatrixToTopologicalSpace(A,n)} 

 Inputs an integer matrix $A$ and an integer $n$. It returns a 2-dimensional topological space corresponding to the
black/white image determined by the threshold $n$ and the values of the pixels in $A$. \\
 \index{ReadImageAsTopologicalSpace} \texttt{ ReadImageAsTopologicalSpace("file.png",n)} \texttt{ ReadImageAsTopologicalSpace("file.png",[m,n])} 

 Reads an image file ("file.png", "file.eps", "file.bmp" etc) and an integer $n$ or pair $[m,n]$ of integers between 0 and 765. It returns a topological space based on the
black/white version of the image determined by the threshold $n$ or threshold range $[m,n]$. \\
 \index{ReadImageAsMatrix} \texttt{ ReadImageAsMatrix("file.png")} 

 Reads an image file ("file.png", "file.eps", "file.bmp" etc) and returns an
integer matrix whose entries are the sum of the RGB values of the pixels in
the image. \\
 \index{WriteTopologicalSpaceAsImage} \texttt{ WriteTopologicalSpaceAsImage(T,"filename","ext")} 

 Inputs a 2-dimensional topological space T, and a filename followed by its
extension (e.g. "myfile" followed by "png"). A black/white image is saved to
the file. \\
 \index{ViewTopologicalSpace} \texttt{ ViewTopologicalSpace(T)} \texttt{ ViewTopologicalSpace(T,"mozilla")} 

 Inputs a topological space T, and optionally a command such as "mozilla" for
viewing image files. A black/white image is displayed. \\
 \index{Bettinumbers} \texttt{ Bettinumbers(T,n)} \texttt{ Bettinumbers(T)} 

 Inputs a topological space $T$ and a non-negative integer $n$. It returns the n-th betti number of $T$. If the integer $n$ is not input then a list of all betti numbers is returned. \\
 \index{PathComponent} \texttt{ PathComponent(T,n)} 

 Inputs a topological space $T$ and an integer $n$ in the rane 0, ..., Bettinumbers(T,0) . It returns the n-th path component of $T$ as a topological space. \\
 \index{SingularChainComplex} \texttt{ SingularChainComplex(A)} 

 Inputs a topological space $T$ and returns a (usually very large) integral chain complex that is homotopy
equivalent to the singular chain complex of $T$. \\
 \index{ContractTopologicalSpace} \texttt{ ContractTopologicalSpace(T)} 

 Inputs a topological space $T$ of dimension $d$ and removes $d$-dimensional cells from $T$ without changing the homotopy type of $T$. When the function has been applied, no further $d$-cells can be removed from $T$ without changing the homotopy type. \\
 \index{BoundaryTopologicalSpace} \texttt{ BoundaryTopologicalSpace(T)} 

 Inputs a topological space $T$ and returns its boundars as a topological space. \\
 \index{BoundarySingularities} \texttt{ BoundarySingularities(T)} 

 Inputs a topological space $T$ and returns the subspace of points in the boundary where the boundary is not
differentiable. (The method for deciding differentiability at a point is
crude/discrete and prone to errors.) The zeroth betti number of the set of
points is a measure of the number of "corners" in the boundary of $T$. \\
 \index{ThickenedTopologicalSpace} \texttt{ ThickenedTopologicalSpace(T)} \texttt{ ThickenedTopologicalSpace(T,n)} 

 Inputs a topological space $T$ and returns a topological space $S$. If a euclidean point is in $T$ then this point and all its perpendicularly neighbouring euclidean points are
included in $S$. 

 If a positive integer $n$ is input as a second argument then the thickening process is repeated $n$ times. \\
 \index{ComplementTopologicalSpace} \texttt{ ComplementTopologicalSpace(T)} 

 Inputs a topological space $T$ and returns a topological space $S$. A euclidean point is in $S$ precisely when the point is not in $T$. \\
 \index{ConcatenatedTopologicalSpace} \texttt{ ConcatenatedTopologicalSpace(L)} 

 Inputs a list $L$ of topological spaces whose underlying arrays of numbers all have equal
dimensions. It returns a topological space $T$ got by juxtaposing the spaces $L[1], L[2], ..., L[Length(L)]$. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Pseudo lists}}\logpage{[ 24, 0, 0 ]}
\hyperdef{L}{X87FE4ABB83AF131C}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{Add} \texttt{ Add(L,x)} 

 Let $L$ be a pseudo list of length $n$, and $x$ an object compatible with the entries in $L$. If $x$ is not in $L$ then this operation converts $L$ into a pseudo list of length n+1 by adding $x$ as the final entry. If $x$ is in $L$ the operation has no effect on $L$. \\
 \index{Append} \texttt{ Append(L,K)} 

 Let $L$ be a pseudo list and $K$ a list whose objects are compatible with those in $L$. This operation applies Add(L,x) for each x in $K$. \\
 \index{ListToPseudoList} \texttt{ ListToPseudoList(L)} 

 Inputs a list $L$ and returns the pseudo list representation of $L$. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Miscellaneous}}\logpage{[ 25, 0, 0 ]}
\hyperdef{L}{X7C5563A37D566DA5}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{BigStepLCS} \texttt{ BigStepLCS(G,n) } 

 Inputs a group $G$ and a positive integer $n$. It returns a subseries $G=L_1${\textgreater}$L_2${\textgreater}$ \ldots L_k=1$ of the lower central series of $G$ such that $L_i/L_{i+1}$ has order greater than $n$. \\
 \index{Compose(f,g)} \texttt{ Compose(f,g) } 

 Inputs two $FpG$-module homomorphisms $ f:M \longrightarrow N$ and $g:L \longrightarrow M$ with $Source(f)=Target(g)$ . It returns the composite homomorphism $fg:L \longrightarrow N$ . 

 This also applies to group homomorphisms $f,g$. \\
 \index{HAPcopyright} \texttt{ HAPcopyright() } 

 This function provides details of HAP'S GNU public copyright licence. \\
 \index{IsLieAlgebraHomomorphism} \texttt{ IsLieAlgebraHomomorphism(f) } 

 Inputs an object $f$ and returns true if $f$ is a homomorphism $f:A \longrightarrow B$ of Lie algebras (preserving the Lie bracket). \\
 \index{IsSuperperfect} \texttt{ IsSuperperfect(G) } 

 Inputs a group $G$ and returns "true" if both the first and second integral homology of $G$ is trivial. Otherwise, it returns "false". \\
 \index{MakeHAPManual} \texttt{MakeHAPManual()} 

 This function creates the manual for HAP from an XML file. \\
 \index{PermToMatrixGroup} \texttt{ PermToMatrixGroup(G,n) } 

 Inputs a permutation group $G$ and its degree $n$. Returns a bijective homomorphism $f:G \longrightarrow M$ where $M$ is a group of permutation matrices. \\
 \index{SolutionsMatDestructive} \texttt{ SolutionsMatDestructive(M,B) } 

 Inputs an $m×n$ matrix $M$ and a $k×n$ matrix $B$ over a field. It returns a k{\ensuremath{\times}}m matrix $S$ satisfying $SM=B$. 

 The function will leave matrix $M$ unchanged but will probably change matrix $B$. 

 (This is a trivial rewrite of the standard GAP function $SolutionMatDestructive(${\textless}$mat${\textgreater},{\textless}$vec${\textgreater}) .) \\
 \index{TestHap} \texttt{ TestHap() } 

 This runs a representative sample of HAP functions and checks to see that they
produce the correct output. \\
\end{tabular}\\[2mm]
\end{center}

 }

 \def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
