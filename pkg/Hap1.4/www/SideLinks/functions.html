<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>functions</title>
</head>
<body
 style="color: rgb(0, 0, 102); background-color: rgb(204, 255, 255);"
 alink="#000066" link="#000066" vlink="#000066">
<div style="text-align: center;">
<h2>DEFINITIONS OF SOME BASIC DATA TYPES <br>
</h2>
<table style="width: 100%; text-align: left;" border="0"
 cellpadding="10" cellspacing="10">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">In
the following definitions we use Z to denote either the ring of
integers, or the ring
of integers modulo a prime p. (Elsewhere in these web pages we denote
the latter by Z<sub>p</sub>
.) A <span style="font-style: italic;">ZG-resolution</span> means a
free
ZG-resolution of the trivial
ZG-module Z. A <span style="font-style: italic;">chain complex </span>means
a chain complex of free Z-modules.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; text-align: center;"><span
 style="font-weight: bold;"><br>
      <br>
TYPE</span><br>
      </td>
      <td style="vertical-align: top; text-align: center;"><span
 style="font-weight: bold;"><br>
      <br>
DEFINITION</span><br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">Free
ZG-module</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Let
eltsG be a (partial) listing of elements in some group G (which could
be finite or infinite).&nbsp; In order
to represent a word w in a free ZG-module M of rank n we use a
list of integer pairs w=[ [i<sub>1</sub>,g<sub>1</sub>], [i<sub>2</sub>,g<sub>2</sub>],
..., [i<sub>k</sub>,g<sub>k</sub>] ]. The
integers i<sub>j</sub> lie in the range between -n and n and correspond
to the
free ZG-generators of M and their additive inverses. The integers g<sub>j</sub>
are positive and correspond to the group element eltsG[g<sub>j</sub>].
The (partial) listing eltsG may contain duplicate copies of
elements of G.<br>
      <big> </big></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ZG-resolution</span><big><br>
      </big></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">A
ZG-resolution&nbsp; ... &#8594; M<sub>n</sub> &#8594; M<sub>n-1</sub> &#8594; ... &#8594; M<sub>1</sub>
&#8594; M<sub>0</sub> &#8594; Z<big> </big>is represented by a record R with the
following components.<br>
      <big> </big>
      <ul>
        <big> </big><li><span
 style="font-family: helvetica,arial,sans-serif;">R.dimension(k)</span>
is a function which returns the
ZG-rank of the module
M<sub>k</sub>.</li>
        <big> </big><li><span
 style="font-family: helvetica,arial,sans-serif;">R.boundary(k, j)</span>
is a function which returns
the image in M<sub>k-1</sub>
of the
j-th free generator of M<sub>k</sub>.</li>
        <big> </big><li><span
 style="font-family: helvetica,arial,sans-serif;">R.homotopy(k,[i,g]) </span>is
a function which
returns the image in M<sub>k+1</sub>,
under a contracting homotopy M<sub>k</sub> &#8594; M<sub>k+1</sub>, of
the element
[[i,g]]&nbsp; in M<sub>k</sub>. (The elements [[i,g]] freely generate M<sub>k</sub>
as an abelian group.) For some resolutions a contracting homotopy is
not
constructed, in which case R.homotopy is set equal to "fail". </li>
        <big> </big><li><span
 style="font-family: helvetica,arial,sans-serif;">R.elts</span> is a
(partial) list of (possibly
duplicate) elements
in G.</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">R.group</span>
is the group in question (and could be a permutation
group, matrix group, finitely presented group etc.).</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">R.properties</span>
is a list of pairs ["name", value] where
"name"
is a
string and value is a numerical or boolean value. Example pairs
are:&nbsp; ["length", n] which records that there are n terms in
the resolution; ["characteristic", p] which records the
characteristic of Z; ["reduced", true] which record that M<sub>0</sub>
is isomorphic to ZG; ["type","resolution"] which records the type of
the object R.<br>
        </li>
        <big> </big>
      </ul>
      <big> </big> </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">Equivariant<br>
chain
map</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">An
equivariant
chain mapping f : R &#8594; S from a ZG-resolution to a ZG'-resolution is
represented by a
record F with the following components.<br>
      <ul>
        <li><span style="font-family: helvetica,arial,sans-serif;">F.source</span>
is the ZG-resolution R.</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">F.target</span>
is the ZG'-resolution S.</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">F.mapping(k,[i,g])
          </span>is a
function which
returns the image in S<sub>k</sub>,
under the chain map, of
the element
[[i,g]]&nbsp; in R<sub>k</sub>.</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">F.properties</span>
is a list of pairs such as ["type", "equivariantChainMap"].<br>
        </li>
      </ul>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; color: rgb(255, 255, 255); background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 0);">Chain complex<br>
      <br>
(Cochain<br>
complex)<br>
      </span></span> </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(0, 0, 102);">A
chain complex&nbsp; ... &#8594; C<sub>n</sub> &#8594; C<sub>n-1</sub> &#8594; ... &#8594; C<sub>1</sub>
&#8594; C<sub>0 </sub><big> </big>is represented by a record C with the
following components.<br>
      <ul>
        <li><span style="font-family: helvetica,arial,sans-serif;">C.dimension(k)</span>
is a function which returns the
Z-rank of the module C<sub>k</sub>.</li>
        <big> </big><li><span
 style="font-family: helvetica,arial,sans-serif;">C.boundary(j, k) </span>is
a function which returns
the image in C<sub>k-1</sub>
of the
j-th free generator of C<sub>k</sub>. <br>
        </li>
        <big> </big><big> </big><li><span
 style="font-family: helvetica,arial,sans-serif;">C.properties</span>
is a list of pairs
["name",value] where "name"
is a
string and value is a numerical or boolean value. Example pairs
are:&nbsp; ["length", n] which would record that there are n terms in
the chain complex; ["characteristic", p] which would record the
characteristic of Z.</li>
      </ul>
      <br>
(A cochain complex&nbsp; ... &#8592; C<sub>n</sub> &#8592; C<sub>n-1</sub> &#8592; ... &#8592; C<sub>1</sub>
&#8592; C<sub>0 </sub><big> </big>is represented by a similar record
C.&nbsp; The only difference is that <span
 style="font-family: helvetica,arial,sans-serif;">C.boundary(k,j)</span>
returns an element in C<sub>k+1</sub>.) </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">Chain
map<br>
      <br>
(Cochain map)<br>
      </span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">A
chain mapping f : C &#8594; D between chain complexes is a record F with the
following components.<br>
      <ul>
        <li><span style="font-family: helvetica,arial,sans-serif;">F.source</span>
is the chain complex C.</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">F.target</span>
is the chain complex D.</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">F.mapping(k,i)
          </span>is a
function which
returns the image in D<sub>k</sub>,
under the chain map, of
the element i-th free generator of&nbsp; C<sub>k</sub>.</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">F.properties</span>
is a list of pairs such as ["type", "chainMap"].</li>
      </ul>
(A cochain mapping is represented by a similar record.)<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">Additive<br>
Functor<br>
      <br>
(Additive<br>
Contravariant<br>
Functor)<br>
      </span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">A
functor T(X) is a function which inputs either a ZG-resolution X=R,
or else an equivariant chain map between resolutions X=(f: R&#8594;S) .<br>
      <ul>
        <li>If&nbsp; X=R then T(R) is a chain complex.</li>
        <li>If X=(f:R&#8594;S) then T(X) is a Z-chain map T(R) &#8594; T(S).</li>
      </ul>
(A contavariant functor is similar, except that T(R) is a cochain
complex and T(R&#8594;S) is a cochain map T(S) &#8594; T(R). ) <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">Coxeter
diagram</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">A
Coxeter diagram is a finite graph (with at most one edge between a pair
of vertices) whose edges are labelled by integers n&gt;2 or
n = infinity. <span style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">The graph is represented as a list D = [L<sub>1</sub>,
... L<sub>t</sub>] in which each term is itself a list L<sub>k</sub> =
[v<sub>k</sub>,
[u<sub>k1</sub>,n<sub>k1</sub>], </span></span><span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">[u<sub>k2</sub>,n<sub>k2</sub>], ... </span></span><span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">[u<sub>km</sub>,n<sub>km</sub>]] such that
vertex v<sub>k</sub> is connected to vertex u<sub>kj</sub> by an edge
with label n<sub>kj</sub>. It is sufficient to list just those
vertices </span></span><span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">u<sub>kj</sub> &gt; v<sub>k</sub>.</span></span><span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;"> We set </span></span><span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">n<sub>kj</sub>=0 when</span></span><span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;"> the edge label is infinity. </span></span></td>
    </tr>
  </tbody>
</table>
<small><br>
</small></div>
<div style="text-align: center;"><span style="font-weight: bold;"><br>
</span>
<h2 style="text-align: center;"><br>
<span style="font-weight: bold;"></span></h2>
<h2 style="text-align: center;"><span style="font-weight: bold;">ALPHABETICAL
LIST OF HAP FUNCTIONS</span></h2>
<span style="font-weight: bold;"></span></div>
<table style="width: 100%; text-align: left;" border="0"
 cellpadding="10" cellspacing="10">
  <tbody>
    <tr>
      <td
 style="background-color: rgb(255, 255, 255); vertical-align: top; font-family: helvetica,arial,sans-serif; color: rgb(255, 204, 0);"><span
 style="color: rgb(0, 0, 0);">AddWords(v,w)</span><big><br>
      </big></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
two words v,w in a
free ZG-module and returns their sum v+w. If the characteristic of Z is
greater than 0 then the next function should be more efficient.<big><br>
      </big></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">AddWordsModP(v,w,p)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
two words v,w in a
free ZG-module and the characteristic p of Z. It returns the sum v+w.
If p=0 the previous function might be fractionally quicker.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: helvetica,arial,sans-serif; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="color: rgb(0, 0, 0);">AlgebraicReduction(w)<br>
      <br>
      </span><span style="color: rgb(0, 0, 0);">AlgebraicReduction(w,p)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a word w in a free
ZG-module and returns a reduced version of the word in which all pairs
of mutually inverse letters have been cancelled. The reduction is
performed in a free abelian group unless the characteristic p of Z is
entered.<big><br>
      </big></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">BigStepLCS(G,n)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a group G and a positive integer n. It returns a subseries G=L<sub>1</sub>&gt;L<sub>2</sub>&gt;...L<sub>k</sub>=1
of the lower central series of G such that L<sub>i</sub>/L<sub>i+1</sub>
has order greater than n.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">CocycleCondition(R,n)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a resolution R and an integer n&gt;0. It returns an integer matrix M
with the following property. Suppose d=R.dimension(n). An integer
vector f=[f<sub>1</sub>, ..., f<sub>d</sub>] then represents a
ZG-homomorphism R<sub>n</sub> &#8594; Z<sub>q</sub> which sends the ith
generator of R<sub>n</sub> to the integer f<sub>i</sub> in the trivial
ZG-module Z<sub>q</sub> (where possibly q=0). The homomorphism f is a
cocycle if and only if
M<sup>t</sup>f=0 mod q. <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">Cohomology(X)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
either a cochain complex X=C or a cochain map X=(C&#8594;D) over the integers
Z. At present only characteristic 0 is implemented. <br>
      <ul>
        <li>If X=C then the torsion coefficients of H<sup>n</sup>(C)
are
retuned.</li>
        <li>If X=(C&#8594;D) then the induced homomorphism H<sup>n</sup>(C) &#8594;
H<sup>n</sup>(D) is returned as a homomorphism of finitely presented
groups.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">CoxeterDiagram<br>
Components(D)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a Coxeter diagram D and returns a list [D<sub>1</sub>, ..., D<sub>d</sub>]
of the maximal connected subgraphs D<sub>i</sub>.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);"><span
 style="font-family: helvetica,arial,sans-serif;">CoxeterDiagram<br>
Degree(D,v)</span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a Coxeter diagram D and vertex v. It returns the degree of v (i.e. the
number of edges incident with v).<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 0);">CoxeterDiagram<br>
Fp</span><span style="color: rgb(0, 0, 0);">ArtinGroup(D)</span></span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">Inputs a Coxeter diagram D and returns the
corresponding
finitely presented Artin group.</span></span></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">CoxeterDiagram<br>
FpCoxeterGroup(D)</span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">I<span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">nputs a Coxeter diagram D and returns the
corresponding finitely presented Coxeter group.</span></span></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">CoxeterDiagram<br>
IsSpherical(D)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a Coxeter diagram D and returns "true" if the associated Coxeter groups
is finite, and returns "false" otherwise.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">CoxeterDiagram<br>
Matrix(D)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">I<span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">nputs a Coxeter diagram D and returns a
matrix representation of it. The matrix is given as a function <span
 style="font-family: helvetica,arial,sans-serif;">DiagramMatrix(D)(i,j)</span>
where i,j can range over the vertices.<br>
      </span></span></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);"><span
 style="font-family: helvetica,arial,sans-serif;">CoxeterSubDiagram(D,V)</span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a Coxeter diagram D and a subset V of its vertices. It returns the full
sub-diagram of D with vertex set V.</td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">CoxeterDiagram<br>
Vertices(D)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">I<span
 style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">nputs a Coxeter diagram D and returns its
set of vertices.<br>
      </span></span></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"></span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">Epicentre(G,N)<br>
      <br>
Epicentre(G)<br>
      </span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a finite group G and normal subgroup N and returns a subgroup Z<sup>*</sup>(G,N)
of the centre of N. The group Z<sup>*</sup>(G,N) is trivial if and only
if there is a crossed module d:E &#8594; G with N=Image(d) and with Ker(d)
equal to the subgroup of E consisting of those elements on which G acts
trivially. <br>
      <br>
If no value for N is entered then it is assumed that N=G. In this case
the group Z<sup>*</sup>(G,G) is trivial if and only if G is isomorphic
to a quotient G=E/Z(E) of some group E by the the centre of E.&nbsp;
(There are probably quicker ways to compute Z<sup>*</sup>(G,G) . )<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 0);">EquivariantChain</span><br
 style="color: rgb(0, 0, 0);">
      <span style="color: rgb(0, 0, 0);">Map(R,S,f)</span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution R, a ZG'-resolution S, and a group homomorphism f : G &#8594;
G'. It outputs a
record M with the following components.<br>
      <ul>
        <li><span style="font-family: helvetica,arial,sans-serif;">M.source</span>
is the resolution R.</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">M.target
          </span>is the resolution S.</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">M.mapping(w,n)</span>
is a function which gives the image in S<sub>n</sub>, under a chain map
induced by f, of a word w in R<sub>n</sub>. (Here&nbsp; R<sub>n</sub>
and S<sub>n </sub>are the n-th modules in the resolutions R and S.)</li>
        <li><span style="font-family: helvetica,arial,sans-serif;">F.properties</span>
is a list of pairs such as ["type", "equivariantChainMap"].</li>
      </ul>
      <br>
The
resolution S must have a contracting homotopy. </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">EvaluateProperty(X,"name")</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a record X (such as a ZG-resolution or chain map) and a string "name"
(such as "characteristic" or "type"). It searches X.property for
the&nbsp; pair ["name",value] and returns value. If X.property does not
exist, or if ["name",value] does not exist, it returns fail.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">EvenSubgroup(G)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a group G and returns a subgroup G<sup>+</sup>. The subgroup is that
generated by all products xy where x and y range over the generating
set for G stored by GAP. The subgroup is probably only meaningful when
G is an Artin or Coxeter group.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">GroupHomology(X,n)</span><br
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">
      <br>
      <span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">GroupHomology(X,n,p)</span><br
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">
      <br>
      <span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);"></span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a positive integer n and either a finite group X=G or a Coxeter diagram
X=D representing an infinite Artin group G.&nbsp; It
returns the torsion coefficients of the integral homology H<sub>n</sub>(G,Z).
      <br>
      <br>
There is an optional third
argument which, when set equal to a prime p, causes the<span
 style="color: rgb(51, 0, 51);"><span style="color: rgb(0, 0, 102);">
function to return the rank of the mod p homology </span></span>H<sub>n</sub>(G,Z<sub>p</sub>).
      <br>
      <span style="color: rgb(51, 0, 51);"><span
 style="color: rgb(0, 0, 102);"> <br>
This function is a composite of more basic functions, and makes choices
for a number of parameters. For a particular group you would almost
certainly be better using the more basic functions and making the
choices yourself!<br>
      </span></span></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">HAPcopyright()</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">This
function provides details of HAP'S GNU public copyright licence.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 0);">Homology(X,n)</span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
either a chain complex X=C or a chain map X=(C&#8594;D). <br>
      <ul>
        <li>If X=C then the torsion coefficients of H<sub>n</sub>(C)
are
retuned.</li>
        <li>If X=(C&#8594;D) then the induced homomorphism H<sub>n</sub>(C) &#8594;
H<sub>n</sub>(D) is returned as a homomorphism of finitely presented
groups. <br>
        </li>
      </ul>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">HomToIntegers(X)<br>
      <br>
      </span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
either a ZG-resolution X =R, or an equivariant chain map X = (F:R&#8594;S).
It returns
the cochain complex or cochain map obtained by applying Hom<sub>ZG</sub>(
_ , Z) where Z is the trivial
module of integers (characteristic 0).<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">HomToIntegralModule(R,f)</td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution R and a group homomorphism f:G &#8594; GL<sub>n</sub>(Z)&nbsp;
to the group of n&times;n invertible integer matrices. Here Z must have
characteristic
0. It returns the cochain complex obtained by applying Hom<sub>ZG</sub>(
_ , A) where A is the ZG-module Z<sup>n</sup> with G action via f. <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">IntegralRingGenerators(R,n)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
at least n+1 terms of a ZG-resolution and integer n&gt;0. It returns a
minimal list of cohomology classes in H<sup>n</sup>(G,Z) which,
together with all cup products of lower degree classes, generate the
group H<sup>n</sup>(G,Z)
.<br>
      <br>
      <span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;"><span style="color: rgb(0, 0, 102);">(</span></span></span>Let
a<sub>i</sub> be the i-th canonical generator of the d-generator
abelian group H<sup>n</sup>(G,Z). The cohomology class n<sub>1</sub>a<sub>1</sub>
+ ... +n<sub>d</sub>a<sub>d </sub>is represented by the integer vector
u=(n<sub>1</sub>, ..., n<sub>d</sub>). )<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);"><span
 style="font-family: helvetica,arial,sans-serif;">IntegralCup<br>
Product(R,u,v,p,q)<br>
      <br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">IntegralCup<br>
Product(R,u,v,p,q,P,Q,N)<br>
      <br>
      <br>
      <br>
      <br style="color: rgb(0, 0, 102);">
      </span><span style="font-family: helvetica,arial,sans-serif;"><small><span
 style="color: rgb(0, 0, 102); font-family: serif;">Various functions
used to construct the cup product <br>
are <a href="CR_functions.html">also available</a>.</span></small><br>
      </span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution R, a vector u representing an element in H<sup>p</sup>(G,Z),
a vector v representing an element in H<sup>q</sup>(G,Z) and the two
integers p,q &gt; 0. It returns a vector w representing the cup product
u&middot;v in H<sup>p+q</sup>(G,Z). This product is associative and
u&middot;v = (-1)<sup>pq</sup>v&middot;u .&nbsp; It provides H<sup>*</sup>(G,Z)
with the structure of an anti-commutative graded ring. The cup product
is currently implemented for characteristic 0 only.<br>
      <br>
The resolution R needs a
contracting homotopy.<br>
      <br>
To save the function from having to calculate the abelian groupsH<sup>n</sup>(G,Z)
additional input variables can be used in the form <span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">IntegralCupProduct(R,u,v,p,q,P,Q,N)
      <span style="color: rgb(0, 0, 102); font-family: serif;">, where <br>
      </span></span>
      <ul>
        <li><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 102); font-family: serif;">P is the output of
the command <span style="font-family: helvetica,arial,sans-serif;">CR_CocyclesAndCoboundaries(R,p,true)</span></span></span></li>
        <li><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 102); font-family: serif;">Q </span></span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 102); font-family: serif;">is the output of
the command <span style="font-family: helvetica,arial,sans-serif;">CR_CocyclesAndCoboundaries(R,q,true)</span></span></span></li>
        <li><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 102); font-family: serif;">N </span></span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 102); font-family: serif;">is the output of
the command <span style="font-family: helvetica,arial,sans-serif;">CR_CocyclesAndCoboundaries(R,p+q,true)<span
 style="font-family: serif;"> .</span></span></span></span></li>
      </ul>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">IsAspherical(F,R)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a free group F and a set R of words in F. It performs a test on the
2-dimensional
CW-space
K associated to this presentation for the group G=F/&lt;R&gt;<sup>F</sup>.&nbsp;
      <br>
      <br>
The function returns "true" if K <span style="font-style: italic;"></span>has
trivial
second homotopy group. In this case it prints:<span
 style="font-style: italic;"> Presentation is aspherical</span>. <br>
      <br>
Otherwise it returns "fail" and prints: <span
 style="font-style: italic;">Presentation is NOT piece-wise Euclidean
non-positively curved</span>. (In this case K may or may not have
trivial second homotopy group. But it is NOT possible to impose a
metric on K which restricts to a Euclidean metric on each 2-cell.)<br>
      <br>
The function uses Polymake software. <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">IsSuperperfect(G)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a group G and returns "true" if&nbsp; both the first and second
integral homology of G is trivial. Otherwise, it returns "false". <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">MultiplyWord(n,w)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a word w and integer n. It returns the scalar multiple n&middot;w .<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 0);">Negate([i,j])</span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a pair [i,j] of integers and returns [-i,j].<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: helvetica,arial,sans-serif; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="color: rgb(0, 0, 0);">NegateWord(w)</span><big><br>
      </big></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a word w in a free
ZG-module and returns the negated word -w.<big><br>
      </big></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">NonabelianExterior<br>
Product(G,N)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a finite group G and normal subgroup N. It returns a record E with the
following components.<br>
      <ul>
        <li><span style="font-family: helvetica,arial,sans-serif;">E.homomorphism</span>
is a group homomorphism &micro; :
G^N &#8594; G from the nonabelian exterior product G^N to G. The
kernel of &micro; is the relative Schur multiplier. <br>
        </li>
        <li><span style="font-family: helvetica,arial,sans-serif;">E.pairing(x,y)
          </span>is a function which inputs an element x in G
and an element y in N and returns&nbsp; x ^ y in the exterior product
G^N
.</li>
      </ul>
      <br>
This function should work for
reasonably small nilpotent groups or extremely small non-nilpotent
groups.</td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: helvetica,arial,sans-serif; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="color: rgb(0, 0, 0);">NonabelianTensor<br>
Square(G)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a finite group G and returns a record T with the following components.<br>
      <ul>
        <li><span style="font-family: helvetica,arial,sans-serif;">T.homomorphism</span>
is a group homomorphism &micro; :
G(&times;)G &#8594; G from the nonabelian tensor square of G to G. The
kernel of &micro; is
isomorphic to the third homotopy group of the suspension SK(G,1)
of&nbsp; an Eilenberg-Mac Lane space. <br>
        </li>
        <li><span style="font-family: helvetica,arial,sans-serif;">T.pairing(x,y)
          </span>is a function which inputs two elements x, y
in G
and returns the tensor x (&times;) y in the tensor square G (&times;) G
. <br>
        </li>
      </ul>
This function should work for
reasonably small nilpotent groups or extremely small non-nilpotent
groups.<br>
      <span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 102);"></span></span> </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">PermToMatrixGroup(G,n)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a permutation group G and its degree n. Returns a bijective
homomorphism f:G &#8594; M where M is a group of permutation matrices.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">PolytopalComplex(G,v)<br>
      <br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">PolytopalComplex(G,v,n)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a permutation group or matrix group G of degree n and a rational vector
v of length n. In both cases there is a natural action of G on v. Let
P(G,v) be the convex polytope arising as the convex hull of
the Euclidean points in the orbit of v under the action of G. The
cellular chain complex C<sub>*</sub>=C<sub>*</sub>(P(G,v)) is an exact
sequence of (not necessarily free) ZG-modules. The
function returns a record R with components:<br>
      <ul style="font-family: helvetica,arial,sans-serif;">
        <li>R.dimension(k)<span style="font-family: serif;"> is a
function which returns the number of G-orbits of the k-dimensional
faces in&nbsp; P(G,v).&nbsp; If each k-face has trivial stabilizer
subgroup in G then C<sub>k</sub> is a free ZG-module of rank
R.dimension(k).</span></li>
        <li><span style="font-family: helvetica,arial,sans-serif;">R.stabilizer(k,n)<span
 style="font-family: serif;"> is a function which returns the
stabilizer subgroup for a face in the n-th orbit of k-faces.</span></span></li>
        <li><span style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;">If all faces of dimension &lt;k+1 have
trivial stabilizer group then the first k terms of C<sub>*</sub>
constitute part of a free&nbsp; ZG-resolution. The boundary map is
described by the function <span
 style="font-family: helvetica,arial,sans-serif;">boundary(k,n)</span>
. (If some faces have non-trivial stabilizer group then C<sub>*</sub>
is not free and no attempt is made to determine signs for the boundary
map.)<br>
          </span></span></li>
        <li><span style="font-family: helvetica,arial,sans-serif;"><span
 style="font-family: serif;"><span
 style="font-family: helvetica,arial,sans-serif;">R.elements, R.group,
R.properties <span style="font-family: serif;">are as in a
ZG-resolution.</span></span></span></span></li>
      </ul>
If an optional third input variable n is used, then only the first n
terms of the resolution C<sub>*</sub> will be computed.<br>
      <br>
The function uses Polymake software. <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">PolytopalGenerators(G,v)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a permutation group or matrix group G of degree n and a rational vector
v of length n. In both cases there is a natural action of G on v, and
the vector v must be chosen so that it has trivial stabilizer subgroup
in G. Let P(G,v) be the convex polytope arising as the convex hull of
the Euclidean points in the orbit of v under the action of G. The
function returns a record P with components:<br>
      <ul>
        <li>P.generators is a list of all those elements g in G such
that
g&middot;v has an edge in common with v. The list is a generating set
for G.<br>
        </li>
        <li>P.vector is the vector v.</li>
        <li>P.hasseDiagram is the Hasse diagram of the cone at v.</li>
      </ul>
The function uses Polymake software. <br>
      <span style="font-weight: bold;">The function is joint work with
Seamus Kelly.</span><br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: helvetica,arial,sans-serif; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">PresentationOfResolution(R)</td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
at least two terms
of a reduced ZG-resolution R and returns a record P with components<br>
      <ul>
        <li><span style="font-family: helvetica,arial,sans-serif;">P.freeGroup</span>
is a free group F<br>
        </li>
        <li><span style="font-family: helvetica,arial,sans-serif;">P.relators</span>
is a list S of words in F</li>
      </ul>
where G is isomorphic to F modulo the normal
closure of S. This presentation for G corresponds to
the 2-skeleton of the classifying CW-space from which R was
constructed. The resolution R
requires no contracting homotopy.</td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: helvetica,arial,sans-serif; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="color: rgb(0, 0, 0);">PrimePartDerived</span><br
 style="color: rgb(0, 0, 0);">
      <span style="color: rgb(0, 0, 0);">Functor(G,R,F,n)</span><big><br>
      </big></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a finite group G, a positive integer n, at least n+1 terms of a
ZP-resolution for a Sylow subgroup P&lt;G and a "mathematically
suitable" covariant additive functor F such as <span
 style="font-family: helvetica,arial,sans-serif;">TensorWithIntegers <span
 style="font-family: serif;"></span></span>. It returns the abelian
invariants of the
p-component of the&nbsp; homology H<sub>n</sub>(F(R)) . <br>
      <br>
Warning: All calculations are assumed to be in characteristic 0. The
function should not be used if the coefficient module is over the field
of p elements.<br>
      <br>
"Mathematically suitable" means that the Cartan-Eilenberg double coset
formula must hold.<br>
      <big> </big></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">PrintZGword(w,elts)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a word w in a free ZG-module and a (possibly partial but sufficient)
listing elts of the
elements of G. The function prints the word w to the screen in the form<br>
      <div style="text-align: center;">r<sub>1</sub>E<sub>1</sub> + ...
+ r<sub>n</sub>E<sub>n</sub><br>
      </div>
where r<sub>i</sub> are elements in the group ring ZG, and E<sub>i</sub>
denotes the i-th free generator of the module. <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">RelativeSchurMultiplierG,N)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a finite group G and normal subgroup N. It returns the homology group H<sub>2</sub>(G,N,Z)
that fits into the exact sequence <br>
&middot;&middot;&middot; &#8594; H<sub>3</sub>(G,Z) &#8594; H<sub>3</sub>(G/N,Z) &#8594; H<sub>2</sub>(G,N,Z)
&#8594; H<sub>3</sub>(G,Z) &#8594; H<sub>3</sub>(G/N,Z) &#8594; &middot;&middot;&middot;.<br>
      <br>
This function should work for reasonably small
nilpotent groups G or extremely small non-nilpotent groups.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionAbelianGroup(L,n)<br>
      <br>
      </span><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);"></span><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionAbelianGroup(G,n)</span>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a list L:=[m<sub>1</sub>,m<sub>2</sub>, ..., m<sub>d</sub>] of
nonnegative integers, and a positive integer n. It returns n terms of a
ZG-resolution for the abelian group G=Z<sub>L[1]</sub>+Z<sub>L[2]</sub>+&middot;&middot;&middot;+Z<sub>L[d]</sub>
.<br>
      <br>
If G is finite then the first argument can also be the abelian group G
itself.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionAlmostCrystalGroup(G,n)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a positive integer n and an almost
crystallographic pcp group G.
It
returns n terms of a free ZG-resolution. (A group is <span
 style="font-style: italic;">almost crystallographic</span> if it
nilpotent-by-finite and has no non-trivial finite normal subgroup. Such
groups can be constructed using the ACLIB package.) <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionAlmostCrystal<br>
Quotient(G,n,c)</span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">An
almost crystallographic group G is an extension of a finite group P by
a nilpotent group T, and has no non-trivial finite normal subgroup. We
define the <span style="font-style: italic;">relative lower central
series</span> by setting T<sub>1</sub>=T and T<sub>i+1</sub>=[T<sub>i</sub>,G].
      <br>
      <br>
This function inputs an almost crystallographic group G together with
positive integers n and c. It returns n terms of a free ZQ-resolution
R for the group Q=G/T<sub>c</sub> .<br>
      <br>
In addition to the usual components, the resolution R has the component
      <span style="font-family: helvetica,arial,sans-serif;">R.quotientHomomorphism</span>
which gives the quotient homomorphism G&#8594;Q.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionArtinGroup(D,n)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a Coxeter diagram D and an integer&nbsp; n&gt;1.&nbsp; It returns n
terms of a free ZG-resolution R where G is the Artin monoid associated
to D.&nbsp; It is conjectured that R is also a free resolution for the
Artin group G. The conjecture is known to hold in <a
 href="About/aboutArtinGroups.html">certain cases</a>.<br>
      <br>
G=R.group is infinite and returned as a finitely presented group. The
list
R.elts is a partial listing of the elements of G which grows as R is
used. Initially R.elts is empty and
then, any time the boundary of a
resolution generator is called, R.elts is updated to include elements
of G involved in the boundary. <br>
      <br>
      <span style="color: rgb(255, 0, 0);">The contracting homotopy on
R has not yet been implemented!</span><br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionAspherical<br>
Presentation(F,R,n)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a free group F, a set R of words in F which constitute an <span
 style="font-weight: bold;">aspherical</span> presentation for a group
G, and a positive integer n.&nbsp; (Asphericity can be a difficult
property to verify. The
function IsAspherical(F,R) could be of help.)<br>
      <br>
The function returns n terms of a free ZG-resolution R which has
generators in dimensions &lt;3 only. No contracting homotopy on R will
be returned.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionDirectProduct(R,S)<br>
      <br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionDirect<br>
Product(R,S,"internal")<br>
      </span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution R and ZH-resolution S. It outputs a ZD-resolution for
the direct product D=G&times;H. <br>
      <br>
If G and H lie in a common group K, and if they commute and have
trivial intersection, then an optional third variable "internal" can be
used. This will force D to be the subgroup GH in K.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionExtension(g,R,S)<br>
      <br>
      </span><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionExtension<br>
(g,R,S,"TestFiniteness")<br>
      <br>
      </span><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionExtension<br>
(g,R,S,"NoTest",GmapE)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a surjective group homomorphism g:E&#8594;G with kernel N. It also inputs a
ZN-resolution R and a ZG-resolution S. It returns
a ZE-resolution. The groups E and G can be infinite.<br>
      <br>
If an optional fourth argument is set equal to "TestFiniteness" then
the
groups N and G will be tested to see if they are finite. If they are
finite then some speed saving routines will be invoked.<br>
      <br>
If the homomorphism g is such that the GAP function <span
 style="font-family: helvetica,arial,sans-serif;">PreImagesElement(g,x)</span>
doesn't work, then a function <span
 style="font-family: helvetica,arial,sans-serif;">GmapE()</span> should
be included as a fifth input. For any x in G this function should
return an element GmapE(x) in E&nbsp; which gets mapped onto x by g. <span
 style="font-weight: bold;"></span><br>
      <br>
      <span style="color: rgb(255, 0, 0);">The contracting homotopy on
the
ZE-resolution has not yet been fully implemented for infinite groups!</span><span
 style="font-family: helvetica,arial,sans-serif;"></span><br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionFiniteDirectProduct(R,S)<br>
      <br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionFiniteDirect<br>
Product(R,S,"internal")<br>
      </span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution R and ZH-resolution S where G and H are finite groups.
It outputs a ZD-resolution for
the direct product D=G&times;H. <br>
      <br>
If G and H lie in a common group K, and if they commute and have
trivial intersection, then an optional third variable "internal" can be
used. This will force D to be the subgroup GH in K.</td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: helvetica,arial,sans-serif; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="color: rgb(0, 0, 0);">ResolutionFiniteExtension</span><br
 style="color: rgb(0, 0, 0);">
      <span style="color: rgb(0, 0, 0);">(gensE,gensG,R,n)</span><br>
      <br>
      <span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionFiniteExtension<br>
(gensE,gensG,R,n,true)<br>
      <br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionFiniteExtension<br>
(gensE,gensG,R,n,false,S)</span><span style="color: rgb(255, 0, 0);"></span><span
 style="font-family: helvetica,arial,sans-serif;"> <br>
      </span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 102);">Inputs: a set gensE of generators for a
finite group E; a set gensG equal to the image of gensE in a quotient
group G
of E; a ZG-resolution R up to dimension at least n; a
positive&nbsp; integer n. It uses the TwistedTensorProduct()
construction to return n terms of a ZE-resolution. </span><br>
      <br>
The
function has an optional fourth
argument which, when set equal to true, <span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"></span><span
 style="font-family: helvetica,arial,sans-serif;"></span><span
 style="color: rgb(51, 0, 51);"><span style="color: rgb(0, 0, 102);">
invokes tietze reductions in the
construction of a resolution for the kernel of E--&gt;G.<br>
      <br>
If a ZN-resolution S is available, where N is the kernel of the
quotient E&#8594;G, then this can be incorporated into the computations using
an optional fifth argument. </span></span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"></span><span
 style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 0, 102);"></span></span><span
 style="color: rgb(0, 0, 102);"><small><span
 style="color: rgb(255, 0, 0);"></span></small><br>
      </span></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: helvetica,arial,sans-serif; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="color: rgb(0, 0, 0);">ResolutionFinite</span><br
 style="color: rgb(0, 0, 0);">
      <span style="color: rgb(0, 0, 0);">Group(gens,n)<br>
      <br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionFinite<br>
Group(gens,n,true)<br>
      <br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionFinite<br>
Group(gens,n,false,p)</span><span
 style="font-family: helvetica,arial,sans-serif;"></span><br>
      </td>
      <td
 style="vertical-align: top; color: rgb(0, 0, 102); background-color: rgb(255, 255, 255);">Inputs
a set gens of
generators for a finite group G and a positive integer n. It outputs n
terms of a ZG-resolution. <br>
      <br>
The function has an optional third
argument which, when set equal to&nbsp; true, invokes<span
 style="font-family: helvetica,arial,sans-serif;"></span><span
 style="color: rgb(51, 0, 51);"><span style="color: rgb(0, 0, 102);">
tietze reductions in the
construction of the resolution. <br>
      <br>
      </span></span>The function has an optional fourth
argument which, when set equal to a prime p, records the fact that the
resolution will only be used for mod p calculations. This could speed
up subsequent constructions.<span style="color: rgb(255, 0, 0);"></span><span
 style="color: rgb(51, 0, 51);"><span style="color: rgb(0, 0, 102);"> </span></span><br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); font-family: helvetica,arial,sans-serif;"><span
 style="color: rgb(0, 0, 0);">ResolutionFinite</span><br
 style="color: rgb(0, 0, 0);">
      <span style="color: rgb(0, 0, 0);">Subgroup(R,K)<br>
      <br>
      </span><span style="color: rgb(0, 0, 0);">ResolutionFinite</span><br
 style="color: rgb(0, 0, 0);">
      <span style="color: rgb(0, 0, 0);">Subgroup(R,gensG,gensK)</span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution for a finite group G and a subgroup K of index |G:K|.
It returns a free ZK-resolution whose
ZK-rank is |G:K| times the ZG-rank in each dimension. <br>
      <br>
Generating sets gensG, gensK for G and K can also be input to the
function (though the method does not depend on a choice of generators).<br>
      <span style="color: rgb(255, 0, 0);"><br>
      <span style="color: rgb(0, 0, 102);">This ZK-resolution has more
than one
generator in dimension 0. So PresentationOfResolution() should not be
applied to it!</span></span><big><span style="color: rgb(0, 0, 102);"> </span></big></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionNilpotentGroup(G,n)<br>
      <br>
      </span><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionNilpotentGroup<br>
(G,n,"TestFiniteness")</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a nilpotent group G and positive integer n. It returns n terms of a
free ZG-resolution. The resolution is computed using a
divide-and-conquer technique involving the lower central series. <br>
      <br>
This function can be applied to infinite groups G. For finite groups
the function ResolutionNormalSeries() probably gives better results.<br>
      <br>
If an optional third argument is set equal to "TestFiniteness" then the
groups N and G will be tested to see if they are finite. If they are
finite then some speed saving routines will be invoked.<span
 style="font-weight: bold;"></span><br>
      <br>
      <span style="color: rgb(255, 0, 0);">The contracting homotopy on
the
ZE-resolution has not yet been fully implemented for infinite groups.</span><br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionNormalSeries(L,n)<br>
      <br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionNormalSeries<br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">(L,n,</span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">true)<br>
      <br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">ResolutionNormalSeries<br>
      </span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">(L,n,</span><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">false,p)</span><br>
      <span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;"><br>
      </span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a positive integer
n and a list L = [L<sub>1</sub> , ..., L<sub>k</sub>] of normal
subgroups L<sub>i </sub>of
a finite group G satisfying G = L<sub>1</sub>&gt;L<sub>2</sub> ... &gt;L<sub>k</sub>.
Alternatively, L = [gensL<sub>1</sub>, ... gensL<sub>k</sub>] can be a
list of generating sets for the L<sub>i</sub> (and these&nbsp;
particular generators will be used in the construction of resolutions).
It returns a Z(G/L<sub>k</sub>)-resolution by repeatedly using the
function
ResolutionFiniteExtension(). Typically L<sub>k</sub>=1 in which case
a ZG-resolution is returned.<br>
      <br>
The function has an optional third
argument which, if set equal to true, invokes tietze reductions in the
construction of resolutions. <br>
      <br>
The function has an optional fourth argument which, if set equal to
p&gt;0, produces a resolution which is only valid for mod p
calculations.<span style="color: rgb(255, 0, 0);"><br>
      </span></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionPrimePower<br>
Group(G,n)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a p-group G and integer n&gt;0. It uses GAP's standard linear algebra
functions over the field Z<sub>p</sub>
to construct a ZG-resolution for mod p calculations only. The
resolution is minimal - meaning that the number of generators
of R<sub>n</sub> equals the rank of H<sub>n</sub>(G,Z<sub>p</sub>). (I
suspect this function could be implemented far more efficiently.)<br>
      <br>
      <span style="color: rgb(255, 0, 0);">The contracting homotopy on
the
ZG-resolution has not yet been implemented!</span><br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionSmall</span><br
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">
      <span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">FpGroup(G,n)<br>
      <br>
      </span><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionSmall</span><br
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">
      <span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">FpGroup(G,n,p)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a small finitely presented group G and an integer n&gt;0. It returns n
terms of a ZG-resolution which, in dimensions 1 and 2, corresponds to
the given presentation for G. The method returns no contracting
homotopy for the resolution.<br>
      <br>
The function has an optional fourth
argument which, when set equal to a prime p, records the fact that the
resolution will only be used for mod p calculations. This could speed
up subsequent constructions.<br>
      <br>
      <span style="font-weight: bold;">This function was written by
Irina Kholodna.</span></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">Resolution<br>
Subgroup(R,K)</td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution for an (infinite) group G and a subgroup K of finite
index |G:K|.
It returns a free ZK-resolution whose
ZK-rank is |G:K| times the ZG-rank in each dimension.<br>
      <br>
If G is finite then the function <span
 style="color: rgb(0, 0, 102); font-family: helvetica,arial,sans-serif;">ResolutionFinite</span><span
 style="color: rgb(0, 0, 102); font-family: helvetica,arial,sans-serif;">Subgroup(R,G,K)
      <span style="font-family: serif;">will probably work better. In
particular, resolutions from this function probably won't work with the
function <span style="font-family: helvetica,arial,sans-serif;">EquivariantChainMap()</span>.</span></span><br>
      <span style="color: rgb(255, 0, 0);"><br>
      <span style="color: rgb(0, 0, 102);">This ZK-resolution has more
than one
generator in dimension 0. So PresentationOfResolution() should not be
applied to it!</span></span><big><span style="color: rgb(0, 0, 102);"> </span></big></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ResolutionSubnormalSeries(L,n)</span></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a positive integer
n and a list L = [L<sub>1</sub> , ..., L<sub>k</sub>] of&nbsp;
subgroups L<sub>i </sub>of
a finite group G=L<sub>1</sub> such that L<sub>1</sub>&gt;L<sub>2</sub>
... &gt;L<sub>k </sub>is a subnormal series in G (meaning that each L<sub>i+1</sub>
must be normal in L<sub>i</sub>). It returns a Z(G/L<sub>k</sub>)-resolution
by repeatedly using the
function <span style="font-family: helvetica,arial,sans-serif;">ResolutionFiniteExtension()</span>.
Typically L<sub>k</sub>=1 in which case
a ZG-resolution is returned.<br>
      <br>
If L is a series of normal subgroups in G then the function <span
 style="font-family: helvetica,arial,sans-serif;">ResolutionNormalSeries(L,n)</span>
will possibly work more efficiently.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">StandardCocycle(R,f,n)</span><br
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">
      <br
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">
      <span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">StandardCocycle(R,f,n,q)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution R (with contracting homotopy), a positive integer n and
an integer vector f representing an n-cocycle R<sub>n</sub> &#8594; Z<sub>q </sub>where
G acts trivially on Z<sub>q</sub>. It is assumed q=0 unless a value for
q is entered. The command returns a function F(g<sub>1</sub>, ...,
g<sub>n</sub>) which is the standard cocycle&nbsp; G<sup>n</sup> &#8594; Z<sub>q</sub>
corresponding to f. At present the command is implemented only for n=2
or 3.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">Syzygy(R,g)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution R (with contracting homotopy) and a list g = [g[1],
..., g[n]] of elements in G. It returns a word w in R<sub>n</sub>. The
word
w is the image of the n-simplex in the standard bar
resolution corresponding
to the n-tuple g. This function can be used to construct explicit
standard n-cocycles. (Currently implemented only for n&lt;4.)<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">TensorWithIntegers(X)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
either a ZG-resolution X =R, or an equivariant chain map X = (F:R&#8594;S).
It returns
the chain complex or chain map obtained by tensoring with the trivial
module of integers (characteristic 0).<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">TensorWith<br>
IntegersModP(X,p)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
either a ZG-resolution X =R, or an equivariant chain map X = (F:R&#8594;S),
and a prime p.
It returns
the chain complex or chain map obtained by tensoring with the trivial
module of integers modulo p.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">TensorWithRationals(R)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution R and returns
the chain complex obtained by tensoring with the trivial
module of rational numbers. <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">TestHap()</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">This
runs a representative sample of HAP functions and checks to see that
they produce the correct output.&nbsp; <br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">ThirdHomotopyGroup<br>
OfSuspensionB(G)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a finite group G and returns the abelian invariants of the third
homotopy group of the suspension SB(G) of the Eilenberg-Mac Lane
space&nbsp; K(G,1). This function should work for reasonably small
nilpotent groups or extremely small non-nilpotent groups.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: helvetica,arial,sans-serif; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="color: rgb(0, 0, 0);">TietzeReduction(S,w)</span><big><br>
      </big></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a set S of words
in a free ZG-module, and a word w in the module. The
function returns a word w' such that {S,w'} generates the same
abelian group as {S,w}. The word w' is possibly shorter (and
certainly no longer) than w. This function needs to be improved!<big><br>
      </big></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="font-family: helvetica,arial,sans-serif; color: rgb(0, 0, 0);">TorsionGeneratorsAbelianGroup(G)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
an abelian group G and returns a generating set [x<sub>1</sub>, ...,x<sub>n</sub>]
where no pair of generators have coprime orders.<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: helvetica,arial,sans-serif; background-color: rgb(255, 255, 255); color: rgb(255, 204, 0);"><span
 style="color: rgb(0, 0, 0);">TwistedTensorProduct(R,S,</span><br
 style="color: rgb(0, 0, 0);">
      <span style="color: rgb(0, 0, 0);">EhomG,GmapE,NhomE,</span><br
 style="color: rgb(0, 0, 0);">
      <span style="color: rgb(0, 0, 0);">NEhomN,EltsE,Mult,InvE)</span><big><br>
      </big></td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a ZG-resolution R,
a ZN-resolution S, and other data
relating to a short exact sequence 1&#8594;N&#8594;E&#8594;G&#8594;1. It
uses a perturbation technique of CTC Wall to construct a ZE-resolution
F. Both G and N could be infinite. The "length" of F is equal to the
minimum of the "length"s of R and S. The resolution R needs no
contracting homotopy if no such homotopy is requied for F. <span
 style="color: rgb(255, 0, 0);"></span><big><br>
      </big></td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);"><span
 style="color: rgb(0, 0, 0); font-family: helvetica,arial,sans-serif;">VectorStabilizer(G,v)</span><br>
      </td>
      <td
 style="vertical-align: top; background-color: rgb(255, 255, 255);">Inputs
a permutation group or matrix group G of degree n and a rational vector
of degree n. In both cases there is a natural action of G on v and the
function returns the group of elements in G that fix v. <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
