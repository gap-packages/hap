<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (HAP) - Chapter 16:  FpG-modules</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body><a href="../www/index.html"><small>HAP home</small></a>



<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap15.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap17.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X81A2A3C97C09685E" name="X81A2A3C97C09685E"></a></p>
<div class="ChapSects"><a href="chap16.html#X81A2A3C97C09685E">16 <span class="Heading"> FpG-modules</span></a>
</div>

<h3>16 <span class="Heading"> FpG-modules</span></h3>

<div class="pcenter"><table cellspacing="10"  class="GAPDocTable">
<tr>
<td class="tdleft"><code class="code">CompositionSeriesOfFpGModules(M) </code></p>

<p>Inputs an FpG-module M and returns a list of FpG-modules that constitute a composition series for M.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">DirectSumOfFpGModules(M,N) </code> <code class="code">DirectSumOfFpGModules([ M[1], M[2], ..., M[k] ])) </code></p>

<p>Inputs two FpG-modules M and N with common group and characteristic. It returns the direct sum of M and N as an FpG-Module.</p>

<p>Alternatively, the function can input a list of FpG-modules with common group G. It returns the direct sum of the list.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">FpGModule(A,P) </code> <code class="code">FpGModule(A,G,p) </code></p>

<p>Inputs a p-group P and a matrix A whose rows have length a multiple of the order of G. It returns the "canonical" FpG-module generated by the rows of A.</p>

<p>A small non-prime-power group G can also be input, provided the characteristic p is entered as a third input variable.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">FpGModuleDualBasis(M) </code></p>

<p>Inputs an FpG-module M. It returns a record R with two components:</p>


<ul>
<li><p>R.freeModule is the free module FG of rank one.</p>

</li>
<li><p>R.basis is a list representing an F-basis for the module Hom_FG(M,FG). Each term in the list is a matrix A whose rows are vectors in FG such that M!.generators[i] --&gt; A[i] extends to a module homomorphism M --&gt; FG.</p>

</li>
</ul>
</td>
</tr>
<tr>
<td class="tdleft"><code class="code">FpGModuleHomomorphism(M,N,A) </code> <code class="code">FpGModuleHomomorphismNC(M,N,A) </code></p>

<p>Inputs FpG-modules M and N over a common p-group G. Also inputs a list A of vectors in the vector space spanned by N!.matrix. It tests that the function</p>

<p>M!.generators[i] --&gt; A[i]</p>

<p>extends to a homomorphism of FpG-modules and, if the test is passed, returns the corresponding FpG-module homomorphism. If the test is failed it returns fail.</p>

<p>The "NC" version of the function assumes that the input defines a homomorphism and simply returns the FpG-module homomorphism.</td>
</tr>
<tr>
<td class="tdleft"><code class="code"> DesuspensionFpGModule(M,n)</code> <code class="code">DesuspensionFpGModule(R,n) </code></p>

<p>Inputs a positive integer n and and FpG-module M. It returns an FpG-module D^nM which is mathematically related to M via an exact sequence 0 --&gt; D^nM --&gt; R_n --&gt; ... --&gt; R_0 --&gt; M --&gt; 0 where R_* is a free resolution. (If G=Group(M) is of prime-power order then the resolution is minimal.)</p>

<p>Alternatively, the function can input a positive integer n and at least n terms of a free resolution R of M.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">RadicalOfFpGModule(M) </code></p>

<p>Inputs an FpG-module M with G a p-group, and returns the Radical of M as an FpG-module. (Ig G is not a p-group then a submodule of the radical is returned.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">RadicalSeriesOfFpGModule(M) </code></p>

<p>Inputs an FpG-module M and returns a list of FpG-modules that constitute the radical series for M.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">GeneratorsOfFpGModule(M) </code></p>

<p>Inputs an FpG-module M and returns a matrix whose rows correspond to a minimal generating set for M.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ImageOfFpGModuleHomomorphism(f) </code></p>

<p>Inputs an FpG-module homomorphism f:M --&gt; N and returns its image f(M) as an FpG-module.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">GroupAlgebraAsFpGModule(G) </code></p>

<p>Inputs a p-group G and returns its mod p group algebra as an FpG-module.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">IntersectionOfFpGModules(M,N) </code></p>

<p>Inputs two FpG-modules M, N arising as submodules in a common free module (FG)^n where G is a finite group and F the field of p-elements. It returns the FpG-module arising as the intersection of M and N.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">IsFpGModuleHomomorphismData(M,N,A) </code></p>

<p>Inputs FpG-modules M and N over a common p-group G. Also inputs a list A of vectors in the vector space spanned by N!.matrix. It returns true if the function</p>

<p>M!.generators[i] --&gt; A[i]</p>

<p>extends to a homomorphism of FpG-modules. Otherwise it returns false.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">MaximalSubmoduleOfFpGModule(M) </code></p>

<p>Inputs an FpG-module M and returns one maximal FpG-submodule of M.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">MaximalSubmodulesOfFpGModule(M) </code></p>

<p>Inputs an FpG-module M and returns the list of maximal FpG-submodules of M.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">MultipleOfFpGModule(w,M) </code></p>

<p>Inputs an FpG-module M and a list w:=[g_1 , ..., g_t] of elements in the group G=M!.group. The list w can be thought of as representing the element w=g_1 + ... + g_t in the group algebra FG, and the function returns a semi-echelon matrix B which is a basis for the vector subspace wM .</td>
</tr>
<tr>
<td class="tdleft"><code class="code">ProjectedFpGModule(M,k) </code></p>

<p>Inputs an FpG-module M of ambient dimension n|G|, and an integer k between 1 and n. The module M is a submodule of the free module (FG)^n . Let M_k denote the intersection of M with the last k summands of (FG)^n . The function returns the image of the projection of M_k onto the k-th summand of (FG)^n . This image is returned an FpG-module with ambient dimension |G|.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">RandomHomomorphismOfFpGModules(M,N) </code></p>

<p>Inputs two FpG-modules M and N over a common group G. It returns a random matrix A whose rows are vectors in N such that the function</p>

<p>M!.generators[i] --&gt; A[i]</p>

<p>extends to a homomorphism M --&gt; N of FpG-modules. (There is a problem with this function at present.)</td>
</tr>
<tr>
<td class="tdleft"><code class="code">Rank(f) </code></p>

<p>Inputs an FpG-module homomorphism f:M --&gt; N and returns the dimension of the image of f as a vector space over the field F of p elements.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">SumOfFpGModules(M,N) </code></p>

<p>Inputs two FpG-modules M, N arising as submodules in a common free module (FG)^n where G is a finite group and F the field of p-elements. It returns the FpG-Module arising as the sum of M and N.</td>
</tr>
<tr>
<td class="tdleft"><code class="code">SumOp(f,g) </code></p>

<p>Inputs two FpG-module homomorphisms f,g:M --&gt; N with common sorce and common target. It returns the sum f+g:M --&gt; N . (This operation is also available using "+".</td>
</tr>
<tr>
<td class="tdleft"><code class="code">VectorsToFpGModuleWords(M,L) </code></p>

<p>Inputs an FpG-module M and a list L=[v_1,... ,v_k] of vectors in M. It returns a list L'= [x_1,...,x_k] . Each x_j=[[W_1,G_1],...,[W_t,G_t]] is a list of integer pairs corresponding to an expression of v_j as a word</p>

<p>v_j = g_1*w_1 + g_2*w_1 + ... + g_t*w_t</p>

<p>where</p>

<p>g_i=Elements(M!.group)[G_i]</p>

<p>w_i=GeneratorsOfFpGModule(M)[W_i] .</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap15.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap17.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
