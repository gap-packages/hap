% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\def\contentsname{Contents\logpage{[ 0, 0, 1 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Cellular complexes}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X81F2008E8232E877}{}
{
 Data $\longrightarrow$ Cellular Complexes \\
 \\
 \\
 \index{HenonOrbit}::::::::::::::::::::::::\\
 
\begin{verbatim}  RegularCWPolytope(L):: List --> RegCWComplex
\end{verbatim}
 
\begin{verbatim}  RegularCWPolytope(G,v):: PermGroup, List --> RegCWComplex
\end{verbatim}


 

 Inputs a list $L$ of vectors in $\mathbb R^n$ and outputs their convex hull as a regular CW-complex. 

 Inputs a permutation group G of degree $d$ and vector $v\in \mathbb R^d$, and outputs the convex hull of the orbit $\{v^g : g\in G\}$ as a regular CW-complex. \\
 \\
 \\
 \\
 \index{CubicalComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  CubicalComplex(A):: List --> CubicalComplex
\end{verbatim}


 

 Inputs a binary array $A$ and returns the cubical complex represented by $A$. The array $A$ must of course be such that it represents a cubical complex. \\
 \\
 \\
 \\
 \index{PureCubicalComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  PureCubicalComplex(A):: List --> PureCubicalComplex
\end{verbatim}


 

 Inputs a binary array $A$ and returns the pure cubical complex represented by $A$. \\
 \\
 \\
 \\
 \index{PureCubicalKnot}::::::::::::::::::::::::\\
 
\begin{verbatim}  PureCubicalKnot(n,k):: Int, Int --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  PureCubicalKnot(L):: List --> PureCubicalComplex
\end{verbatim}


 

 Inputs integers $n, k$ and returns the $k$-th prime knot on $n$ crossings as a pure cubical complex (if this prime knot exists). 

 Inputs a list $L$ describing an arc presentation for a knot or link and returns the knot or link
as a pure cubical complex. \\
 \\
 \\
 \\
 \index{PurePermutahedralKnot}::::::::::::::::::::::::\\
 
\begin{verbatim}  PurePermutahedralKnot(n,k):: Int, Int --> PurePermutahedralComplex
\end{verbatim}
 
\begin{verbatim}  PurePermutahedralKnot(L):: List --> PurePermutahedralComplex
\end{verbatim}
 

 Inputs integers $n, k$ and returns the $k$-th prime knot on $n$ crossings as a pure permutahedral complex (if this prime knot exists). 

 Inputs a list $L$ describing an arc presentation for a knot or link and returns the knot or link
as a pure permutahedral complex. \\
 \\
 \\
 \\
 \index{PurePermutahedralComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  PurePermutahedralComplex(A):: List --> PurePermComplex
\end{verbatim}


 

 Inputs a binary array $A$ and returns the pure permutahedral complex represented by $A$. \\
 \\
 \\
 \\
 \index{CayleyGraphOfGroup}::::::::::::::::::::::::\\
 
\begin{verbatim}  CayleyGraphOfGroup(G,L):: Group, List --> Graph
\end{verbatim}


 

 Inputs a finite group $G$ and a list $L$ of elements in $G$.It returns the Cayley graph of the group generated by $L$. \\
 \\
 \\
 \\
 \index{EquivariantEuclideanSpace}::::::::::::::::::::::::\\
 
\begin{verbatim}  EquivariantEuclideanSpace(G,v):: MatrixGroup, List --> EquivariantRegCWComplex
\end{verbatim}


 

 Inputs a crystallographic group $G$ with left action on $\mathbb R^n$ together with a row vector $v \in \mathbb R^n$. It returns an equivariant regular CW-space corresponding to the
Dirichlet-Voronoi tessellation of $\mathbb R^n$ produced from the orbit of $v$ under the action. \\
 \\
 \\
 \\
 \index{EquivariantOrbitPolytope}::::::::::::::::::::::::\\
 
\begin{verbatim}  EquivariantOrbitPolytope(G,v):: PermGroup, List --> EquivariantRegCWComplex
\end{verbatim}


 

 Inputs a permutation group $G$ of degree $n$ together with a row vector $v \in \mathbb R^n$. It returns, as an equivariant regular CW-space, the convex hull of the orbit
of $v$ under the canonical left action of $G$ on $\mathbb R^n$. \\
 \\
 \\
 \\
 \index{EquivariantTwoComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  EquivariantTwoComplex(G):: Group --> EquivariantRegCWComplex
\end{verbatim}


 

 Inputs a suitable group $G$ and returns, as an equivariant regular CW-space, the $2$-complex associated to some presentation of $G$. \\
 \\
 \\
 \\
 \index{QuillenComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  QuillenComplex(G,p):: Group, Int --> SimplicialComplex
\end{verbatim}


 

 Inputs a finite group $G$ and prime $p$, and returns the simplicial complex arising as the order complex of the poset
of elementary abelian $p$-subgroups of $G$. \\
 \\
 \\
 \\
 \index{RestrictedEquivariantCWComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  RestrictedEquivariantCWComplex(Y,H):: RegCWComplex, Group --> EquivariantRegCWComplex
\end{verbatim}


 

 Inputs a $G$-equivariant regular CW-space Y and a subgroup $H \le G$ for which GAP can find a transversal. It returns the equivariant regular
CW-complex obtained by retricting the action to $H$. \\
 \\
 \\
 \\
 \index{RandomSimplicialGraph}::::::::::::::::::::::::\\
 
\begin{verbatim}  RandomSimplicialGraph(n,p):: Int, Int --> SimplicialComplex
\end{verbatim}


 

 Inputs an integer $ n \ge 1 $ and positive prime $p$, and returns an Erd\texttt{\symbol{92}}"os-R\texttt{\symbol{92}}'enyi random
graph as a $1$-dimensional simplicial complex. The graph has $n$ vertices. Each pair of vertices is, with probability $p$, directly connected by an edge. \\
 \\
 \\
 \\
 \index{RandomSimplicialTwoComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  RandomSimplicialTwoComplex(n,p):: Int, Int --> SimplicialComplex
\end{verbatim}


 

 Inputs an integer $ n \ge 1 $ and positive prime $p$, and returns a Linial-Meshulam random simplicial $2$-complex. The $1$-skeleton of this simplicial complex is the complete graph on $n$ vertices. Each triple of vertices lies, with probability $p$, in a common $2$-simplex of the complex. \\
 \\
 \\
 \\
 \index{ReadCSVfileAsPureCubicalKnot}::::::::::::::::::::::::\\
 
\begin{verbatim}  ReadCSVfileAsPureCubicalKnot(str):: String --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ReadCSVfileAsPureCubicalKnot(str,r):: String, Int --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ReadCSVfileAsPureCubicalKnot(L):: List --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ReadCSVfileAsPureCubicalKnot(L,R):: List,List --> PureCubicalComplex
\end{verbatim}


 

 Reads a CSV file identified by a string str such as "file.pdb" or
"path/file.pdb" and returns a $3$-dimensional pure cubical complex $K$. Each line of the file should contain the coordinates of a point in $\mathbb R^3$ and the complex $K$ should represent a knot determined by the sequence of points, though the
latter is not guaranteed. A useful check in this direction is to test that $K$ has the homotopy type of a circle. 

If the test fails then try the function again with an integer $r \ge 2$ entered as the optional second argument. The integer determines the resolution
with which the knot is constructed. 

 The function can also read in a list $L$ of strings identifying CSV files for several knots. In this case a list $R$ of integer resolutions can also be entered. The lists $L$ and $R$ must be of equal length. \\
 \\
 \\
 \\
 \index{ReadImageAsPureCubicalComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  ReadImageAsPureCubicalComplex(str,t):: String, Int --> PureCubicalComplex
\end{verbatim}


 

 Reads an image file identified by a string str such as "file.bmp", "file.eps",
"file.jpg", "path/file.png" etc., together with an integer $t$ between $0$ and $765$. It returns a $2$-dimensional pure cubical complex corresponding to a black/white version of
the image determined by the threshold $t$. The $2$-cells of the pure cubical complex correspond to pixels with RGB value $R+G+B \le t$. \\
 \\
 \\
 \\
 \index{ReadImageAsFilteredPureCubicalComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  ReadImageAsFilteredPureCubicalComplex(str,n):: String, Int --> FilteredPureCubicalComplex
\end{verbatim}


 

 Reads an image file identified by a string str such as "file.bmp", "file.eps",
"file.jpg", "path/file.png" etc., together with a positive integer $n$. It returns a $2$-dimensional filtered pure cubical complex of filtration length $n$. The $k$th term in the filtration is a pure cubical complex corresponding to a
black/white version of the image determined by the threshold $t_k=k \times 765/n $. The $2$-cells of the $k$th term correspond to pixels with RGB value $R+G+B \le t_k$. \\
 \\
 \\
 \\
 \index{ReadImageAsWeightFunction}::::::::::::::::::::::::\\
 
\begin{verbatim}  ReadImageAsWeightFunction(str,t):: String, Int --> RegCWComplex, Function
\end{verbatim}


 

 Reads an image file identified by a string str such as "file.bmp", "file.eps",
"file.jpg", "path/file.png" etc., together with an integer $t$. It constructs a $2$-dimensional regular CW-complex $Y$ from the image, together with a weight function $w\colon Y\rightarrow \mathbb Z$ corresponding to a filtration on $Y$ of filtration length $t$. The pair $[Y,w]$ is returned. \\
 \\
 \\
 \\
 \index{ReadPDBfileAsPureCubicalComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  ReadPDBfileAsPureCubicalComplex(str):: String --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ReadPDBfileAsPureCubicalComplex(str,r):: String, Int --> PureCubicalComplex
\end{verbatim}


 

 Reads a PDB (Protein Database) file identified by a string str such as
"file.pdb" or "path/file.pdb" and returns a $3$-dimensional pure cubical complex $K$. The complex $K$ should represent a (protein backbone) knot but this is not guaranteed. A
useful check in this direction is to test that $K$ has the homotopy type of a circle. 

If the test fails then try the function again with an integer $r \ge 2$ entered as the optional second argument. The integer determines the resolution
with which the knot is constructed. \\
 \\
 \\
 \\
 \index{ReadPDBfileAsPurePermutahedralComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  ReadPDBfileAsPurepermutahedralComplex(str):: String --> PurePermComplex
\end{verbatim}
 
\begin{verbatim}  ReadPDBfileAsPurePermutahedralComplex(str,r):: String, Int --> PurePermComplex
\end{verbatim}


 

 Reads a PDB (Protein Database) file identified by a string str such as
"file.pdb" or "path/file.pdb" and returns a $3$-dimensional pure permutahedral complex $K$. The complex $K$ should represent a (protein backbone) knot but this is not guaranteed. A
useful check in this direction is to test that $K$ has the homotopy type of a circle. 

If the test fails then try the function again with an integer $r \ge 2$ entered as the optional second argument. The integer determines the resolution
with which the knot is constructed. \\
 \\
 \\
 \\
 \index{RegularCWPolytope}::::::::::::::::::::::::\\
 
\begin{verbatim}  RegularCWPolytope(L):: List --> RegCWComplex
\end{verbatim}
 
\begin{verbatim}  RegularCWPolytope(G,v):: PermGroup, List --> RegCWComplex
\end{verbatim}


 

 Inputs a list $L$ of vectors in $\mathbb R^n$ and outputs their convex hull as a regular CW-complex. 

 Inputs a permutation group G of degree $d$ and vector $v\in \mathbb R^d$, and outputs the convex hull of the orbit $\{v^g : g\in G\}$ as a regular CW-complex. \\
 \\
 \\
 \\
 \index{SimplicialComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  SimplicialComplex(L):: List --> SimplicialComplex
\end{verbatim}


 

Inputs a list $L$ whose entries are lists of vertices representing the maximal simplices of a
simplicial complex, and returns the simplicial complex. Here a "vertex" is a
GAP object such as an integer or a subgroup. The list $L$ can also contain non-maximal simplices. \\
 \\
 \\
 \\
 \index{SymmetricMatrixToFilteredGraph}::::::::::::::::::::::::\\
 
\begin{verbatim}  SymmetricMatrixToFilteredGraph(A,m,s):: Mat, Int, Rat --> FilteredGraph
\end{verbatim}
 
\begin{verbatim}  SymmetricMatrixToFilteredGraph(A,m):: Mat, Int --> FilteredGraph
\end{verbatim}


 

Inputs an $n \times n$ symmetric matrix $A$, a positive integer $m$ and a positive rational $s$. The function returns a filtered graph of filtration length $m$. The $t$-th term of the filtration is a graph with $n$ vertices and an edge between the $i$-th and $j$-th vertices if the $(i,j)$ entry of $A$ is less than or equal to $t \times s/m$. 

 If the optional input $s$ is omitted then it is set equal to the largest entry in the matrix $A$. \\
 \\
 \\
 \\
 \index{SymmetricMatrixToGraph}::::::::::::::::::::::::\\
 
\begin{verbatim}  SymmetricMatrixToGraph(A,t):: Mat, Rat --> Graph
\end{verbatim}


 

 Inputs an $n\times n$ symmetric matrix $A$ over the rationals and a rational number $t \ge 0$, and returns the graph on the vertices $1,2, \ldots, n$ with an edge between distinct vertices $i$ and $j$ precisely when the $(i,j)$ entry of $A$ is $\le t$. \\
 \\
 \\
 Metric Spaces \\
 \\
 \\
 \index{CayleyMetric}::::::::::::::::::::::::\\
 
\begin{verbatim}  CayleyMetric(g,h):: Permutation, Permutation --> Int
\end{verbatim}


 

 Inputs two permutations $g,h$ and optionally the degree $N$ of a symmetric group containing them. It returns the minimum number of
transpositions needed to express $g*h^{-1}$ as a product of transpositions. \\
 \\
 \\
 \\
 \index{EuclideanMetric}::::::::::::::::::::::::\\
 
\begin{verbatim}  EuclideanMetric(g,h):: List, List --> Rat
\end{verbatim}


 

 Inputs two vectors $v,w \in \mathbb R^n$ and returns a rational number approximating the Euclidean distance between
them. \\
 \\
 \\
 \\
 \index{EuclideanSquaredMetric}::::::::::::::::::::::::\\
 
\begin{verbatim}  EuclideanSquaredMetric(g,h):: List, List --> Rat
\end{verbatim}


 

 Inputs two vectors $v,w \in \mathbb R^n$ and returns the square of the Euclidean distance between them. \\
 \\
 \\
 \\
 \index{HammingMetric}::::::::::::::::::::::::\\
 
\begin{verbatim}  HammingMetric(g,h):: Permutation, Permutation --> Int
\end{verbatim}


 

 Inputs two permutations $g,h$ and optionally the degree $N$ of a symmetric group containing them. It returns the minimum number of
integers moved by the permutation $g*h^{-1}$. \\
 \\
 \\
 \\
 \index{KendallMetric}::::::::::::::::::::::::\\
 
\begin{verbatim}  KendallMetric(g,h):: Permutation, Permutation --> Int
\end{verbatim}


 

 Inputs two permutations $g,h$ and optionally the degree $N$ of a symmetric group containing them. It returns the minimum number of
adjacent transpositions needed to express $g*h^{-1}$ as a product of adjacent transpositions. An
\texttt{\symbol{123}}\texttt{\symbol{92}}em adjacent\texttt{\symbol{125}}
transposition is of the form $(i,i+1)$. \\
 \\
 \\
 \\
 \index{ManhattanMetric}::::::::::::::::::::::::\\
 
\begin{verbatim}  ManhattanMetric(g,h):: List, List --> Rat
\end{verbatim}


 

 Inputs two vectors $v,w \in \mathbb R^n$ and returns the Manhattan distance between them. \\
 \\
 \\
 \\
 \index{VectorsToSymmetricMatrix}::::::::::::::::::::::::\\
 
\begin{verbatim}  VectorsToSymmetricMatrix(V):: List --> Matrix
\end{verbatim}
 
\begin{verbatim}  VectorsToSymmetricMatrix(V,d):: List, Function --> Matrix
\end{verbatim}


 

 Inputs a list $V =\{ v_1, \ldots, v_k\} \in \mathbb R^n$ and returns the $k \times k$ symmetric matrix of Euclidean distances $d(v_i, v_j)$. When these distances are irrational they are approximated by a rational
number. 

 As an optional second argument any rational valued function $d(x,y)$ can be entered. \\
 \\
 \\
 Cellular Complexes $\longrightarrow$ Cellular Complexes \\
 \\
 \\
 \index{BoundaryMap}::::::::::::::::::::::::\\
 
\begin{verbatim}  BoundaryMap(K):: RegCWComplex --> RegCWMap
\end{verbatim}


 

 Inputs a pure regular CW-complex $K$ and returns the regular CW-inclusion map $\iota \colon \partial K \hookrightarrow K$ from the boundary $\partial K$ into the complex $K$. \\
 \\
 \\
 \\
 \index{CliqueComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  CliqueComplex(G,n):: Graph, Int --> SimplicialComplex
\end{verbatim}
 
\begin{verbatim}  CliqueComplex(F,n):: FilteredGraph, Int --> FilteredSimplicialComplex
\end{verbatim}
 
\begin{verbatim}  CliqueComplex(K,n):: SimplicialComplex, Int --> SimplicialComplex
\end{verbatim}


 

 Inputs a graph $G$ and integer $n \ge 1$. It returns the $n$-skeleton of a simplicial complex $K$ with one $k$-simplex for each complete subgraph of $G$ on $k+1$ vertices. 

 Inputs a fitered graph $F$ and integer $n \ge 1$. It returns the $n$-skeleton of a filtered simplicial complex $K$ whose $t$-term has one $k$-simplex for each complete subgraph of the $t$-th term of $G$ on $k+1$ vertices. 

 Inputs a simplicial complex of dimension $d=1$ or $d=2$. If $d=1$ then the clique complex of a graph returned. If $d=2$ then the clique complex of a \$2\$-complex is returned. \\
 \\
 \\
 \\
 \index{ConcentricFiltration}::::::::::::::::::::::::\\
 
\begin{verbatim}  ConcentricFiltration(K,n):: PureCubicalComplex, Int --> FilteredPureCubicalComplex
\end{verbatim}


 

 Inputs a pure cubical complex $K$ and integer $n \ge 1$, and returns a filtered pure cubical complex of filtration length $n$. The $t$-th term of the filtration is the intersection of $K$ with the ball of radius $r_t$ centred on the centre of gravity of $K$, where $0=r_1 \le r_2 \le r_3 \le \cdots \le r_n$ are equally spaced rational numbers. The complex $K$ is contained in the ball of radius $r_n$. (At present, this is implemented only for $2$- and $3$-dimensional complexes.) \\
 \\
 \\
 \\
 \index{DirectProduct}::::::::::::::::::::::::\\
 
\begin{verbatim}  DirectProduct(M,N):: RegCWComplex, RegCWComplex --> RegCWComplex
\end{verbatim}
 
\begin{verbatim}  DirectProduct(M,N):: PureCubicalComplex, PureCubicalComplex --> PureCubicalComplex
\end{verbatim}


 

 Inputs two or more regular CW-complexes or two or more pure cubical complexes
and returns their direct product. \\
 \\
 \\
 \\
 \index{FiltrationTerm}::::::::::::::::::::::::\\
 
\begin{verbatim}  FiltrationTerm(K,t):: FilteredPureCubicalComplex, Int --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  FiltrationTerm(K,t):: FilteredRegCWComplex, Int --> RegCWComplex
\end{verbatim}
 

 

 Inputs a filtered regular CW-complex or a filtered pure cubical complex $K$ together with an integer $t \ge 1$. The $t$-th term of the filtration is returned. \\
 \\
 \\
 \\
 \index{Graph}::::::::::::::::::::::::\\
 
\begin{verbatim}  Graph(K):: RegCWComplex --> Graph
\end{verbatim}
 
\begin{verbatim}  Graph(K):: SimplicialComplex --> Graph
\end{verbatim}


 

 Inputs a regular CW-complex or a simplicial complex $K$ and returns its \$1\$-skeleton as a graph. \\
 \\
 \\
 \\
 \index{HomotopyGraph}::::::::::::::::::::::::\\
 
\begin{verbatim}  HomotopyGraph(Y):: RegCWComplex --> Graph
\end{verbatim}


 

 Inputs a regular CW-complex $Y$ and returns a subgraph $M \subset Y^1$ of the $1$-skeleton for which the induced homology homomorphisms $H_1(M,\mathbb Z) \rightarrow H_1(Y,\mathbb Z)$ and $H_1(Y^1,\mathbb Z) \rightarrow H_1(Y,\mathbb Z)$ have identical images. The construction tries to include as few edges in $M$ as possible, though a minimum is not guaranteed. \\
 \\
 \\
 \\
 \index{Nerve}::::::::::::::::::::::::\\
 
\begin{verbatim}  Nerve(M):: PureCubicalComplex --> SimplicialComplex
\end{verbatim}
 
\begin{verbatim}  Nerve(M):: PurePermComplex --> SimplicialComplex
\end{verbatim}
 
\begin{verbatim}  Nerve(M,n):: PureCubicalComplex, Int --> SimplicialComplex
\end{verbatim}
 
\begin{verbatim}  Nerve(M,n):: PurePermComplex, Int --> SimplicialComplex
\end{verbatim}


 

Inputs a pure cubical complex or pure permutahedral complex $M$ and returns the simplicial complex $K$ obtained by taking the nerve of an open cover of $|M|$, the open sets in the cover being sufficiently small neighbourhoods of the
top-dimensional cells of $|M|$. The spaces $|M|$ and $|K|$ are homotopy equivalent by the Nerve Theorem. If an integer $n \ge 0$ is supplied as the second argument then only the n-skeleton of $K$ is returned. \\
 \\
 \\
 \\
 \index{RegularCWComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  RegularCWComplex(K):: SimplicialComplex --> RegCWComplex
\end{verbatim}
 
\begin{verbatim}  RegularCWComplex(K):: PureCubicalComplex --> RegCWComplex
\end{verbatim}
 
\begin{verbatim}  RegularCWComplex(K):: CubicalComplex --> RegCWComplex
\end{verbatim}
 
\begin{verbatim}  RegularCWComplex(K):: PurePermComplex --> RegCWComplex
\end{verbatim}
 
\begin{verbatim}  RegularCWComplex(L):: List --> RegCWComplex
\end{verbatim}
 
\begin{verbatim}  RegularCWComplex(L,M):: List,List --> RegCWComplex
\end{verbatim}


 

Inputs a simplicial, pure cubical, cubical or pure permutahedral complex $K$ and returns the corresponding regular CW-complex. Inputs a list $L=Y!.boundaries$ of boundary incidences of a regular CW-complex $Y$ and returns $Y$. Inputs a list $L=Y!.boundaries$ of boundary incidences of a regular CW-complex $Y$ together with a list $M=Y!.orientation$ of incidence numbers and returns a regular CW-complex $Y$. The availability of precomputed incidence numbers saves recalculating them. \\
 \\
 \\
 \\
 \index{RegularCWMap}::::::::::::::::::::::::\\
 
\begin{verbatim}  RegularCWMap(M,A):: PureCubicalComplex, PureCubicalComplex --> RegCWMap
\end{verbatim}


 

 Inputs a pure cubical complex $M$ and a subcomplex $A$ and returns the inclusion map $A \rightarrow M$ as a map of regular CW complexes. \\
 \\
 \\
 \\
 \index{ThickeningFiltration}::::::::::::::::::::::::\\
 
\begin{verbatim}  ThickeningFiltration(K,n):: PureCubicalComplex, Int --> FilteredPureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ThickeningFiltration(K,n,s):: PureCubicalComplex, Int, Int --> FilteredPureCubicalComplex
\end{verbatim}


 

 Inputs a pure cubical complex $K$ and integer $n \ge 1$, and returns a filtered pure cubical complex of filtration length $n$. The $t$-th term of the filtration is the $t$-fold thickening of $K$. If an integer $s \ge 1$ is entered as the optional third argument then the $t$-th term of the filtration is the $ts$-fold thickening of $K$. \\
 \\
 \\
 Cellular Complexes $\longrightarrow$ Cellular Complexes (Preserving Data Types) \\
 \\
 \\
 \index{ContractedComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  ContractedComplex(K):: RegularCWComplex --> RegularCWComplex
\end{verbatim}
 
\begin{verbatim}  ContractedComplex(K):: FilteredRegularCWComplex --> FilteredRegularCWComplex
\end{verbatim}
 
\begin{verbatim}  ContractedComplex(K):: CubicalComplex --> CubicalComplex
\end{verbatim}
 
\begin{verbatim}  ContractedComplex(K):: PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ContractedComplex(K,S):: PureCubicalComplex, PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ContractedComplex(K):: FilteredPureCubicalComplex --> FilteredPureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ContractedComplex(K):: PurePermComplex --> PurePermComplex
\end{verbatim}
 
\begin{verbatim}  ContractedComplex(K,S):: PurePermComplex, PurePermComplex --> PurePermComplex
\end{verbatim}
 
\begin{verbatim}  ContractedComplex(K):: SimplicialComplex --> SimplicialComplex
\end{verbatim}
 
\begin{verbatim}  ContractedComplex(G):: Graph --> Graph
\end{verbatim}
 

 Inputs a complex (regular CW, Filtered regular CW, pure cubical etc.) and
returns a homotopy equivalent subcomplex. 

 Inputs a pure cubical complex or pure permutahedral complex $K$ and a subcomplex $S$. It returns a homotopy equivalent subcomplex of $K$ that contains $S$. 

 Inputs a graph $G$ and returns a subgraph $S$ such that the clique complexes of $G$ and $S$ are homotopy equivalent. \\
 \\
 \\
 \\
 \index{ContractibleSubcomplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  ContractibleSubcomplex(K):: PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ContractibleSubcomplex(K):: PurePermComplex --> PurePermComplex
\end{verbatim}
 
\begin{verbatim}  ContractibleSubcomplex(K):: SimplicialComplex --> SimplicialComplex
\end{verbatim}


 

 Inputs a non-empty pure cubical, pure permutahedral or simplicial complex $K$ and returns a contractible subcomplex. \\
 \\
 \\
 \\
 \index{KnotReflection}::::::::::::::::::::::::\\
 
\begin{verbatim}  KnotReflection(K):: PureCubicalComplex --> PureCubicalComplex
\end{verbatim}


 

 Inputs a pure cubical knot and returns the reflected knot. \\
 \\
 \\
 \\
 \index{KnotSum}::::::::::::::::::::::::\\
 
\begin{verbatim}  KnotSum(K,L):: PureCubicalComplex, PureCubicalComplex --> PureCubicalComplex
\end{verbatim}


 

 Inputs two pure cubical knots and returns their sum. \\
 \\
 \\
 \\
 \index{OrientRegularCWComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  OrientRegularCWComplex(Y):: RegCWComplex --> Void
\end{verbatim}


 

 Inputs a regular CW-complex $Y$ and computes and stores incidence numbers for $Y$. If $Y$ already has incidence numbers then the function does nothing. \\
 \\
 \\
 \\
 \index{PathComponent}::::::::::::::::::::::::\\
 
\begin{verbatim}  PathComponent(K,n):: SimplicialComplex, Int --> SimplicialComplex
\end{verbatim}
 
\begin{verbatim}  PathComponent(K,n):: PureCubicalComplex, Int --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  PathComponent(K,n):: PurePermComplex, Int --> PurePermComplex
\end{verbatim}


 

Inputs a simplicial, pure cubical or pure permutahedral complex $K$ together with an integer $1 \le n \le \beta_0(K)$. The $n$-th path component of $K$ is returned. \\
 \\
 \\
 \\
 \index{PureComplexBoundary}::::::::::::::::::::::::\\
 
\begin{verbatim}  PureComplexBoundary(M):: PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  PureComplexBoundary(M):: PurePermComplex --> PurePermComplex
\end{verbatim}


 

 Inputs a $d$-dimensional pure cubical or pure permutahedral complex $M$ and returns a $d$-dimensional complex consisting of the closure of those $d$-cells whose boundaries contains some cell with coboundary of size less than
the maximal possible size. \\
 \\
 \\
 \\
 \index{PureComplexComplement}::::::::::::::::::::::::\\
 
\begin{verbatim}  PureComplexComplement(M):: PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  PureComplexComplement(M):: PurePermComplex --> PurePermComplex
\end{verbatim}


 

 Inputs a pure cubical complex or a pure permutahedral complex and returns its
complement. \\
 \\
 \\
 \\
 \index{PureComplexDifference}::::::::::::::::::::::::\\
 
\begin{verbatim}  PureComplexDifference(M,N):: PureCubicalComplex, PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  PureComplexDifference(M,N):: PurePermComplex, PurePermComplex --> PurePermComplex
\end{verbatim}


 

 Inputs two pure cubical complexes or two pure permutahedral complexes and
returns the difference $ M - N$. \\
 \\
 \\
 \\
 \index{PureComplexIntersection}::::::::::::::::::::::::\\
 
\begin{verbatim}  PureComplexInterstection(M,N):: PureCubicalComplex, PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  PureComplexIntersection(M,N):: PurePermComplex, PurePermComplex --> PurePermComplex
\end{verbatim}


 

 Inputs two pure cubical complexes or two pure permutahedral complexes and
returns their intersection. \\
 \\
 \\
 \\
 \index{PureComplexThickened}::::::::::::::::::::::::\\
 
\begin{verbatim}  PureComplexThickened(M):: PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  PureComplexThickened(M):: PurePermComplex --> PurePermComplex
\end{verbatim}


 

 Inputs a pure cubical complex or a pure permutahedral complex and returns the
a thickened complex. \\
 \\
 \\
 \\
 \index{PureComplexUnion}::::::::::::::::::::::::\\
 
\begin{verbatim}  PureComplexUnion(M,N):: PureCubicalComplex, PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  PureComplexUnion(M,N):: PurePermComplex, PurePermComplex --> PurePermComplex
\end{verbatim}


 

 Inputs two pure cubical complexes or two pure permutahedral complexes and
returns their union. \\
 \\
 \\
 \\
 \index{SimplifiedComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  SimplifiedComplex(K):: RegularCWComplex --> RegularCWComplex
\end{verbatim}
 
\begin{verbatim}  SimplifiedComplex(K):: PurePermComplex --> PurePermComplex
\end{verbatim}
 
\begin{verbatim}  SimplifiedComplex(R):: FreeResolution --> FreeResolution
\end{verbatim}
 
\begin{verbatim}  SimplifiedComplex(C):: ChainComplex --> ChainComplex
\end{verbatim}


 

 Inputs a regular CW-complex or a pure permutahedral complex $K$ and returns a homeomorphic complex with possibly fewer cells and certainly no
more cells. 

 Inputs a free $\mathbb ZG$-resolution $R$ of $\mathbb Z$ and returns a $\mathbb ZG$-resolution $S$ with potentially fewer free generators. 

 Inputs a chain complex $C$ of free abelian groups and returns a chain homotopic chain complex $D$ with potentially fewer free generators. \\
 \\
 \\
 \\
 \index{ZigZagContractedComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  ZigZagContractedComplex(K):: PureCubicalComplex --> PureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ZigZagContractedComplex(K):: FilteredPureCubicalComplex --> FilteredPureCubicalComplex
\end{verbatim}
 
\begin{verbatim}  ZigZagContractedComplex(K):: PurePermComplex --> PurePermComplex
\end{verbatim}
 

 Inputs a pure cubical, filtered pure cubical or pure permutahedral complex and
returns a homotopy equivalent complex. In the filtered case, the $t$-th term of the output is homotopy equivalent to the $t$-th term of the input for all $t$. \\
 \\
 \\
 Cellular Complexes $\longrightarrow$ Homotopy Invariants \\
 \\
 \\
 \index{AlexanderPolynomial}::::::::::::::::::::::::\\
 
\begin{verbatim}  AlexanderPolynomial(K):: PureCubicalComplex --> Polynomial
\end{verbatim}
 
\begin{verbatim}  AlexanderPolynomial(K):: PurePermComplex --> Polynomial
\end{verbatim}
 
\begin{verbatim}  AlexanderPolynomial(G):: FpGroup --> Polynomial
\end{verbatim}


 

 Inputs a $3$-dimensional pure cubical or pure permutahdral complex $K$ representing a knot and returns the Alexander polynomial of the fundamental
group $G = \pi_1(\mathbb R^3\setminus K)$. 

 Inputs a finitely presented group $G$ with infinite cyclic abelianization and returns its Alexander polynomial. \\
 \\
 \\
 \\
 \index{BettiNumber}::::::::::::::::::::::::\\
 
\begin{verbatim}  BettiNumber(K,n):: SimplicialComplex, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n):: PureCubicalComplex, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n):: CubicalComplex, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n):: PurePermComplex, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n):: RegCWComplex, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n):: ChainComplex, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n):: SparseChainComplex, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n,p):: SimplicialComplex, Int, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n,p):: PureCubicalComplex, Int, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n,p):: CubicalComplex, Int, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n,p):: PurePermComplex, Int, Int --> Int
\end{verbatim}
 
\begin{verbatim}  BettiNumber(K,n,p):: RegCWComplex, Int, Int --> Int
\end{verbatim}
 

Inputs a simplicial, cubical, pure cubical, pure permutahedral, regular CW,
chain or sparse chain complex $K$ together with an integer $n \ge 0$ and returns the $n$th Betti number of $K$. 

Inputs a simplicial, cubical, pure cubical, pure permutahedral or regular
CW-complex $K$ together with an integer $n \ge 0$ and a prime $p \ge 0$ or $p=0$. In this case the $n$th Betti number of $K$ over a field of characteristic $p$ is returned. \\
 \\
 \\
 \\
 \index{EulerCharacteristic}::::::::::::::::::::::::\\
 
\begin{verbatim}  EulerCharacteristic(C):: ChainComplex --> Int
\end{verbatim}
 
\begin{verbatim}  EulerCharacteristic(K):: CubicalComplex --> Int
\end{verbatim}
 
\begin{verbatim}  EulerCharacteristic(K):: PureCubicalComplex --> Int
\end{verbatim}
 
\begin{verbatim}  EulerCharacteristic(K):: PurePermComplex --> Int
\end{verbatim}
 
\begin{verbatim}  EulerCharacteristic(K):: RegCWComplex --> Int
\end{verbatim}
 
\begin{verbatim}  EulerCharacteristic(K):: SimplicialComplex --> Int
\end{verbatim}


 

 Inputs a chain complex $C$ and returns its Euler characteristic. 

 Inputs a cubical, or pure cubical, or pure permutahedral or regular CW-, or
simplicial complex $K$ and returns its Euler characteristic. \\
 \\
 \\
 \\
 \index{EulerIntegral}::::::::::::::::::::::::\\
 
\begin{verbatim}  EulerIntegral(Y,w):: RegCWComplex, Int --> Int
\end{verbatim}


 

 Inputs a regular CW-complex $Y$ and a weight function $w\colon Y\rightarrow \mathbb Z$, and returns the Euler integral $ \int_Y w\, d\chi $. \\
 \\
 \\
 \\
 \index{FundamentalGroup}::::::::::::::::::::::::\\
 
\begin{verbatim}  FundamentalGroup(K):: RegCWComplex --> FpGroup
\end{verbatim}
 
\begin{verbatim}  FundamentalGroup(K,n):: RegCWComplex, Int --> FpGroup
\end{verbatim}
 
\begin{verbatim}  FundamentalGroup(K):: SimplicialComplex --> FpGroup
\end{verbatim}
 
\begin{verbatim}  FundamentalGroup(K):: PureCubicalComplex --> FpGroup
\end{verbatim}
 
\begin{verbatim}  FundamentalGroup(K):: PurePermComplex --> FpGroup
\end{verbatim}


 
\begin{verbatim}  FundamentalGroup(F):: RegCWMap --> GroupHomomorphism
\end{verbatim}
 
\begin{verbatim}  FundamentalGroup(F,n):: RegCWMap, Int --> GroupHomomorphism
\end{verbatim}


 

 Inputs a regular CW, simplicial, pure cubical or pure permutahedral complex $K$ and returns the fundamental group. 

 Inputs a regular CW complex $K$ and the number $n$ of some zero cell. It returns the fundamental group of $K$ based at the $n$-th zero cell. 

 Inputs a regular CW map $F$ and returns the induced homomorphism of fundamental groups. If the number of
some zero cell in the domain of $F$ is entered as an optional second variable then the fundamental group is based
at this zero cell. \\
 \\
 \\
 \\
 \index{FundamentalGroupOfQuotient}::::::::::::::::::::::::\\
 
\begin{verbatim}  FundamentalGroupOfQuotient(Y):: EquivariantRegCWComplex --> Group
\end{verbatim}


 

 Inputs a $G$-equivariant regular CW complex $Y$ and returns the group $G$. \\
 \\
 \\
 \\
 \index{IsAspherical}::::::::::::::::::::::::\\
 
\begin{verbatim}  IsAspherical(F,R):: FreeGroup, List --> Boolean
\end{verbatim}


 

 Inputs a free group $F$ and a list $R$ of words in $F$. The function attempts to test if the quotient group $G=F/\langle R \rangle^F$ is aspherical. If it succeeds it returns $true$. Otherwise the test is inconclusive and $fail$ is returned. \\
 \\
 \\
 \\
 \index{KnotGroup}::::::::::::::::::::::::\\
 
\begin{verbatim}  KnotGroup(K):: PureCubicalComplex --> FpGroup
\end{verbatim}
 
\begin{verbatim}  KnotGroup(K):: PureCubicalComplex --> FpGroup
\end{verbatim}


 

 Inputs a pure cubical or pure permutahedral complex $K$ and returns the fundamental group of its complement. If the complement is
path-connected then this fundamental group is unique up to isomorphism.
Otherwise it will depend on the path-component in which the randomly chosen
base-point lies. \\
 \\
 \\
 \\
 \index{PiZero}::::::::::::::::::::::::\\
 
\begin{verbatim}  PiZero(Y):: RegCWComplex --> List
\end{verbatim}
 
\begin{verbatim}  PiZero(Y):: Graph --> List
\end{verbatim}
 
\begin{verbatim}  PiZero(Y):: SimplicialComplex --> List
\end{verbatim}


 

 Inputs a regular CW-complex $Y$, or graph $Y$, or simplicial complex $Y$ and returns a pair $[cells,r]$ where: $cells$ is a list of vertices of \$Y\$ representing the distinct path-components; $r(v)$ is a function which, for each vertex $v$ of $Y$ returns the representative vertex $r(v) \in cells$. \\
 \\
 \\
 \\
 \index{PersistentBettiNumbers}::::::::::::::::::::::::\\
 
\begin{verbatim}  PersistentBettiNumbers(K,n):: FilteredSimplicialComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  PersistentBettiNumbers(K,n):: FilteredPureCubicalComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  PersistentBettiNumbers(K,n):: FilteredRegCWComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  PersistentBettiNumbers(K,n):: FilteredChainComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  PersistentBettiNumbers(K,n):: FilteredSparseChainComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  PersistentBettiNumbers(K,n,p):: FilteredSimplicialComplex, Int, Int --> List
\end{verbatim}
 
\begin{verbatim}  PersistentBettiNumbers(K,n,p):: FilteredPureCubicalComplex, Int, Int --> List
\end{verbatim}
 
\begin{verbatim}  PersistentBettiNumbers(K,n,p):: FilteredRegCWComplex, Int, Int --> List
\end{verbatim}
 
\begin{verbatim}  PersistentBettiNumbers(K,n,p):: FilteredChainComplex, Int, Int --> List
\end{verbatim}
 
\begin{verbatim}  PersistentBettiNumbers(K,n,p):: FilteredSparseChainComplex, Int, Int --> List
\end{verbatim}
 

Inputs a filtered simplicial, filtered pure cubical, filtered regular CW,
filtered chain or filtered sparse chain complex $K$ together with an integer $n \ge 0$ and returns the $n$th PersistentBetti numbers of $K$ as a list of lists of integers. 

Inputs a filtered simplicial, filtered pure cubical, filtered regular CW,
filtered chain or filtered sparse chain complex $K$ together with an integer $n \ge 0$ and a prime $p \ge 0$ or $p=0$. In this case the $n$th PersistentBetti numbers of $K$ over a field of characteristic $p$ are returned. \\
 \\
 \\
 Data $\longrightarrow$ Homotopy Invariants \\
 \\
 \\
 \index{DendrogramMat}::::::::::::::::::::::::\\
 
\begin{verbatim}  DendrogramMat(A,t,s):: Mat, Rat, Int --> List
\end{verbatim}


 

 Inputs an $n\times n$ symmetric matrix $A$ over the rationals, a rational $t \ge 0$ and an integer $s \ge 1$. A list $[v_1, \ldots, v_{t+1}]$ is returned with each $v_k$ a list of positive integers. Let $t_k = (k-1)s$. Let $G(A,t_k)$ denote the graph with vertices $1, \ldots, n$ and with distinct vertices $i$ and $j$ connected by an edge when the $(i,j)$ entry of $A$ is $\le t_k$. The $i$-th path component of $G(A,t_k)$ is included in the $v_k[i]$-th path component of $G(A,t_{k+1})$. This defines the integer vector $v_k$. The vector $v_k$ has length equal to the number of path components of $G(A,t_k)$. \\
 \\
 \\
 Cellular Complexes $\longrightarrow$ Non Homotopy Invariants \\
 \\
 \\
 \index{ChainComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  ChainComplex(K):: CubicalComplex --> ChainComplex
\end{verbatim}
 
\begin{verbatim}  ChainComplex(K):: PureCubicalComplex --> ChainComplex
\end{verbatim}
 
\begin{verbatim}  ChainComplex(K):: PurePermComplex --> ChainComplex
\end{verbatim}
 
\begin{verbatim}  ChainComplex(Y):: RegCWComplex --> ChainComplex
\end{verbatim}
 
\begin{verbatim}  ChainComplex(K):: SimplicialComplex --> ChainComplex
\end{verbatim}


 

 Inputs a cubical, or pure cubical, or pure permutahedral or simplicial complex $K$ and returns its chain complex of free abelian groups. In degree $n$ this chain complex has one free generator for each $n$-dimensional cell of $K$. 

 Inputs a regular CW-complex $Y$ and returns a chain complex $C$ which is chain homotopy equivalent to the cellular chain complex of $Y$. In degree $n$ the free abelian chain group $C_n$ has one free generator for each critical $n$-dimensional cell of $Y$ with respect to some discrete vector field on $Y$. \\
 \\
 \\
 \\
 \index{ChainComplexEquivalence}::::::::::::::::::::::::\\
 
\begin{verbatim}  ChainComplexEquivalence(X):: RegCWComplex --> List
\end{verbatim}


 

 Inputs a regular CW-complex $X$ and returns a pair $[f_\ast, g_\ast]$ of chain maps $f_\ast\colon C_\ast(X) \rightarrow D_\ast(X)$, $g_\ast\colon D_\ast(X) \rightarrow C_\ast(X)$. Here $C_\ast(X)$ is the standard cellular chain complex of $X$ with one free generator for each cell in $X$. The chain complex $D_\ast(X)$ is a typically smaller chain complex arising from a discrete vector field on $X$. The chain maps $f_\ast, g_\ast$ are chain homotopy equivalences. \\
 \\
 \\
 \\
 \index{ChainComplexOfQuotient}::::::::::::::::::::::::\\
 
\begin{verbatim}  ChainComplexOfQuotient(Y):: EquivariantRegCWComplex --> ChainComplex
\end{verbatim}


 

 Inputs a $G$-equivariant regular CW-complex $Y$ and returns the cellular chain complex of the quotient space $Y/G$. \\
 \\
 \\
 \\
 \index{ChainMap}::::::::::::::::::::::::\\
 
\begin{verbatim}  ChainMap(X,A,Y,B):: PureCubicalComplex, PureCubicalComplex, PureCubicalComplex, PureCubicalComplex --> ChainMap
\end{verbatim}
 
\begin{verbatim}  ChainMap(f):: RegCWMap --> ChainMap
\end{verbatim}
 
\begin{verbatim}  ChainMap(f):: SimplicialMap --> ChainComplex
\end{verbatim}


 

Inputs a pure cubical complex $Y$ and pure cubical sucomplexes $X\subset Y$, $B\subset Y$,$A\subset B$. It returns the induced chain map $f_\ast\colon C_\ast(X/A) \rightarrow C_\ast(Y/B)$ of cellular chain complexes of pairs. (Typlically one takes $A$ and $B$ to be empty or contractible subspaces, in which case $C_\ast(X/A) \simeq C_\ast(X)$, $C_\ast(Y/B) \simeq C_\ast(Y)$.) 

 Inputs a map $f\colon X \rightarrow Y$ between two regular CW-complexes $X,Y$ and returns an induced chain map $f_\ast\colon C_\ast(X) \rightarrow C_\ast(Y)$ where $C_\ast(X)$, $C_\ast(Y)$ are chain homotopic to (but usually smaller than) the cellular chain complexes
of $X$, $Y$. 

 Inputs a map $f\colon X \rightarrow Y$ between two simplicial complexes $X,Y$ and returns the induced chain map $f_\ast\colon C_\ast(X) \rightarrow C_\ast(Y)$ of cellular chain complexes. \\
 \\
 \\
 \\
 \index{CochainComplex}::::::::::::::::::::::::\\
 
\begin{verbatim}  CochainComplex(K):: CubicalComplex --> CochainComplex
\end{verbatim}
 
\begin{verbatim}  CochainComplex(K):: PureCubicalComplex --> CochainComplex
\end{verbatim}
 
\begin{verbatim}  CochainComplex(K):: PurePermComplex --> CochainComplex
\end{verbatim}
 
\begin{verbatim}  CochainComplex(Y):: RegCWComplex --> CochainComplex
\end{verbatim}
 
\begin{verbatim}  CochainComplex(K):: SimplicialComplex --> CohainComplex
\end{verbatim}


 

 Inputs a cubical, or pure cubical, or pure permutahedral or simplicial complex $K$ and returns its cochain complex of free abelian groups. In degree $n$ this cochain complex has one free generator for each $n$-dimensional cell of $K$. 

 Inputs a regular CW-complex $Y$ and returns a cochain complex $C$ which is chain homotopy equivalent to the cellular cochain complex of $Y$. In degree $n$ the free abelian cochain group $C_n$ has one free generator for each critical $n$-dimensional cell of $Y$ with respect to some discrete vector field on $Y$. \\
 \\
 \\
 \\
 \index{CriticalCells}::::::::::::::::::::::::\\
 
\begin{verbatim}  CriticalCells(K):: RegCWComplex --> List
\end{verbatim}


 

 Inputs a regular CW-complex $K$ and returns its critical cells with respect to some discrete vector field on $K$. If no discrete vector field on $K$ is available then one will be computed and stored. \\
 \\
 \\
 \\
 \index{DiagonalApproximation}::::::::::::::::::::::::\\
 
\begin{verbatim}  DiagonalApproximation(X):: RegCWComplex --> RegCWMap, RegCWMap
\end{verbatim}


 

 Inputs a regular CW-complex $X$ and outputs a pair $[p,\iota]$ of maps of CW-complexes. The map $p\colon X^\Delta \rightarrow X$ will often be a homotopy equivalence. This is always the case if $X$ is the CW-space of any pure cubical complex. In general, one can test to see
if the induced chain map $p_\ast \colon C_\ast(X^\Delta) \rightarrow C_\ast(X)$ is an isomorphism on integral homology. The second map $\iota \colon X^\Delta \hookrightarrow X\times X$ is an inclusion into the direct product. If $p_\ast$ induces an isomorphism on homology then the chain map $\iota_\ast\colon C_\ast(X^\Delta) \rightarrow C_\ast(X\times X)$ can be used to compute the cup product. \\
 \\
 \\
 \\
 \index{Size}::::::::::::::::::::::::\\
 
\begin{verbatim}  Size(Y):: RegCWComplex --> Int
\end{verbatim}
 
\begin{verbatim}  Size(Y):: SimplicialComplex --> Int
\end{verbatim}
 
\begin{verbatim}  Size(K):: PureCubicalComplex --> Int
\end{verbatim}
 
\begin{verbatim}  Size(K):: PurePermComplex --> Int
\end{verbatim}


 

Inputs a regular CW complex or a simplicial complex $Y$ and returns the number of cells in the complex. 

Inputs a $d$-dimensional pure cubical or pure permutahedral complex $K$ and returns the number of $d$-dimensional cells in the complex. \\
 \\
 \\
 (Co)chain Complexes $\longrightarrow $ (Co)chain Complexes \\
 \\
 \\
 \index{FilteredTensorWithInteres}::::::::::::::::::::::::\\
 
\begin{verbatim}  FilteredTensorWithIntegers(R):: FreeResolution, Int --> FilteredChainComplex
\end{verbatim}


 Inputs a free $\mathbb ZG$-resolution $R$ for which $"filteredDimension"$ lies in \textsc{NamesOfComponents(R)}. (Such a resolution can be produced using \textsc{TwisterTensorProduct()}, \textsc{ResolutionNormalSubgroups()} or \textsc{FreeGResolution()}.) It returns the filtered chain complex obtained by tensoring with the
trivial module \$\texttt{\symbol{92}}mathbb Z\$. \\
 \\
 \\
 \\
 \index{FilteredTensorWithInteresModP}::::::::::::::::::::::::\\
 
\begin{verbatim}  FilteredTensorWithIntegersModP(R,p):: FreeResolution, Int --> FilteredChainComplex
\end{verbatim}


 Inputs a free $\mathbb ZG$-resolution $R$ for which $"filteredDimension"$ lies in \textsc{NamesOfComponents(R)}, together with a prime $p$. (Such a resolution can be produced using \textsc{TwisterTensorProduct()}, \textsc{ResolutionNormalSubgroups()} or \textsc{FreeGResolution()}.) It returns the filtered chain complex obtained by tensoring with the
trivial module \$\texttt{\symbol{92}}mathbb F\$, the field of $p$ elements. \\
 \\
 \\
 \\
 \index{HomToIntegers}::::::::::::::::::::::::\\
 
\begin{verbatim}  HomToIntegers(C):: ChainComplex --> CochainComplex
\end{verbatim}
 
\begin{verbatim}  HomToIntegers(R):: FreeResolution --> CochainComplex
\end{verbatim}
 
\begin{verbatim}  HomToIntegers(F):: EquiChainMap --> CochainMap
\end{verbatim}


 

 Inputs a chain complex $C$ of free abelian groups and returns the cochain complex $Hom_{\mathbb Z}(C,\mathbb Z)$. 

 Inputs a free $\mathbb ZG$-resolution $R$ in characteristic $0$ and returns the cochain complex $Hom_{\mathbb ZG}(R,\mathbb Z)$. 

 Inputs an equivariant chain map $F\colon R\rightarrow S$ of resolutions and returns the induced cochain map $Hom_{\mathbb ZG}(S,\mathbb Z) \longrightarrow Hom_{\mathbb ZG}(R,\mathbb Z)$. \\
 \\
 \\
 \\
 \index{TensorWithIntegersModP}::::::::::::::::::::::::\\
 
\begin{verbatim}  TensorWithIntegersModP(C,p):: ChainComplex, Int --> ChainComplex
\end{verbatim}
 
\begin{verbatim}  TensorWithIntegersModP(R,p):: FreeResolution, Int --> ChainComplex
\end{verbatim}
 
\begin{verbatim}  TensorWithIntegersModP(F,p):: EquiChainMap, Int --> ChainMap
\end{verbatim}


 

 Inputs a chain complex $C$ of characteristic $0$ and a prime integer $p$. It returns the chain complex $C \otimes_{\mathbb Z} {\mathbb Z}_p$ of characteristic $p$. 

 Inputs a free $\mathbb ZG$-resolution $R$ of characteristic $0$ and a prime integer $p$. It returns the chain complex $R \otimes_{\mathbb ZG} {\mathbb Z}_p$ of characteristic $p$. 

 Inputs an equivariant chain map $F\colon R \rightarrow S$ in characteristic $0$ a prime integer $p$. It returns the induced chain map $F\otimes_{\mathbb ZG}\mathbb Z_p \colon R \otimes_{\mathbb ZG} {\mathbb Z}_p
\longrightarrow S \otimes_{\mathbb ZG} {\mathbb Z}_p$. \\
 \\
 \\
 (Co)chain Complexes $\longrightarrow $ Homotopy Invariants \\
 \\
 \\
 \index{Cohomology}::::::::::::::::::::::::\\
 
\begin{verbatim}  Cohomology(C,n):: CochainComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Cohomology(F,n):: CochainMap, Int --> GroupHomomorphism
\end{verbatim}
 
\begin{verbatim}  Cohomology(K,n):: CubicalComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Cohomology(K,n):: PureCubicalComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Cohomology(K,n):: PurePermComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Cohomology(K,n):: RegCWComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Cohomology(K,n):: SimplicialComplex, Int --> List
\end{verbatim}


 

 Inputs a cochain complex $C$ and integer $n \ge 0$ and returns the $n$-th cohomology group of $C$ as a list of its abelian invariants. 

 Inputs a chain map $F$ and integer $n \ge 0$. It returns the induced cohomology homomorphism $H_n(F)$ as a homomorphism of finitely presented groups. 

 Inputs a cubical, or pure cubical, or pure permutahedral or regular CW or
simplicial complex $K$ together with an integer $n \ge 0$. It returns the $n$-th integral cohomology group of $K$ as a list of its abelian invariants. \\
 \\
 \\
 \\
 \index{CupProduct}::::::::::::::::::::::::\\
 
\begin{verbatim}  CupProduct(Y):: RegCWComplex --> Function
\end{verbatim}
 
\begin{verbatim}  CupProduct(R,p,q,P,Q):: FreeRes, Int, Int, List, List  --> List
\end{verbatim}


 

 Inputs a regular CW-complex $Y$ and returns a function $f(p,q,P,Q)$. This function $f$ inputs two integers $p,q \ge 0$ and two integer lists $P=[p_1, \ldots, p_m]$, $Q=[q_1, \ldots, q_n]$ representing elements $P\in H^p(Y,\mathbb Z)$ and $Q\in H^q(Y,\mathbb Z)$. The function $f$ returns a list $P \cup Q$ representing the cup product $P \cup Q \in H^{p+q}(Y,\mathbb Z)$. 

 Inputs a free $\mathbb ZG$ resolution $R$ of $\mathbb Z$ for some group $G$, together with integers $p,q \ge 0$ and integer lists $P, Q$ representing cohomology classes $P\in H^p(G,\mathbb Z)$, $Q\in H^q(G,\mathbb Z)$. An integer list representing the cup product $P\cup Q \in H^{p+q}(G,\mathbb Z)$ is returned. \\
 \\
 \\
 \\
 \index{Homology}::::::::::::::::::::::::\\
 
\begin{verbatim}  Homology(C,n):: ChainComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Homology(F,n):: ChainMap, Int --> GroupHomomorphism
\end{verbatim}
 
\begin{verbatim}  Homology(K,n):: CubicalComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Homology(K,n):: PureCubicalComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Homology(K,n):: PurePermComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Homology(K,n):: RegCWComplex, Int --> List
\end{verbatim}
 
\begin{verbatim}  Homology(K,n):: SimplicialComplex, Int --> List
\end{verbatim}


 

 Inputs a chain complex $C$ and integer $n \ge 0$ and returns the $n$-th homology group of $C$ as a list of its abelian invariants. 

 Inputs a chain map $F$ and integer $n \ge 0$. It returns the induced homology homomorphism $H_n(F)$ as a homomorphism of finitely presented groups. 

 Inputs a cubical, or pure cubical, or pure permutahedral or regular CW or
simplicial complex $K$ together with an integer $n \ge 0$. It returns the $n$-th integral homology group of $K$ as a list of its abelian invariants. \\
 \\
 \\
 Visualization \\
 \\
 \\
 \index{BarCodeDisplay}::::::::::::::::::::::::\\
 
\begin{verbatim}  BarCodeDisplay(L) :: List --> void
\end{verbatim}


 

Displays a barcode \textsc{L=PersitentBettiNumbers(X,n)}. \\
 \\
 \\
 \\
 \index{BarCodeCompactDisplay}::::::::::::::::::::::::\\
 
\begin{verbatim}  BarCodeCompactDisplay(L) :: List --> void
\end{verbatim}


 

Displays a barcode \textsc{L=PersitentBettiNumbers(X,n)} in compact form. \\
 \\
 \\
 \\
 \index{CayleyGraphOfGroupDisplay}::::::::::::::::::::::::\\
 
\begin{verbatim}  CayleyGraphOfGroup(G,L):: Group, List --> Void
\end{verbatim}


 

 Inputs a finite group $G$ and a list $L$ of elements in $G$.It displays the Cayley graph of the group generated by $L$ where edge colours correspond to generators. \\
 \\
 \\
 \\
 \index{Display}::::::::::::::::::::::::\\
 
\begin{verbatim}  Display(G) :: Graph --> void
\end{verbatim}
 
\begin{verbatim}  Display(M) :: PureCubicalComplex --> void
\end{verbatim}
 
\begin{verbatim}  Display(M) :: PurePermutahedralComplex --> void
\end{verbatim}


 

Displays a graph $G$; a \$2\$- or \$3\$-dimensional pure cubical complex $M$; a \$3\$-dimensional pure permutahedral complex $M$. \\
 \\
 \\
 \\
 \index{DisplayArcPresentation}::::::::::::::::::::::::\\
 
\begin{verbatim}  DisplayArcPresentation(K) :: PureCubicalComplex --> void
\end{verbatim}


 

Displays a $3$-dimensional pure cubical knot \textsc{K=PureCubicalKnot(L)} in the form of an arc presentation. \\
 \\
 \\
 \\
 \index{DisplayCSVknotFile}::::::::::::::::::::::::\\
 
\begin{verbatim}  DisplayCSVKnotFile(str) :: String --> void
\end{verbatim}


 

Inputs a string $str$ that identifies a csv file containing the points on a piecewise linear knot in $\mathbb R^3$. It displays the knot. \\
 \\
 \\
 \\
 \index{DisplayDendrogram}::::::::::::::::::::::::\\
 
\begin{verbatim}  DisplayDendrogram(L):: List --> Void
\end{verbatim}


 

 Displays the dendrogram \textsc{L:=DendrogramMat(A,t,s)}. \\
 \\
 \\
 \\
 \index{DisplayDendrogramMat}::::::::::::::::::::::::\\
 
\begin{verbatim}  DisplayDendrogramMat(A,t,s):: Mat, Rat, Int --> Void
\end{verbatim}


 

 Inputs an $n\times n$ symmetric matrix $A$ over the rationals, a rational $t \ge 0$ and an integer $s \ge 1$. The dendrogram defined by \textsc{DendrogramMat(A,t,s)} is displayed. \\
 \\
 \\
 \\
 \index{DisplayPDBfile}::::::::::::::::::::::::\\
 
\begin{verbatim}  DisplayPDBfile(str):: String --> Void
\end{verbatim}


 

 Displays the protein backone described in a PDB (Protein Database) file
identified by a string str such as "file.pdb" or "path/file.pdb". \\
 \\
 \\
 \\
 \index{OrbitPolytope}::::::::::::::::::::::::\\
 
\begin{verbatim}  OrbitPolytope(G,v,L) :: PermGroup, List, List --> void
\end{verbatim}


 

Inputs a permutation group or finite matrix group $G$ of degree $d$ and a rational vector $v\in \mathbb R^d$. In both cases there is a natural action of $G$ on $\mathbb R^d$. Let $P(G,v)$ be the convex hull of the orbit of $v$ under the action of $G$. The function also inputs a sublist $L$ of the following list of strings:
["dimension","vertex\texttt{\symbol{92}}{\textunderscore}degree",
"visual\texttt{\symbol{92}}{\textunderscore}graph", "schlegel", "visual"] 

Depending on $L$, the function displays the following
information:\texttt{\symbol{92}}\texttt{\symbol{92}} the dimension of the
orbit polytope $P(G,v)$;\texttt{\symbol{92}}\texttt{\symbol{92}} the degree of a vertex in the graph
of $P(G,v)$;\texttt{\symbol{92}}\texttt{\symbol{92}} a visualization of the graph of $P(G,v)$;\texttt{\symbol{92}}\texttt{\symbol{92}} a visualization of the Schlegel
diagram of $P(G,v)$;\texttt{\symbol{92}}\texttt{\symbol{92}} a visualization of the polytope $P(G,v)$ if $d=2,3$. 

The function requires Polymake software. \\
 \\
 \\
 \\
 \index{ScatterPlot}::::::::::::::::::::::::\\
 
\begin{verbatim}  ScatterPlot(L):: List --> Void
\end{verbatim}


 

 Inputs a list $L=[[x_1,y_1],\ldots, [x_n,y_n]]$ of pairs of rational numbers and displays a scatter plot of the points in the $x$-$y$-plane. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{$\mathbb ZG$-Resolutions and Group Cohomology}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7C391012839DB4C5}{}
{
 Resolutions \begin{center}
\begin{tabular}{|l|} \index{EquivariantChainMap} 
\begin{verbatim}  EquivariantChainMap(R,S,f):: FreeResolution, FreeResolution, GroupHomomorphisms --> EquiChainMap
\end{verbatim}
 

 Inputs a free $\mathbb ZG$-resolution $R$ of $\mathbb Z$, a free $\mathbb ZQ$-resolution $S$ of $\mathbb Z$, and a group homomorphism $f\colon G \rightarrow Q$. It returns the induced $f$-equivariant chain map $F\colon R \rightarrow S$. \\
 \index{FreeGResolution} 
\begin{verbatim}  FreeGResolution(P,n):: NonFreeResolution, Int --> FreeResolution
\end{verbatim}


 Inputs a non-free \$\texttt{\symbol{92}}mathbb ZG\$-resolution
\$P{\textunderscore}\texttt{\symbol{92}}ast\$ and a positive integer $n$. It attempts to return $n$ terms of a free $\mathbb ZG$-resolution of $\mathbb Z$. However, the stabilizer groups in the non-free resolution must be such that
HAP can construct free resolutions with contracting homotopies for them. 

 The contracting homotopy on the resolution was implemented by Bui Anh Tuan. \\
 \index{ResolutionBieberbachGroup} 
\begin{verbatim}  ResolutionBieberbachGroup(G):: MatrixGroup --> FreeResolution
\end{verbatim}
 
\begin{verbatim}  ResolutionBieberbachGroup(G,v):: MatrixGroup, List --> FreeResolution
\end{verbatim}


 

 Inputs a torsion free crystallographic group $G$, also known as a Bieberbach group, represented using \textsc{AffineCrystGroupOnRight} as in the GAP package Cryst. It also optionally inputs a choice of vector $v$ in the Euclidean space $\mathbb R^n$ on which $G$ acts freely. The function returns $n+1$ terms of the free ZG-resolution of $\mathbb Z$ arising as the cellular chain complex of the tessellation of $\mathbb R^n$ by the Dirichlet-Voronoi fundamental domain determined by $v$. No contracting homotopy is returned with the resolution. 

 This function is part of the HAPcryst package written by Marc Roeder and thus
requires the HAPcryst package to be loaded. 

 The function requires the use of Polymake software. \\
 \index{ResolutionCubicalCrystGroup} 
\begin{verbatim}  ResolutionCubicalCrustGroup(G,k):: MatrixGroup, Int --> FreeResolution
\end{verbatim}
 

 Inputs a crystallographic group $G$ represented using \textsc{AffineCrystGroupOnRight} as in the GAP package $Cryst$ together with an integer $k \ge 1$. The function tries to find a cubical fundamental domain in the Euclidean
space $\mathbb R^n$ on which $G$ acts. If it succeeds it uses this domain to return $k+1$ terms of a free ZG-resolution of $\mathbb Z$. 

 This function was written by Bui Anh Tuan. \\
 \index{ResolutionFiniteGroup} 
\begin{verbatim}  ResolutionFiniteGroup(G,k):: Group, Int --> FreeResolution
\end{verbatim}


 

 Inputs a finite group $G$ and an integer $k \ge 1$. It returns $k+1$ terms of a free ZG-resolution of $\mathbb Z$. \\
 \index{ResolutionNilpotentGroup} 
\begin{verbatim}  ResolutionNilpotentGroup(G,k):: Group, Int --> FreeResolution
\end{verbatim}


 

 Inputs a nilpotent group $G$ (which can be infinite) and an integer $k \ge 1$. It returns $k+1$ terms of a free $\mathbb ZG$-resolution of $\mathbb Z$. \\
 \index{ResolutionNormalSeries} 
\begin{verbatim}  ResolutionNormalSeries(L,k):: List, Int --> FreeResolution
\end{verbatim}


 

 Inputs a a list $L$ consisting of a chain \$$1=N_1 \le N_2 \le \cdots \le N_n =G$ of normal subgroups of $G$, together with an integer $k \ge 1$. It returns $k+1$ terms of a free ZG-resolution of $\mathbb Z$. \\
 \index{ResolutionPrimePowerGroup} 
\begin{verbatim}  ResolutionPrimePowerGroup(G,k):: Group, Int --> FreeResolution
\end{verbatim}


 

 Inputs a finite $p$-group $G$ and an integer $k \ge 1$. It returns $k+1$ terms of a minimal free $\mathbb FG$-resolution of the field $\mathbb F$ of $p$ elements. \\
 \index{ResolutionSL2Z} 
\begin{verbatim}  ResolutionSL2Z(m,k):: Int, Int --> FreeResolution
\end{verbatim}
 Inputs positive integers $m, n$ and returns $n$ terms of a free $\mathbb ZG$-resolution of $\mathbb Z$ for the group $G=SL_2(\mathbb Z[1/m])$. 

 This function is joint work with Bui Anh Tuan. \\
 \index{ResolutionSmallGroup} 
\begin{verbatim}  ResolutionSmallGroup(G,k):: Group, Int --> FreeResolution
\end{verbatim}
 
\begin{verbatim}  ResolutionSmallGroup(G,k):: FpGroup, Int --> FreeResolution
\end{verbatim}
 

 Inputs a small group $G$ and an integer $k \ge 1$. It returns $k+1$ terms of a free ZG-resolution of $\mathbb Z$. 

 If $G$ is a finitely presented group then up to degree \$2\$ the resolution coincides
with cellular chain complex of the universal cover of the $2$ complex associated to the presentation of $G$. Thus the boundaries of the generators in degree $3$ provide a generating set for the module of identities of the presentation. 

 This function was written by Irina Kholodna. \\
 \index{ResolutionSubgroup} 
\begin{verbatim}  ResolutionSubgroup(R,H):: FreeResolution, Group --> FreeResolution
\end{verbatim}


 

 Inputs a free ZG-resolution of $\mathbb Z$ and a finite index subgroup $H \le G$. It returns a free ZH-resolution of $\mathbb Z$. \\
\end{tabular}\\[2mm]
\end{center}

 Algebras $\longrightarrow $ (Co)chain Complexes \begin{center}
\begin{tabular}{|l|} \index{LeibnizComplex} 
\begin{verbatim}  LeibnizComplex(g,n):: LeibnizAlgebra, Int --> ChainComplex
\end{verbatim}
 

 Inputs a Leibniz algebra, or Lie algebra, $\mathfrak{g}$ over a ring $\mathbb K$ together with an integer $n\ge 0$. It returns the first $n$ terms of the Leibniz chain complex over $\mathbb K$. The complex was implemented by Pablo Fernandez Ascariz. \\
\end{tabular}\\[2mm]
\end{center}

 Resolutions $\longrightarrow $ (Co)chain Complexes \begin{center}
\begin{tabular}{|l|} \index{HomToIntegers} 
\begin{verbatim}  HomToIntegers(C):: ChainComplex --> CochainComplex
\end{verbatim}
 
\begin{verbatim}  HomToIntegers(R):: FreeResolution --> CochainComplex
\end{verbatim}
 
\begin{verbatim}  HomToIntegers(F):: EquiChainMap --> CochainMap
\end{verbatim}


 

 Inputs a chain complex $C$ of free abelian groups and returns the cochain complex $Hom_{\mathbb Z}(C,\mathbb Z)$. 

 Inputs a free $\mathbb ZG$-resolution $R$ in characteristic $0$ and returns the cochain complex $Hom_{\mathbb ZG}(R,\mathbb Z)$. 

 Inputs an equivariant chain map $F\colon R\rightarrow S$ of resolutions and returns the induced cochain map $Hom_{\mathbb ZG}(S,\mathbb Z) \longrightarrow Hom_{\mathbb ZG}(R,\mathbb Z)$. \\
 \index{HomToIntegralModule} 
\begin{verbatim}  HomToIntegralModule(R,A):: FreeResolution, GroupHomomorphism --> CochainComplex
\end{verbatim}


 

 Inputs a free $\mathbb ZG$-resolution $R$ in characteristic $0$ and a group homomorphism $A\colon G \rightarrow {\rm GL}_n(\mathbb Z)$. The homomorphism $A$ can be viewed as the $\mathbb ZG$-module with underlying abelian group $\mathbb Z^n$ on which $G$ acts via the homomorphism $A$. It returns the cochain complex $Hom_{\mathbb ZG}(R,A)$. \\
 \index{TensorWithIntegers} 
\begin{verbatim}  TensorWithIntegers(R):: FreeResolution --> ChainComplex
\end{verbatim}
 
\begin{verbatim}  TensorWithIntegers(F):: EquiChainMap --> ChainMap
\end{verbatim}


 

 Inputs a free $\mathbb ZG$-resolution $R$ of characteristic $0$ and returns the chain complex $R \otimes_{\mathbb ZG} {\mathbb Z}$. 

 Inputs an equivariant chain map $F\colon R \rightarrow S$ in characteristic $0$ and returns the induced chain map $F\otimes_{\mathbb ZG}\mathbb Z \colon R \otimes_{\mathbb ZG} {\mathbb Z}
\longrightarrow S \otimes_{\mathbb ZG} {\mathbb Z}$. \\
 \index{TensorWithIntegersModP} 
\begin{verbatim}  TensorWithIntegersModP(C,p):: ChainComplex, Int --> ChainComplex
\end{verbatim}
 
\begin{verbatim}  TensorWithIntegersModP(R,p):: FreeResolution, Int --> ChainComplex
\end{verbatim}
 
\begin{verbatim}  TensorWithIntegersModP(F,p):: EquiChainMap, Int --> ChainMap
\end{verbatim}


 

 Inputs a chain complex $C$ of characteristic $0$ and a prime integer $p$. It returns the chain complex $C \otimes_{\mathbb Z} {\mathbb Z}_p$ of characteristic $p$. 

 Inputs a free $\mathbb ZG$-resolution $R$ of characteristic $0$ and a prime integer $p$. It returns the chain complex $R \otimes_{\mathbb ZG} {\mathbb Z}_p$ of characteristic $p$. 

 Inputs an equivariant chain map $F\colon R \rightarrow S$ in characteristic $0$ a prime integer $p$. It returns the induced chain map $F\otimes_{\mathbb ZG}\mathbb Z_p \colon R \otimes_{\mathbb ZG} {\mathbb Z}_p
\longrightarrow S \otimes_{\mathbb ZG} {\mathbb Z}_p$. \\
\end{tabular}\\[2mm]
\end{center}

 Cohomology rings \begin{center}
\begin{tabular}{|l|} \index{AreIsomorphicGradedAlgebras} 
\begin{verbatim}  AreIsomorphicGradedAlgebras(A,B):: PresentedGradedAlgebra, PresentedGradedAlgebra --> Boolean
\end{verbatim}


 Inputs two freely presented graded algebras $A=\mathbb F[x_1, \ldots, x_m]/I$ and $B=\mathbb F[y_1, \ldots, y_n]/J$ and returns \textsc{true} if they are isomorphic, and \textsc{false} otherwise. This function was implemented by Paul Smith. \\
 \index{HAPDerivation} 
\begin{verbatim}  HAPDerivation(R,I,L):: PolynomialRing, List, List --> Derivation
\end{verbatim}


 Inputs a polynomial ring $R=\mathbb F[x_1,\ldots,x_m]$ over a field $\mathbb F$ together with a list $I$ of generators for an ideal in $R$ and a list $L=[y_1,\ldots,y_m]\subset R$. It returns the derivation $d\colon E \rightarrow E$ for $E=R/I$ defined by $d(x_i)=y_i$. This function was written by Paul Smith. It uses the Singular commutative
algebra package. \\
 \index{HilbertPoincareSeries} 
\begin{verbatim}  HilbertPoincareSeries::PresentedGradedAlgebra  --> RationalFunction
\end{verbatim}
 Inputs a presentation $E=\mathbb F[x_1,\ldots,x_m]/I$ of a graded algebra and returns its Hilbert-Poincar\texttt{\symbol{92}}'e
series. This function was written by Paul Smith and uses the Singular
commutative algebra package. It is essentially a wrapper for Singular's
Hilbert-Poincare series. \\
 \index{HomologyOfDerivation} 
\begin{verbatim}  HomologyOfDerivation(d):: Derivation --> List
\end{verbatim}


 Inputs a derivation $d\colon E \rightarrow E$ on a quotient $E=R/I$ of a polynomial ring $R=\mathbb F[x_1,\ldots,x_m]$ over a field $\mathbb F$. It returns a list $[S,J,h]$ where $S$ is a polynomial ring and $J$ is a list of generators for an ideal in \$S\$ such that there is an
isomorphism $\alpha\colon S/J \rightarrow \ker d/{\rm im~} d$. This isomorphism lifts to the ring homomorphism $h\colon S \rightarrow \ker d$. This function was written by Paul Smith. It uses the Singular commutative
algebra package. \\
 \index{IntegralCohomologyGenerators} 
\begin{verbatim}  IntegralCohomologyGenerators(R,n):: FreeResolution, Int --> List
\end{verbatim}


 Inputs at least $n+1$ terms of a free $\mathbb ZG$-resolution of $\mathbb Z$ and the integer $ n \ge 1$. It returns a minimal list of cohomology classes in $H^n(G,\mathbb Z)$ which, together with all cup products of lower degree classes, generate the
group $H^n(G,\mathbb Z)$ . (Let $a_i$ be the $i$-th canonical generator of the $d$-generator abelian group $H^n(G,Z)$. The cohomology class $n_1a_1 + ... +n_da_d$ is represented by the integer vector $u=(n_1, ..., n_d)$. ) \\
 \index{LHSSpectralSequence} 
\begin{verbatim}  LHSSpectralSequence(G,N,r):: Group, Int, Int --> List
\end{verbatim}


 Inputs a finite $2$-group $G$, and normal subgroup $N$ and an integer $r$. It returns a list of length $r$ whose $i$-th term is a presentation for the $i$-th page of the Lyndon-Hochschild-Serre spectral sequence. This function was
written by Paul Smith. It uses the Singular commutative algebra package. \\
 \index{LHSSpectralSequenceLastSheet} 
\begin{verbatim}  LHSSpectralSequenceLastSheet(G,N):: Group, Int --> List
\end{verbatim}


 Inputs a finite $2$-group $G$ and normal subgroup $N$. It returns presentation for the $E_\infty$ page of the Lyndon-Hochschild-Serre spectral sequence. This function was
written by Paul Smith. It uses the Singular commutative algebra package. \\
 \index{ModPCohomologyGenerators} 
\begin{verbatim}  ModPCohomologyGenerators(G,n):: Group, Int --> List
\end{verbatim}
 
\begin{verbatim}  ModPCohomologyGenerators(R):: FreeResolution --> List
\end{verbatim}


 Inputs either a $p$-group $G$ and positive integer $n$, or else $n+1$ terms of a minimal $\mathbb FG$-resolution $R$ of the field $\mathbb F$ of $p$ elements. It returns a pair whose first entry is a minimal list of homogeneous
generators for the cohomology ring $A=H^\ast(G,\mathbb F)$ modulo all elements in degree greater than $n$. The second entry of the pair is a function \textsc{deg} which, when applied to a minimal generator, yields its degree. WARNING: the
following rule must be applied when multiplying generators $x_i$ together. Only products of the form $x_1*(x_2*(x_3*(x_4*...)))$ with $deg(x_i) \le deg(x_{i+1})$ should be computed (since the $x_i$ belong to a structure constant algebra with only a partially defined structure
constants table). \\
 \index{ModPCohomologyRing} 
\begin{verbatim}  ModPCohomologyRing(R):: FreeResolution --> SCAlgebra
\end{verbatim}
 
\begin{verbatim}  ModPCohomologyRing(R,level):: FreeResolution, String --> SCAlgebra
\end{verbatim}
 
\begin{verbatim}  ModPCohomologyRing(G,n):: Group, Int --> SCAlgebra
\end{verbatim}
 
\begin{verbatim}  ModPCohomologyRing(G,n,level):: Group, Int, String --> SCAlgebra
\end{verbatim}


 Inputs either a $p$-group $G$ and positive integer $n$, or else $n$ terms of a minimal $\mathbb FG$-resolution $R$ of the field $\mathbb F$ of $p$ elements. It returns the cohomology ring $A=H^\ast(G,\mathbb F)$ modulo all elements in degree greater than $n$. The ring is returned as a structure constant algebra $A$. The ring $A$ is graded. It has a component \textsc{A!.degree(x)} which is a function returning the degree of each (homogeneous) element $x$ in \textsc{GeneratorsOfAlgebra(A)}. An optional input variable $"level"$ can be set to one of the strings $"medium"$ or $"high"$. These settings determine parameters in the algorithm. The default setting is $"medium"$. When $"level"$ is set to $"high"$ the ring $A$ is returned with a component \textsc{A!.niceBasis}. This component is a pair $[Coeff,Bas]$. Here $Bas$ is a list of integer lists; a "nice" basis for the vector space $A$ can be constructed using the command \textsc{List(Bas,x-{\textgreater}Product(List(x,i-{\textgreater}Basis(A)[i]))}. The coefficients of the canonical basis element \textsc{Basis(A)[i]} are stored as \textsc{Coeff[i]}. If the ring $A$ is computed using the setting $"level"="medium"$ then the component \textsc{A!.niceBasis} can be added to $A$ using the command \textsc{A:=ModPCohomologyRing\texttt{\symbol{92}}{\textunderscore}part\texttt{\symbol{92}}{\textunderscore}2(A)}. \\
 \index{Mod2CohomologyRingPresentation} 
\begin{verbatim}  Mod2CohomologyRingPresentation(G):: Group --> PresentedGradedAlgebra
\end{verbatim}
 
\begin{verbatim}  Mod2CohomologyRingPresentation(G,n):: Group --> PresentedGradedAlgebra
\end{verbatim}
 
\begin{verbatim}  Mod2CohomologyRingPresentation(A):: Group --> PresentedGradedAlgebra
\end{verbatim}
 
\begin{verbatim}  Mod2CohomologyRingPresentation(R):: Group --> PresentedGradedAlgebra
\end{verbatim}


 When applied to a finite $2$-group $G$ this function returns a presentation for the mod-$2$ cohomology ring $H^\ast(G,\mathbb F)$. The Lyndon-Hochschild-Serre spectral sequence is used to prove that the
presentation is complete. When the function is applied to a $2$-group G and positive integer $n$ the function first constructs $n+1$ terms of a free $\mathbb FG$-resolution $R$, then constructs the finite-dimensional graded algebra $A=H^{(\ast \le n)}(G,\mathbb F)$, and finally uses $A$ to approximate a presentation for $H^*(G,\mathbb F)$. For "sufficiently large" $n$ the approximation will be a correct presentation for $H^\ast(G,\mathbb F)$. Alternatively, the function can be applied directly to either the resolution $R$ or graded algebra $A$. This function was written by Paul Smith. It uses the Singular commutative
algebra package to handle the Lyndon-Hochschild-Serre spectral sequence. \\
\end{tabular}\\[2mm]
\end{center}

 Group Invariants \begin{center}
\begin{tabular}{|l|} \index{GroupCohomology} 
\begin{verbatim}  GroupCohomology(G,k):: Group, Int --> List
\end{verbatim}
 
\begin{verbatim}  GroupCohomology(G,k,p):: Group, Int, Int --> List
\end{verbatim}


 

 Inputs a group $G$ and integer $k \ge 0$. The group $G$ should either be finite or else lie in one of a range of classes of infinite
groups (such as nilpotent, crystallographic, Artin etc.). The function returns
the list of abelian invariants of $H^k(G,\mathbb Z)$. 

 If a prime $p$ is given as an optional third input variable then the function returns the
list of abelian invariants of $H^k(G,\mathbb Z_p)$. In this case each abelian invariant will be equal to $p$ and the length of the list will be the dimension of the vector space $H^k(G,\mathbb Z_p)$. \\
 \index{GroupHomology} 
\begin{verbatim}  GroupHomology(G,k):: Group, Int --> List
\end{verbatim}
 
\begin{verbatim}  GroupHomology(G,k,p):: Group, Int, Int --> List
\end{verbatim}


 

 Inputs a group $G$ and integer $k \ge 0$. The group $G$ should either be finite or else lie in one of a range of classes of infinite
groups (such as nilpotent, crystallographic, Artin etc.). The function returns
the list of abelian invariants of $H_k(G,\mathbb Z)$. 

 If a prime $p$ is given as an optional third input variable then the function returns the
list of abelian invariants of $H_k(G,\mathbb Z_p)$. In this case each abelian invariant will be equal to $p$ and the length of the list will be the dimension of the vector space $H_k(G,\mathbb Z_p)$. \\
 \index{PrimePartDerivedFunctor} 
\begin{verbatim}  PrimePartDerivedFunctor(G,R,A,k):: Group, FreeResolution, Function, Int --> List
\end{verbatim}


 

 Inputs a group $G$, an integer $k \ge 0$, at least $k+1$ terms of a free $\mathbb ZP$-resolution of $\mathbb Z$ for $P$ a Sylow $p$-subgroup of $G$. A function such as \textsc{A=TensorWithIntegers} is also entered. The abelian invariants of the $p$-primary part $H_k(G,A)_{(p)}$ of the homology with coefficients in $A$ is returned. \\
 \index{PoincareSeries} 
\begin{verbatim}  PoincareSeries(G,n):: Group, Int --> RationalFunction
\end{verbatim}
 
\begin{verbatim}  PoincareSeries(G):: Group --> RationalFunction
\end{verbatim}
 
\begin{verbatim}  PoincareSeries(R,n):: Group, Int --> RationalFunction
\end{verbatim}
 
\begin{verbatim}  PoincareSeries(L,n):: Group, Int --> RationalFunction
\end{verbatim}


 

 Inputs a finite $p$-group $G$ and a positive integer $n$. It returns a quotient of polynomials $f(x)=P(x)/Q(x)$ whose expansion has coefficient of $x^k$ equal to the rank of the vector space $H_k(G,\mathbb F_p)$ for all $k$ in the range $1 \le k \le n$. (The second input variable can be omitted, in which case the function tries
to choose a `reasonable' value for $n$. For 2-groups the function \textsc{PoincareSeriesLHS(G)} can be used to produce an $f(x)$ that is correct in all degrees.) In place of the group $G$ the function can also input (at least $n$ terms of) a minimal mod-$p$ resolution $R$ for $G$. Alternatively, the first input variable can be a list $L$ of integers. In this case the coefficient of $x^k$ in $f(x)$ is equal to the $(k+1)$st term in the list. \\
 \index{PoincareSeries} 
\begin{verbatim}  PoincareSeries(G,n):: Group, Int --> RationalFunction
\end{verbatim}
 
\begin{verbatim}  PoincareSeries(G):: Group --> RationalFunction
\end{verbatim}
 
\begin{verbatim}  PoincareSeries(R,n):: Group, Int --> RationalFunction
\end{verbatim}
 
\begin{verbatim}  PoincareSeries(L,n):: Group, Int --> RationalFunction
\end{verbatim}


 

 Inputs a finite $p$-group $G$ and a positive integer $n$. It returns a quotient of polynomials $f(x)=P(x)/Q(x)$ whose expansion has coefficient of $x^k$ equal to the rank of the vector space $H_k(G,\mathbb F_p)$ for all $k$ in the range $1 \le k \le n$. (The second input variable can be omitted, in which case the function tries
to choose a `reasonable' value for $n$. For 2-groups the function \textsc{PoincareSeriesLHS(G)} can be used to produce an $f(x)$ that is correct in all degrees.) In place of the group $G$ the function can also input (at least $n$ terms of) a minimal mod-$p$ resolution $R$ for $G$. Alternatively, the first input variable can be a list $L$ of integers. In this case the coefficient of $x^k$ in $f(x)$ is equal to the $(k+1)$st term in the list. \\
 \index{RankHomologyPGroup} 
\begin{verbatim}  RankHomologyPGroup(G,P,n):: Group, RationalFunction, Int --> Int
\end{verbatim}


 Inputs a $p$-group $G$, a rational function $P$ representing the Poincar\texttt{\symbol{92}}'e series of the mod-$p$ cohomology of $G$ and a positive integer $n$. It returns the minimum number of generators for the finite abelian $p$-group $H_n{G,\mathbb Z)$. \\
\end{tabular}\\[2mm]
\end{center}

 $\mathbb F_p$-modules \begin{center}
\begin{tabular}{|l|} \index{GroupAlgebraAsFpGModule} 
\begin{verbatim}  GroupAlgebraAsFpGModule:: Group --> FpGModule
\end{verbatim}


 

 Inputs a finite $p$-group $G$ and returns the modular group algebra $\mathbb F_pG$ in the form of an $\mathbb F_pG$-module. \\
 \index{Radical} 
\begin{verbatim}  Radical:: FpGModule --> FpGModule
\end{verbatim}


 

 Inputs an $\mathbb F_pG$-module and returns its radical. \\
 \index{RadicalSeries} 
\begin{verbatim}  RadicalSeries(M):: FpGModule --> List
\end{verbatim}
 
\begin{verbatim}  RadicalSeries(R):: Resolution --> FilteredSparseChainComplex
\end{verbatim}


 

 Inputs an $\mathbb F_pG$-module $M$ and returns its radical series as a list of $\mathbb F_pG$-modules. 

 Inputs a free $\mathbb F_pG$-resolution R and returns the filtered chain complex $\cdots Rad_2(\mathbb F_pG)R \le Rad_1(\mathbb F_pG)R \le R$. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{Homological Group Theory}}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7D59694E84F10ABE}{}
{
 Cocycles \begin{center}
\begin{tabular}{|l|} \index{CcGroup} 
\begin{verbatim}  CcGroup(N,f):: GOuterGroup, StandardCocycle --> CcGroup
\end{verbatim}


 Inputs a $G$-outer group $N$ with nonabelian cocycle describing some extension $N \rightarrowtail E \twoheadrightarrow G$ together with standard 2-cocycle $f\colon G \times G \rightarrow A$ where $A=Z(N)$. It returns the extension group determined by the cocycle $f$. The group is returned as a cocyclic group. 

 This function is part of the HAPcocyclic package of functions implemented by
Robert F. Morse. \\
 \index{CocycleCondition} 
\begin{verbatim}  CocycleCondition(R,n):: FreeRes, Int --> IntMat
\end{verbatim}


 Inputs a free $\mathbb ZG$-resolution $R$ of $\mathbb Z$ and an integer $n \ge 1$. It returns an integer matrix $M$ with the following property. Let $d$ be the $\mathbb ZG$-rank of $R_n$. An integer vector $f=[f_1, ... , f_d]$ then represents a $\mathbb ZG$-homomorphism $R_n \rightarrow \mathbb Z_q$ which sends the $i$th generator of $R_n$ to the integer $f_i$ in the trivial $\mathbb ZG$-module $\mathbb Z_q=\mathbb Z/q{\mathbb Z}$ (where possibly $q=0$). The homomorphism $f$ is a cocycle if and only if $M^tf=0$ mod $q$. \\
 \index{StandardCocycle} 
\begin{verbatim}  StandardCocycle(R,f,n):: FreeRes, List, Int --> Function
\end{verbatim}
 
\begin{verbatim}  StandardCocycle(R,f,n,q):: FreeRes, List, Int --> Function
\end{verbatim}


 Inputs a free $\mathbb ZG$-resolution $R$ (with contracting homotopy), a positive integer $n$ and an integer vector $f$ representing an $n$-cocycle $R_n \rightarrow \mathbb Z_q=\mathbb Z/q\mathbb Z$ where $G$ acts trivially on $\mathbb Z_q$. It is assumed $q=0$ unless a value for $q$ is entered. The command returns a function $F(g_1, ..., g_n)$ which is the standard cocycle $G^n \rightarrow \mathbb Z_q$ corresponding to $f$. At present the command is implemented only for $n=2$ or $3$. \\
\end{tabular}\\[2mm]
\end{center}

 G-Outer Groups \begin{center}
\begin{tabular}{|l|} \index{ActedGRoup} 
\begin{verbatim}  ActedGroup(M):: GOuterGroup --> Group
\end{verbatim}


 

 Inputs a $G$-outer group $M$ corresponding to a homomorphism $\alpha\colon G\rightarrow {\rm Out}(N)$ and returns the group \$N\$. \\
 \index{ActingGRoup} 
\begin{verbatim}  ActingGroup(M):: GOuterGroup --> Group
\end{verbatim}


 

 Inputs a $G$-outer group $M$ corresponding to a homomorphism $\alpha\colon G\rightarrow {\rm Out}(N)$ and returns the group \$G\$. \\
 \index{Centre} 
\begin{verbatim}  Centre(M):: GOuterGroup --> GOuterGroup
\end{verbatim}


 

 Inputs a $G$-outer group $M$ and returns its group-theoretic centre as a $G$-outer group. \\
 \index{GOuterGroup} 
\begin{verbatim}  GOuterGroup(E,N):: Group, Subgroup --> GOuterGroup
\end{verbatim}
 
\begin{verbatim}  GOuterGroup():: Group, Subgroup --> GOuterGroup
\end{verbatim}


 

 Inputs a group $E$ and normal subgroup $N$. It returns $N$ as a $G$-outer group where $G=E/N$. A nonabelian cocycle $f\colon G\times G\rightarrow N$ is attached as a component of the $G$-Outer group. 

 The function can be used without an argument. In this case an empty outer
group $C$ is returned. The components must be set using \textsc{SetActingGroup(C,G)}, \textsc{SetActedGroup(C,N)} and \textsc{SetOuterAction(C,alpha)}. \\
\end{tabular}\\[2mm]
\end{center}

 $G$-cocomplexes \begin{center}
\begin{tabular}{|l|} \index{CohomologyModule} 
\begin{verbatim}  CohomologyModule(C,n):: GCocomplex, Int --> GOuterGroup
\end{verbatim}


 

 Inputs a $G$-cocomplex $C$ together with a non-negative integer $n$. It returns the cohomology $H^n(C)$ as a $G$-outer group. If $C$ was constructed from a $\mathbb ZG$-resolution $R$ by homing to an abelian $G$-outer group $A$ then, for each $x$ in $H:=CohomologyModule(C,n)$, there is a function $f:=H!.representativeCocycle(x)$ which is a standard $n$-cocycle corresponding to the cohomology class $x$. (At present this is implemented only for $n=1,2,3$.) \\
 \index{HomToGModule} 
\begin{verbatim}  HomToGModule(R,A):: FreeRes, GOuterGroup --> GCocomplex
\end{verbatim}


 

 Inputs a $\mathbb ZG$-resolution $R$ and an abelian $G$-outer group $A$. It returns the $G$-cocomplex obtained by applying $HomZG( \_ , A)$. (At present this function does not handle equivariant chain maps.) \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{Resolutions of the ground ring}}\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X8735FC5E7BB5CE3A}{}
{
 \\
 \\
 \\
 \index{TietzeReducedResolution}::::::::::::::::::::::::\\
 \texttt{TietzeReducedResolution(R)}\\
 

 Inputs a $\mathbb ZG$-resolution $R$ and returns a $\mathbb ZG$-resolution $S$ which is obtained from $R$ by applying "Tietze like operations" in each dimension. The hope is that $S$ has fewer free generators than $R$. \\
 \\
 \\
 \\
 \index{ResolutionArithmeticGroup}::::::::::::::::::::::::\\
 \texttt{ResolutionArithmeticGroup("PSL(4,Z)",n)}\\
 

 Inputs a positive integer $n$ and one of the following strings: \\
\\
 "SL(2,Z)" , "SL(3,Z)" , "PGL(3,Z[i])" ,
"PGL(3,Eisenstein{\textunderscore}Integers)" , "PSL(4,Z)" ,
"PSL(4,Z){\textunderscore}b" , "PSL(4,Z){\textunderscore}c" ,
"PSL(4,Z){\textunderscore}d" , "Sp(4,Z)" \\
\\
 or the string \\
\\
 "GL(2,O(-d))" \\
\\
 for d=1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 43 \\
\\
 or the string \\
\\
 "SL(2,O(-d))" \\
\\
 for d=2, 3, 5, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 43, 67, 163 \\
\\
 or the string \\
\\
 "SL(2,O(-d)){\textunderscore}a" \\
\\
 for d=2, 7, 11, 19. \\
\\
 It returns $n$ terms of a free ZG-resolution for the group $G$ described by the string. Here O(-d) denotes the ring of integers of
Q(sqrt(-d)) and subscripts {\textunderscore}a, {\textunderscore}b ,
{\textunderscore}c , {\textunderscore}d denote alternative non-free
ZG-resolutions for a given group G.\\
\\
 Data for the first list of resolutions was provided provided by \textsc{Mathieu Dutour}. Data for GL(2,O(-d)) was provided by \textsc{Sebastian Schoenennbeck}. Data for SL(2,O(-d)) was provided by\textsc{Sebastian Schoennenbeck} for d {\textless}= 26 and by \textsc{Alexander Rahm} for d{\textgreater}26 and for the alternative complexes.\\
 \\
 \\
 \\
 \index{FreeGResolution}::::::::::::::::::::::::\\
 \texttt{FreeGResolution(P,n)}\\
 \texttt{FreeGResolution(P,n,p)}\\
 

 Inputs a non-free $ZG$-resolution $P$ with finite stabilizer groups, and a positive integer $n$. It returns a free $ZG$-resolution of length equal to the minimum of n and the length of $P$. If one requires only a mod $p$ resolution then the prime $p$ can be entered as an optional third argument. 

 The free resolution is returned without a contracting homotopy. \\
 \\
 \\
 \\
 \index{ResolutionGTree}::::::::::::::::::::::::\\
 \texttt{ResolutionGTree(P,n)}\\
 

 Inputs a non-free $ZG$-resolution $P$ of dimension 1 (i.e. a G-tree) with finite stabilizer groups, and a positive
integer $n$. It returns a free $ZG$-resolution of length equal to n. 

 If $P$ has a contracting homotopy then the free resolution is returned with a
contracting homotopy. 

 This function was written by \textsc{ Bui Anh Tuan}. \\
 \\
 \\
 \\
 \index{ResolutionSL2Z}::::::::::::::::::::::::\\
 \texttt{ResolutionSL2Z(p,n)}\\
 

 Inputs positive integers $m, n$ and returns $n$ terms of a $ZG$-resolution for the group $G=SL(2,Z[1/m])$ . 

 

 This function is joint work with \textsc{Bui Anh Tuan}. \\
 \\
 \\
 \\
 \index{ResolutionAbelianGroup}::::::::::::::::::::::::\\
 \texttt{ResolutionAbelianGroup(L,n)}\\
 \texttt{ResolutionAbelianGroup(G,n)}\\
 

 Inputs a list $L:=[m_1,m_2, ..., m_d]$ of nonnegative integers, and a positive integer $n$. It returns $n$ terms of a ${\mathbb Z}G$-resolution for the abelian group $G=Z_{L[1]}+Z_{L[2]}+{\textperiodcentered}{\textperiodcentered}{\textperiodcentered}+{Z_L[d]}$ . 

 If $G$ is finite then the first argument can also be the abelian group $G$ itself. \\
 \\
 \\
 \\
 \index{ResolutionAlmostCrystalGroup}::::::::::::::::::::::::\\
 \texttt{ResolutionAlmostCrystalGroup(G,n)}\\
 

 Inputs a positive integer $n$ and an almost crystallographic pcp group $G$. It returns $n$ terms of a free $ZG$-resolution. (A group is almost crystallographic if it is nilpotent-by-finite
and has no non-trivial finite normal subgroup. Such groups can be constructed
using the ACLIB package.) \\
 \\
 \\
 \\
 \index{ResolutionAlmostCrystalQuotient}::::::::::::::::::::::::\\
 \texttt{ResolutionAlmostCrystalQuotient(G,n,c)}\\
 \texttt{ResolutionAlmostCrystalQuotient(G,n,c,false)}\\
 

 An almost crystallographic group $G$ is an extension of a finite group $P$ by a nilpotent group $T$, and has no non-trivial finite normal subgroup. We define the relative lower
central series by setting $T_1=T$ and $T_{i+1}=[T_i,G]$.

 This function inputs an almost crystallographic group $G$ together with positive integers $n$ and $c$. It returns $n$ terms of a free $ZQ$-resolution $R$ for the group $Q=G/T_c$ .

 In addition to the usual components, the resolution $R$ has the component $R.quotientHomomorphism$ which gives the quotient homomorphism $G \longrightarrow Q $.

 If a fourth optional variable is set equal to "false" then the function omits
to test whether $Q$ is finite and a "more canonical" resolution is constructed. \\
 \\
 \\
 \\
 \index{ResolutionArtinGroup}::::::::::::::::::::::::\\
 \texttt{ResolutionArtinGroup(D,n)}\\
 

 Inputs a Coxeter diagram $D$ and an integer $n>1$. It returns $n$ terms of a free $ZG$-resolution $R$ where $G$ is the Artin monoid associated to $D$. It is conjectured that $R$ is also a free resolution for the Artin group $G$. The conjecture is known to hold in \href{../www/SideLinks/About/aboutArtinGroups.html} {certain cases}.

 $G=R.group$ is infinite and returned as a finitely presented group. The list $R.elts$ is a partial listing of the elements of $G$ which grows as $R$ is used. Initially $R.elts$ is empty and then, any time the boundary of a resolution generator is called, $R.elts$ is updated to include elements of $G$ involved in the boundary.

 The contracting homotopy on $R$ has not yet been implemented! Furthermore, the group $G$ is currently returned only as a finitely presented group (without any method
for solving the word problem). \\
 \\
 \\
 \\
 \index{ResolutionAsphericalPresentation}::::::::::::::::::::::::\\
 \texttt{ResolutionAsphericalPresentation(F,R,n)}\\
 

 Inputs a free group $F$, a set $R$ of words in $F$ which constitute an aspherical presentation for a group $G$, and a positive integer $n$. (Asphericity can be a difficult property to verify. The function $IsAspherical(F,R)$ could be of help.)

 The function returns n terms of a free $ZG$-resolution $R$ which has generators in dimensions {\textless} 3 only. No contracting homotopy
on $R$ will be returned. \\
 \\
 \\
 \\
 \index{ResolutionBieberbachGroup (HAPcryst)}::::::::::::::::::::::::\\
 \texttt{ResolutionBieberbachGroup( G ) }\\
 \texttt{ResolutionBieberbachGroup( G, v ) }\\
 

 Inputs a torsion free crystallographic group $G$, also known as a Bieberbach group, represented using AffineCrystGroupOnRight
as in the GAP package Cryst. It also optionally inputs a choice of vector $v$ in the euclidean space $R^n$ on which $G$ acts freely. The function returns $n+1$ terms of the free $ZG$-resolution of $Z$ arising as the cellular chain complex of the tesselation of $R^n$ by the Dirichlet-Voronoi fundamental domain determined by $v$. 

 This function is part of the HAPcryst package written by \textsc{Marc Roeder} and thus requires the HAPcryst package to be loaded. 

 The function requires the use of Polymake software. \\
 \\
 \\
 \\
 \index{ResolutionCoxeterGroup}::::::::::::::::::::::::\\
 \texttt{ResolutionCoxeterGroup(D,n)}\\
 

 Inputs a Coxeter diagram $D$ and an integer $n>1$. It returns $k$ terms of a free $ZG$-resolution $R$ where $G$ is the Coxeter group associated to $D$. Here $k$ is the maximum of n and the number of vertices in the Coxeter diagram. At
present the implementation is only for finite Coxeter groups and the group $G$ is returned as a permutation group. The contracting homotopy on $R$ has not yet been implemented! \\
 \\
 \\
 \\
 \index{ResolutionDirectProduct}::::::::::::::::::::::::\\
 \texttt{ResolutionDirectProduct(R,S) }\\
 \texttt{ResolutionDirectProduct(R,S,"internal")}\\
 

 Inputs a $ZG$-resolution $R$ and $ZH$-resolution $S$. It outputs a $ZD$-resolution for the direct product $D=G x H$.

 If $G$ and $H$ lie in a common group $K$, and if they commute and have trivial intersection, then an optional third
variable "internal" can be used. This will force $D$ to be the subgroup $GH$ in $K$. \\
 \\
 \\
 \\
 \index{ResolutionExtension}::::::::::::::::::::::::\\
 \texttt{ResolutionExtension(g,R,S) }\\
 \texttt{ResolutionExtension(g,R, S,"TestFiniteness")}\\
 \texttt{ResolutionExtension(g,R,S,"NoTest",GmapE)}\\
 

 Inputs a surjective group homomorphism $g:E \longrightarrow G$ with kernel $N$. It also inputs a $ZN$-resolution $R$ and a $ZG$-resolution $S$. It returns a $ZE$-resolution. The groups $E$ and $G$ can be infinite.

 If an optional fourth argument is set equal to "TestFiniteness" then the
groups $N$ and $G$ will be tested to see if they are finite. If they are finite then some speed
saving routines will be invoked.

 If the homomorphism $g$ is such that the GAP function $PreImagesElement(g,x)$ doesn't work, then a function $GmapE()$ should be included as a fifth input. For any $x$ in $G$ this function should return an element $GmapE(x)$ in $E$ which gets mapped onto $x$ by $g$.

 The contracting homotopy on the $ZE$-resolution has not yet been fully implemented for infinite groups! \\
 \\
 \\
 \\
 \index{ResolutionFiniteDirectProduct}::::::::::::::::::::::::\\
 \texttt{ResolutionFiniteDirectProduct(R,S) }\\
 \texttt{ResolutionFiniteDirectProduct(R,S, "internal")}\\
 

 Inputs a $ZG$-resolution $R$ and $ZH$-resolution $S$ where $G$ and $H$ are finite groups. It outputs a $ZD$-resolution for the direct product $D=G{\ensuremath{\times}}H$.

 If $G$ and $H$ lie in a common group $K$, and if they commute and have trivial intersection, then an optional third
variable "internal" can be used. This will force $D$ to be the subgroup $GH$ in $K$. \\
 \\
 \\
 \\
 \index{ResolutionFiniteExtension}::::::::::::::::::::::::\\
 \texttt{ResolutionFiniteExtension(gensE,gensG,R,n)}\\
 \texttt{ResolutionFiniteExtension(gensE,gensG,R,n,true) }\\
 \texttt{ResolutionFiniteExtension(gensE,gensG,R,n,false,S) }\\
 

 Inputs: a set $gensE$ of generators for a finite group $E$; a set $gensG$ equal to the image of $gensE$ in a quotient group $G$ of $E$; a $ZG$-resolution $R$ up to dimension at least $n$; a positive integer $n$. It uses the $TwistedTensorProduct()$ construction to return $n$ terms of a $ZE$-resolution.

 The function has an optional fourth argument which, when set equal to "true",
invokes tietze reductions in the construction of a resolution for the kernel
of $E \longrightarrow G$.

 If a $ZN$-resolution $S$ is available, where $N$ is the kernel of the quotient $E \longrightarrow G$, then this can be incorporated into the computations using an optional fifth
argument. \\
 \\
 \\
 \\
 \index{ResolutionFiniteGroup}::::::::::::::::::::::::\\
 \texttt{ResolutionFiniteGroup(gens,n)}\\
 \texttt{ResolutionFiniteGroup(gens,n,true)}\\
 \texttt{ResolutionFiniteGroup(gens,n,false,p) }\\
 \texttt{ResolutionFiniteGroup(gens,n,false,0,"extendible") }\\
 

 Inputs a set $gens$ of generators for a finite group $G$ and a positive integer $n$. It outputs $n$ terms of a $ZG$-resolution.

 The function has an optional third argument which, when set equal to $true$, invokes tietze reductions in the construction of the resolution. 

 The function has an optional fourth argument which, when set equal to a prime $p$, records the fact that the resolution will only be used for mod $p$ calculations. This could speed up subsequent constructions. 

 The function has an optional fifth argument which, when set equal to
"extendible", returns a resolution whose length can be increased using the
command R!.extend() . \\
\\
 \\
 \\
 \index{ResolutionFiniteSubgroup}::::::::::::::::::::::::\\
 \texttt{ResolutionFiniteSubgroup(R,K)}\\
 \texttt{ResolutionFiniteSubgroup(R,gensG,gensK)}\\
 

 Inputs a $ZG$-resolution for a finite group $G$ and a subgroup $K$ of index $|G:K|$. It returns a free $ZK$-resolution whose $ZK$-rank is $|G:K|$ times the $ZG$-rank in each dimension.

 Generating sets $gensG$, $gensK$ for $G$ and $K$ can also be input to the function (though the method does not depend on a
choice of generators).

 This $ZK$-resolution is not reduced. ie. it has more than one generator in dimension $0$. \\
 \\
 \\
 \\
 \index{ResolutionGraphOfGroups}::::::::::::::::::::::::\\
 \texttt{ResolutionGraphOfGroups(D,n) }\\
 \texttt{ResolutionGraphOfGroups(D,n,L) }\\
 

 Inputs a graph of groups $D$ and a positive integer $n$. It returns $n$ terms of a free $ZG$-resolution for the fundamental group $G$ of $D$.

 An optional third argument $L=[R_1 , \ldots , R_t]$ can be used to list (in any order) free resolutions for some/all of the vertex
and edge groups in $D$. If for some vertex or edge group no resolution is listed in $L$ then the function $ResolutionFiniteGroup()$ will be used to try to construct the resolution. 

 The $ZG$-resolution is usually not reduced. i.e. it has more than one generator in
dimension 0.

 The contracting homotopy on the $ZG$-resolution has not yet been implemented! Furthermore, the group $G$ is currently returned only as a finitely presented group (without any method
for solving the word problem). \\
 \\
 \\
 \\
 \index{ResolutionNilpotentGroup}::::::::::::::::::::::::\\
 \texttt{ResolutionNilpotentGroup(G,n) }\\
 \texttt{ResolutionNilpotentGroup(G,n,"TestFiniteness")}\\
 

 Inputs a nilpotent group $G$ and positive integer $n$. It returns $n$ terms of a free $ZG$-resolution. The resolution is computed using a divide-and-conquer technique
involving the lower central series.

 This function can be applied to infinite groups $G$. For finite groups the function $ResolutionNormalSeries()$ probably gives better results.

 If an optional third argument is set equal to "TestFiniteness" then the groups $N$ and $G$ will be tested to see if they are finite. If they are finite then some speed
saving routines will be invoked.

 The contracting homotopy on the $ZE$-resolution has not yet been fully implemented for infinite groups. \\
 \\
 \\
 \\
 \index{ResolutionNormalSeries}::::::::::::::::::::::::\\
 \texttt{ResolutionNormalSeries(L,n) }\\
 \texttt{ResolutionNormalSeries(L,n,true)}\\
 \texttt{ResolutionNormalSeries(L,n,false,p)}\\
 

 Inputs a positive integer $n$ and a list $L = [L_1 , ..., L_k]$ of normal subgroups $L_i$ of a finite group $G$ satisfying $G = L_1$ {\textgreater} $L2$ {\textgreater}$ \ldots $ {\textgreater}$ L_k$. Alternatively, $L = [gensL_1, ... gensL_k]$ can be a list of generating sets for the $L_i$ (and these particular generators will be used in the construction of
resolutions). It returns a $ZG$-resolution by repeatedly using the function $ResolutionFiniteExtension()$.

 The function has an optional third argument which, if set equal to true,
invokes tietze reductions in the construction of resolutions.

 The function has an optional fourth argument which, if set equal to p
{\textgreater} 0, produces a resolution which is only valid for mod $p$ calculations. \\
 \\
 \\
 \\
 \index{ResolutionPrimePowerGroup}::::::::::::::::::::::::\\
 \texttt{ResolutionPrimePowerGroup(P,n) }\\
 \texttt{ResolutionPrimePowerGroup(G,n,p)}\\
 

 Inputs a $p$-group $P$ and integer $n${\textgreater}$0$. It uses GAP's standard linear algebra functions over the field $F$ of p elements to construct a free $FP$-resolution for mod $p$ calculations only. The resolution is minimal - meaning that the number of
generators of $R_n$ equals the rank of $H_n(P,F)$. 

 The function can also be used to obtain a free non-minimal $FG$-resolution of a small group $G$ of non-prime-power order. In this case the prime $p$ must be entered as the third input variable. (In the non-prime-power case the
algorithm is naive and not very good.) \\
 \\
 \\
 \\
 \index{ResolutionSmallFpGroup}::::::::::::::::::::::::\\
 \texttt{ResolutionSmallFpGroup(G,n) }\\
 \texttt{ResolutionSmallFpGroup(G,n,p) }\\
 

 Inputs a small finitely presented group $G$ and an integer $n${\textgreater}$0$. It returns $n$ terms of a $ZG$-resolution which, in dimensions 1 and 2, corresponds to the given
presentation for $G$. The method returns no contracting homotopy for the resolution.

 The function has an optional fourth argument which, when set equal to a prime $p$, records the fact that the resolution will only be used for mod $p$ calculations. This could speed up subsequent constructions. 

 This function was written by Irina Kholodna. \\
 \\
 \\
 \\
 \index{ResolutionSubgroup}::::::::::::::::::::::::\\
 \texttt{ResolutionSubgroup(R,K)}\\
 

 Inputs a $ZG$-resolution for an (infinite) group $G$ and a subgroup $K$ of finite index $|G:K|$. It returns a free $ZK$-resolution whose $ZK$-rank is $|G:K|$ times the $ZG$-rank in each dimension.

 If $G$ is finite then the function $ResolutionFiniteSubgroup(R,G,K)$ will probably work better. In particular, resolutions from this function
probably won't work with the function $EquivariantChainMap()$. This $ZK$-resolution is not reduced. i.e. it has more than one generator in dimension
0. \\
 \\
 \\
 \\
 \index{ResolutionSubnormalSeries}::::::::::::::::::::::::\\
 \texttt{ResolutionSubnormalSeries(L,n) }\\
 

 Inputs a positive integer n and a list $L = [L_1 , \ldots , L_k]$ of subgroups $L_i$ of a finite group $G=L_1$ such that $L_1$ {\textgreater} $L2 \ldots $ {\textgreater} $L_k$ is a subnormal series in $G$ (meaning that each $L_{i+1}$ must be normal in $L_i$). It returns a $ZG$-resolution by repeatedly using the function $ResolutionFiniteExtension()$.

 If $L$ is a series of normal subgroups in $G$ then the function $ResolutionNormalSeries(L,n)$ will possibly work more efficiently. \\
 \\
 \\
 \\
 \index{TwistedTensorProduct}::::::::::::::::::::::::\\
 \texttt{TwistedTensorProduct(R,S,EhomG,GmapE,NhomE,NEhomN,EltsE,Mult,InvE)}\\
 

 Inputs a $ZG$-resolution $R$, a $ZN$-resolution $S$, and other data relating to a short exact sequence $1 \longrightarrow N \longrightarrow E \longrightarrow G \longrightarrow 1$. It uses a perturbation technique of CTC Wall to construct a $ZE$-resolution $F$. Both $G$ and $N$ could be infinite. The "length" of $F$ is equal to the minimum of the "length"s of $R$ and $S$. The resolution $R$ needs no contracting homotopy if no such homotopy is requied for $F$. \\
 \\
 \\
 \\
 \index{ConjugatedResolution}::::::::::::::::::::::::\\
 \texttt{ConjugatedResolution(R,x)}\\
 

 Inputs a ZG-resoluton $R$ and an element $x$ from some group containing $G$. It returns a $ZG^x$-resolution $S$ where the group $G^x$ is the conjugate of $G$ by $x$. (The component $S!.elts$ will be a pseudolist rather than a list.) \\
 \\
 \\
 \\
 \index{RecalculateIncidenceNumbers}::::::::::::::::::::::::\\
 \texttt{RecalculateIncidenceNumbers(R)}\\
 

 Inputs a ZG-resoluton $R$ which arises as the cellular chain complex of a regular CW-complex. (Thus the
boundary of any cell is a list of distinct cells.) It recalculates the
incidence numbers for $R$. If it is applied to a resolution that is not regular then a wrong answer may
be returned. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Resolutions of modules}}\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X841673BA782D0D1D}{}
{
 \\
 \\
 \\
 \index{ResolutionFpGModule}::::::::::::::::::::::::\\
 \texttt{ResolutionFpGModule(M,n)}\\
 

 Inputs an $FpG$-module $M$ and a positive integer $n$. It returns $n$ terms of a minimal free $FG$-resolution of the module $M$ (where $G$ is a finite group and $F$ the field of $p$ elements). \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Induced equivariant chain maps}}\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X7E91068780486C3A}{}
{
 \\
 \\
 \\
 \index{EquivariantChainMap}::::::::::::::::::::::::\\
 \texttt{EquivariantChainMap(R,S,f)}\\
 

 Inputs a $ZG$-resolution $R$, a $ZG'$-resolution $S$, and a group homomorphism $f : G \longrightarrow G'$. It outputs a component object $M$ with the following components. 

 \\
 \\
 $M!.source$ is the resolution $R$.\\
 \\
 $M!.target$ is the resolution $S$.\\
 \\
$M!.mapping(w,n)$ is a function which gives the image in $S_n$, under a chain map induced by $f$, of a word $w$ in $R_n$. (Here $R_n$ and $S_n$ are the $n$-th modules in the resolutions $R$ and $S$.)\\
 \\
 $F!.properties$ is a list of pairs such as ["type", "equivariantChainMap"].\\
 \\
 

 The resolution $S$ must have a contracting homotopy. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Functors}}\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X78D1062D78BE08C1}{}
{
 \\
 \\
 \\
 \index{ExtendScalars}::::::::::::::::::::::::\\
 \texttt{ExtendScalars(R,G,EltsG)}\\
 

 Inputs a $ZH$-resolution $R$, a group $G$ containing $H$ as a subgroup, and a list $EltsG$ of elements of $G$. It returns the free $ZG$-resolution $(R \otimes_{ZH} ZG)$. The returned resolution $S$ has S!.elts:=EltsG. This is a resolution of the $ZG$-module $(Z \otimes_{ZH} ZG)$. (Here $\otimes_{ZH}$ means tensor over $ZH$.) \\
 \\
 \\
 \\
 \index{HomToIntegers}::::::::::::::::::::::::\\
 \texttt{HomToIntegers(X) }\\
 

 Inputs either a $ZG$-resolution $X=R$, or an equivariant chain map $X = (F:R \longrightarrow S)$. It returns the cochain complex or cochain map obtained by applying $HomZG( _ , Z)$ where $Z$ is the trivial module of integers (characteristic 0). \\
 \\
 \\
 \\
 \index{HomToIntegersModP}::::::::::::::::::::::::\\
 \texttt{HomToIntegersModP(R) }\\
 

 Inputs a $ZG$-resolution $R$ and returns the cochain complex obtained by applying $HomZG( _ , Z_p)$ where $Z_p$ is the trivial module of integers mod $p$. (At present this functor does not handle equivariant chain maps.) \\
 \\
 \\
 \\
 \index{HomToIntegralModule}::::::::::::::::::::::::\\
 \texttt{HomToIntegralModule(R,f) }\\
 

 Inputs a $ZG$-resolution $R$ and a group homomorphism $f:G \longrightarrow GL_n(Z)$ to the group of $n{\ensuremath{\times}}n$ invertible integer matrices. Here $Z$ must have characteristic 0. It returns the cochain complex obtained by
applying $HomZG( _ , A)$ where $A$ is the $ZG$-module $Z^n$ with $G$ action via $f$. (At present this function does not handle equivariant chain maps.) \\
 \\
 \\
 \\
 \index{TensorWithIntegralModule}::::::::::::::::::::::::\\
 \texttt{TensorWithIntegralModule(R,f) }\\
 

 Inputs a $ZG$-resolution $R$ and a group homomorphism $f:G \longrightarrow GL_n(Z)$ to the group of $n{\ensuremath{\times}}n$ invertible integer matrices. Here $Z$ must have characteristic 0. It returns the chain complex obtained by tensoring
over $ZG$ with the $ZG$-module $A=Z^n$ with $G$ action via $f$. (At present this function does not handle equivariant chain maps.) \\
 \\
 \\
 \\
 \index{HomToGModule}::::::::::::::::::::::::\\
 \texttt{HomToGModule(R,A) }\\
 

 Inputs a $ZG$-resolution $R$ and an abelian G-outer group A. It returns the G-cocomplex obtained by
applying $HomZG( _ , A)$. (At present this function does not handle equivariant chain maps.) \\
 \\
 \\
 \\
 \index{InduceScalars}::::::::::::::::::::::::\\
 \texttt{InduceScalars(R,hom) }\\
 

 Inputs a $ZQ$-resolution $R$ and a surjective group homomorphism $hom:G\rightarrow Q$. It returns the unduced non-free $ZG$-resolution. \\
 \\
 \\
 \\
 \index{LowerCentralSeriesLieAlgebra}::::::::::::::::::::::::\\
 \texttt{LowerCentralSeriesLieAlgebra(G) }\\
 \texttt{LowerCentralSeriesLieAlgebra(f) }\\
 

 Inputs a pcp group $G$. If each quotient $G_c/G_{c+1}$ of the lower central series is free abelian or p-elementary abelian (for fixed
prime p) then a Lie algebra $L(G)$ is returned. The abelian group underlying $L(G)$ is the direct sum of the quotients $G_c/G_{c+1}$ . The Lie bracket on $L(G)$ is induced by the commutator in $G$. (Here $G_1=G$, $G_{c+1}=[G_c,G]$ .) 

 The function can also be applied to a group homomorphism $f: G \longrightarrow G'$ . In this case the induced homomorphism of Lie algebras $L(f):L(G) \longrightarrow L(G')$ is returned.

 If the quotients of the lower central series are not all free or p-elementary
abelian then the function returns fail.

 This function was written by Pablo Fernandez Ascariz \\
 \\
 \\
 \\
 \index{TensorWithIntegers}::::::::::::::::::::::::\\
 \texttt{TensorWithIntegers(X) }\\
 

 Inputs either a $ZG$-resolution $X=R$, or an equivariant chain map $X = (F:R \longrightarrow S)$. It returns the chain complex or chain map obtained by tensoring with the
trivial module of integers (characteristic 0). \\
 \\
 \\
 \\
 \index{FilteredTensorWithIntegers}::::::::::::::::::::::::\\
 \texttt{FilteredTensorWithIntegers(R) }\\
 

 Inputs a $ZG$-resolution $R$ for which "filteredDimension" lies in NamesOfComponents(R). (Such a resolution
can be produced using TwisterTensorProduct(), ResolutionNormalSubgroups() or
FreeGResolution().) It returns the filtered chain complex obtained by
tensoring with the trivial module of integers (characteristic 0). \\
 \\
 \\
 \\
 \index{TensorWithTwistedIntegers}::::::::::::::::::::::::\\
 \texttt{TensorWithTwistedIntegers(X,rho) }\\
 

 Inputs either a $ZG$-resolution $X=R$, or an equivariant chain map $X = (F:R \longrightarrow S)$. It also inputs a function $rho\colon G\rightarrow \mathbb Z$ where the action of $g \in G$ on $\mathbb Z$ is such that $g.1 = rho(g)$. It returns the chain complex or chain map obtained by tensoring with the
(twisted) module of integers (characteristic 0). \\
 \\
 \\
 \\
 \index{TensorWithIntegersModP}::::::::::::::::::::::::\\
 \texttt{TensorWithIntegersModP(X,p) }\\
 

 Inputs either a $ZG$-resolution $X=R$, or a characteristics 0 chain complex, or an equivariant chain map $X = (F:R \longrightarrow S)$, or a chain map between characteristic 0 chain complexes, together with a
prime $p$. It returns the chain complex or chain map obtained by tensoring with the
trivial module of integers modulo $p$. \\
 \\
 \\
 \\
 \index{TensorWithTwistedIntegersModP}::::::::::::::::::::::::\\
 \texttt{TensorWithTwistedIntegersModP(X,p,rho)}\\
 

 Inputs either a $ZG$-resolution $X=R$, or an equivariant chain map $X = (F:R \longrightarrow S)$, and a prime $p$. It also inputs a function $rho\colon G\rightarrow \mathbb Z$ where the action of $g \in G$ on $\mathbb Z$ is such that $g.1 = rho(g)$. It returns the chain complex or chain map obtained by tensoring with the
trivial module of integers modulo $p$. \\
 \\
 \\
 \\
 \index{TensorWithRationals}::::::::::::::::::::::::\\
 \texttt{TensorWithRationals(R)}\\
 

 Inputs a $ZG$-resolution $R$ and returns the chain complex obtained by tensoring with the trivial module of
rational numbers. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Chain complexes}}\logpage{[ 8, 0, 0 ]}
\hyperdef{L}{X7A06103979B92808}{}
{
 \\
 \\
 \\
 \index{ChainComplex}::::::::::::::::::::::::\\
 \texttt{ChainComplex(T)}\\
 

 Inputs a pure cubical complex, or cubical complex, or simplicial complex $T$ and returns the (often very large) cellular chain complex of $T$. \\
 \\
 \\
 \\
 \index{ChainComplexOfPair}::::::::::::::::::::::::\\
 \texttt{ChainComplexOfPair(T,S)}\\
 

 Inputs a pure cubical complex or cubical complex $T$ and contractible subcomplex $S$. It returns the quotient $C(T)/C(S)$ of cellular chain complexes. \\
 \\
 \\
 \\
 \index{ChevalleyEilenbergComplex}::::::::::::::::::::::::\\
 \texttt{ ChevalleyEilenbergComplex(X,n) }\\
 

 Inputs either a Lie algebra $X=A$ (over the ring of integers $Z$ or over a field $K$) or a homomorphism of Lie algebras $X=(f:A \longrightarrow B)$, together with a positive integer $n$. It returns either the first $n$ terms of the Chevalley-Eilenberg chain complex $C(A)$, or the induced map of Chevalley-Eilenberg complexes $C(f):C(A) \longrightarrow C(B)$. 

 (The homology of the Chevalley-Eilenberg complex $C(A)$ is by definition the homology of the Lie algebra $A$ with trivial coefficients in $Z$ or $K$). 

 This function was written by \textsc{Pablo Fernandez Ascariz} \\
 \\
 \\
 \\
 \index{LeibnizComplex}::::::::::::::::::::::::\\
 \texttt{ LeibnizComplex(X,n) }\\
 

 Inputs either a Lie or Leibniz algebra $X=A$ (over the ring of integers $Z$ or over a field $K$) or a homomorphism of Lie or Leibniz algebras $X=(f:A \longrightarrow B)$, together with a positive integer $n$. It returns either the first $n$ terms of the Leibniz chain complex $C(A)$, or the induced map of Leibniz complexes $C(f):C(A) \longrightarrow C(B)$. 

 (The Leibniz complex $C(A)$ was defined by J.-L.Loday. Its homology is by definition the Leibniz homology
of the algebra $A$). 

 This function was written by \textsc{Pablo Fernandez Ascariz} \\
 \\
 \\
 \\
 \index{SuspendedChainComplex}::::::::::::::::::::::::\\
 \texttt{SuspendedChainComplex(C)}\\
 

 Inputs a chain complex $C$ and returns the chain complex $S$ defined by applying the degree shift $S_n = C_{n-1}$ to chain groups and boundary homomorphisms. \\
 \\
 \\
 \\
 \index{ReducedSuspendedChainComplex}::::::::::::::::::::::::\\
 \texttt{ReducedSuspendedChainComplex(C)}\\
 

 Inputs a chain complex $C$ and returns the chain complex $S$ defined by applying the degree shift $S_n = C_{n-1}$ to chain groups and boundary homomorphisms for all $n > 0$. The chain complex $S$ has trivial homology in degree $0$ and $S_0=\mathbb Z$. \\
 \\
 \\
 \\
 \index{CoreducedChainComplex}::::::::::::::::::::::::\\
 \texttt{CoreducedChainComplex(C)}\\
 \texttt{CoreducedChainComplex(C,2)}\\
 

 Inputs a chain complex $C$ and returns a quasi-isomorphic chain complex $D$. In many cases the complex $D$ should be smaller than $C$. If an optional second input argument is set equal to 2 then an alternative
method is used for reducing the size of the chain complex. \\
 \\
 \\
 \\
 \index{TensorProductOfChainComplexes}::::::::::::::::::::::::\\
 \texttt{TensorProductOfChainComplexes(C,D)}\\
 

 Inputs two chain complexes $C$ and $D$ of the same characteristic and returns their tensor product as a chain
complex. 

 This function was written by \textsc{ Le Van Luyen}. \\
 \\
 \\
 \\
 \index{LefschetzNumber}::::::::::::::::::::::::\\
 \texttt{LefschetzNumber(F)}\\
 

 Inputs a chain map $F\colon C\rightarrow C$ with common source and target. It returns the Lefschetz number of the map
(that is, the alternating sum of the traces of the homology maps in each
degree). \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Sparse Chain complexes}}\logpage{[ 9, 0, 0 ]}
\hyperdef{L}{X856F202D823280F8}{}
{
 \\
 \\
 \\
 \index{SparseMat}::::::::::::::::::::::::\\
 \texttt{SparseMat(A)}\\
 

 Inputs a matrix $A$ and returns the matrix in sparse format. \\
 \\
 \\
 \\
 \index{TransposeOfSparseMat}::::::::::::::::::::::::\\
 \texttt{TransposeOfSparseMat(A)}\\
 

 Inputs a sparse matrix $A$ and returns its transpose sparse format. \\
 \\
 \\
 \\
 \index{ReverseSparseMat}::::::::::::::::::::::::\\
 \texttt{ReverseSparseMat(A)}\\
 

 Inputs a sparse matrix $A$ and modifies it by reversing the order of the columns. This function modifies $A$ and returns no value. \\
 \\
 \\
 \\
 \index{SparseRowMult}::::::::::::::::::::::::\\
 \texttt{SparseRowMult(A,i,k)}\\
 

 Multiplies the i-th row of a sparse matrix $A$ by $k$. The sparse matrix $A$ is modified but nothing is returned. \\
 \\
 \\
 \\
 \index{SparseRowInterchange}::::::::::::::::::::::::\\
 \texttt{SparseRowInterchange(A,i,k)}\\
 

 Interchanges the i-th and j-th rows of a sparse matrix $A$ by $k$. The sparse matrix $A$ is modified but nothing is returned. \\
 \\
 \\
 \\
 \index{SparseRowAdd}::::::::::::::::::::::::\\
 \texttt{SparseRowAdd(A,i,j,k)}\\
 

 Adds $k$ times the j-th row to the i-th row of a sparse matrix $A$. The sparse matrix $A$ is modified but nothing is returned. \\
 \\
 \\
 \\
 \index{SparseSemiEchelon}::::::::::::::::::::::::\\
 \texttt{SparseSemiEchelon(A)}\\
 

 Converts a sparse matrix $A$ to semi-echelon form (which means echelon form up to a permutation of rows).
The sparse matrix $A$ is modified but nothing is returned. \\
 \\
 \\
 \\
 \index{RankMatDestructive}::::::::::::::::::::::::\\
 \texttt{RankMatDestructive(A)}\\
 

 Returns the rank of a sparse matrix $A$. The sparse matrix $A$ is modified during the calculation. \\
 \\
 \\
 \\
 \index{RankMat}::::::::::::::::::::::::\\
 \texttt{RankMat(A)}\\
 

 Returns the rank of a sparse matrix $A$. \\
 \\
 \\
 \\
 \index{SparseChainComplex}::::::::::::::::::::::::\\
 \texttt{SparseChainComplex(Y)}\\
 

 Inputs a regular CW-complex $Y$ and returns a sparse chain complex which is chain homotopy equivalent to the
cellular chain complex of $Y$. The function uses discrete vector fields to calculate a smallish chain
complex. \\
 \\
 \\
 \\
 \index{SparseChainComplexOfRegularCWComplex}::::::::::::::::::::::::\\
 \texttt{SparseChainComplexOfRegularCWComplex(Y)}\\
 

 Inputs a regular CW-complex $Y$ and returns its cellular chain complex as a sparse chain complex. The function
SparseChainComplex(Y) will usually return a smaller chain complex. \\
 \\
 \\
 \\
 \index{SparseBoundaryMatrix}::::::::::::::::::::::::\\
 \texttt{SparseBoundaryMatrix(C,n)}\\
 

 Inputs a sparse chain complex $C$ and integer $n$. Returns the n-th boundary matrix of the chain complex in sparse format. \\
 \\
 \\
 \\
 \index{Bettinumbers}::::::::::::::::::::::::\\
 \texttt{Bettinumbers(C,n)}\\
 

 Inputs a sparse chain complex $C$ and integer $n$. Returns the n-th Netti number of the chain complex. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Homology and cohomology groups}}\logpage{[ 10, 0, 0 ]}
\hyperdef{L}{X782177107A5D6D19}{}
{
 \\
 \\
 \\
 \index{Cohomology}::::::::::::::::::::::::\\
 \texttt{Cohomology(X,n) }\\
 

 Inputs either a cochain complex $X=C$ (or G-cocomplex C) or a cochain map $X=(C \longrightarrow D)$ in characteristic $p$ together with a non-negative intereg $n$. \\
 \\
If $X=C$ and $p=0$ then the torsion coefficients of $H^n(C)$ are retuned. If $X=C$ and $p$ is prime then the dimension of $H^n(C)$ are retuned. \\
 \\
If $X=(C \longrightarrow D)$ then the induced homomorphism $H^n(C)\longrightarrow H^n(D)$ is returned as a homomorphism of finitely presented groups. \\
 \\
 A $G$-cocomplex $C$ can also be input. The cohomology groups of such a complex may not be abelian. \textsc{Warning:} in this case Cohomology(C,n) returns the abelian invariants of the $n$-th cohomology group of $C$. \\
 \\
 \\
 \\
 \index{CohomologyModule}::::::::::::::::::::::::\\
 \texttt{CohomologyModule(C,n) }\\
 

 Inputs a $G$-cocomplex $C$ together with a non-negative integer $n$. It returns the cohomology $H^n(C)$ as a $G$-outer group. If $C$ was constructed from a resolution $R$ by homing to an abelian $G$-outer group $A$ then, for each x in H:=CohomologyModule(C,n), there is a function
f:=H!.representativeCocycle(x) which is a standard n-cocycle corresponding to
the cohomology class x. (At present this works only for n=1,2,3.) \\
 \\
 \\
 \\
 \index{CohomologyPrimePart}::::::::::::::::::::::::\\
 \texttt{CohomologyPrimePart(C,n,p)}\\
 

 Inputs a cochain complex $C$ in characteristic 0, a positive integer $n$, and a prime $p$. It returns a list of those torsion coefficients of $H^n(C)$ that are positive powers of $p$. The function uses the EDIM package by Frank Luebeck. \\
 \\
 \\
 \\
 \index{GroupCohomology}::::::::::::::::::::::::\\
 \texttt{GroupCohomology(X,n) }\\
 \texttt{GroupCohomology(X,n,p)}\\
 

 Inputs a positive integer $n$ and either \\
 \\
 a finite group $X=G$ \\
 \\
 or a nilpotent Pcp-group $X=G$ \\
 \\
 or a space group $X=G$ \\
 \\
 or a list $X=D$ representing a graph of groups\\
 \\
or a pair $X=["Artin",D]$ where $D$ is a Coxeter diagram representing an infinite Artin group $G$.\\
 \\
or a pair $X=["Coxeter",D]$ where $D$ is a Coxeter diagram representing a finite Coxeter group $G$.\\
 \\
 It returns the torsion coefficients of the integral cohomology $H^n(G,Z)$. 

 There is an optional third argument which, when set equal to a prime $p$, causes the function to return the the mod $p$ cohomology $H^n(G,Z_p)$ as a list of length equal to its rank. 

 This function is a composite of more basic functions, and makes choices for a
number of parameters. For a particular group you would almost certainly be
better using the more basic functions and making the choices yourself! \\
 \\
 \\
 \\
 \index{GroupHomology}::::::::::::::::::::::::\\
 \texttt{GroupHomology(X,n)}\\
 \texttt{GroupHomology(X,n,p)}\\
 

 Inputs a positive integer $n$ and either \\
 \\
 a finite group $X=G$ \\
 \\
 or a nilpotent Pcp-group $X=G$ \\
 \\
 or a space group $X=G$ \\
 \\
 or a list $X=D$ representing a graph of groups\\
 \\
or a pair $X=["Artin",D]$ where $D$ is a Coxeter diagram representing an infinite Artin group $G$.\\
 \\
or a pair $X=["Coxeter",D]$ where $D$ is a Coxeter diagram representing a finite Coxeter group $G$.\\
 \\
 It returns the torsion coefficients of the integral homology $H_n(G,Z)$. 

 There is an optional third argument which, when set equal to a prime $p$, causes the function to return the mod $p$ homology $H_n(G,Z_p)$ as a list of lenth equal to its rank. 

 This function is a composite of more basic functions, and makes choices for a
number of parameters. For a particular group you would almost certainly be
better using the more basic functions and making the choices yourself! \\
 \\
 \\
 \\
 \index{PersistentHomologyOfQuotientGroupSeries}::::::::::::::::::::::::\\
 \texttt{PersistentHomologyOfQuotientGroupSeries(S,n)}\\
 \texttt{PersistentHomologyOfQuotientGroupSeries(S,n,p,Resolution{\textunderscore}Algorithm)}\\
 

 Inputs a positive integer $n$ and a decreasing chain $S=[S_1, S_2, ..., S_k]$ of normal subgroups in a finite $p$-group $G=S_1$. It returns the bar code of the persistent mod $p$ homology in degree $n$ of the sequence of quotient homomorphisms $G \rightarrow G/S_k \rightarrow G/S_{k-1} \rightarrow ... \rightarrow G/S_2 $. The bar code is returned as a matrix containing the dimensions of the images
of the induced homology maps. 

 If one sets $p=0$ then the integral persitent homology bar code is returned. This is a matrix
whose entries are pairs of the lists: the list of abelian invariants of the
images of the induced homology maps and the cokernels of the induced homology
maps. (The matrix probably does not uniquely determine the induced homology
maps.) 

 Non prime-power (and possibly infinite) groups $G$ can also be handled; in this case the prime must be entered as a third
argument, and the resolution algorithm (e.g. ResolutionNilpotentGroup) can be
entered as a fourth argument. (The default algorithm is ResolutionFiniteGroup,
so this must be changed for infinite groups.) \\
 \\
 \\
 \\
 \index{PersistentCohomologyOfQuotientGroupSeries}::::::::::::::::::::::::\\
 \texttt{PersistentCohomologyOfQuotientGroupSeries(S,n)}\\
 \texttt{PersistentCohomologyOfQuotientGroupSeries(S,n,p,Resolution{\textunderscore}Algorithm)}\\
 

 Inputs a positive integer $n$ and a decreasing chain $S=[S_1, S_2, ..., S_k]$ of normal subgroups in a finite $p$-group $G=S_1$. It returns the bar code of the persistent mod $p$ cohomology in degree $n$ of the sequence of quotient homomorphisms $G \rightarrow G/S_k \rightarrow G/S_{k-1} \rightarrow ... \rightarrow G/S_2 $. The bar code is returned as a matrix containing the dimensions of the images
of the induced homology maps. 

 If one sets $p=0$ then the integral persitent cohomology bar code is returned. This is a matrix
whose entries are pairs of the lists: the list of abelian invariants of the
images of the induced cohomology maps and the cokernels of the induced
cohomology maps. (The matrix probably does not uniquely determine the induced
homology maps.) 

 Non prime-power (and possibly infinite) groups $G$ can also be handled; in this case the prime must be entered as a third
argument, and the resolution algorithm (e.g. ResolutionNilpotentGroup) can be
entered as a fourth argument. (The default algorithm is ResolutionFiniteGroup,
so this must be changed for infinite groups.) 

 (The implementation is possibly a little less efficient than that of the
corresponding persistent homology function.) \\
 \\
 \\
 \\
 \index{UniversalBarCode}::::::::::::::::::::::::\\
 \texttt{UniversalBarCode("UpperCentralSeries",n,d)}\\
 \texttt{UniversalBarCode("UpperCentralSeries",n,d,k)}\\
 

 Inputs integers $n,d$ that identify a prime power group G=SmallGroup(n,d), together with one of the
strings "UpperCentralSeries", LowerCentralSeries", "DerivedSeries",
"UpperPCentralSeries", "LowerPCentralSeries". The function returns a matrix of
rational functions; the coefficients of $x^k$ in their expansions yield the persistence matrix for the degree $k$ homology with trivial mod p coefficients associated to the quotients of $G$ by the terms of the given series. 

 If the additional integer argument $k$ is supplied then the function returns the degree k homology persistence
matrix. \\
 \\
 \\
 \\
 \index{PersistentHomologyOfSubGroupSeries}::::::::::::::::::::::::\\
 \texttt{PersistentHomologyOfSubGroupSeries(S,n)}\\
 \texttt{PersistentHomologyOfSubGroupSeries(S,n,p,Resolution{\textunderscore}Algorithm)}\\
 

 Inputs a positive integer $n$ and a decreasing chain $S=[S_1, S_2, ..., S_k]$ of subgroups in a finite $p$-group $G=S_1$. It returns the bar code of the persistent mod $p$ homology in degree $n$ of the sequence of inclusion homomorphisms $S_k \rightarrow S_{k-1} \rightarrow ... \rightarrow S_1=G $. The bar code is returned as a binary matrix. 

 Non prime-power (and possibly infinite) groups $G$ can also be handled; in this case the prime must be entered as a third
argument, and the resolution algorithm (e.g. ResolutionNilpotentGroup) must be
entered as a fourth argument. \\
 \\
 \\
 \\
 \index{PersistentHomologyOfFilteredChainComplex}::::::::::::::::::::::::\\
 \texttt{PersistentHomologyOfFilteredChainComplex(C,n,p) }\\
 

 Inputs a filtered chain complex $C$ (of characteristic $0$ or $p$) together with a positive integer $n$ and prime $p$. It returns the bar code of the persistent mod $p$ homology in degree $n$ of the filtered chain complex $C$. (This function needs a more efficient implementation. Its fine as it stands
for investigation in group homology, but not sufficiently efficient for the
homology of large complexes arising in applied topology.) \\
 \\
 \\
 \\
 \texttt{PersistentHomologyOfCommutativeDiagramOfPGroups(D,n) }\\
 

 Inputs a commutative diagram $D$ of finite $p$-groups and a positive integer $n$. It returns a list containing, for each homomorphism in the nerve of $D$, a triple $[k,l,m]$ where $k$ is the dimension of the source of the induced mod $p$ homology map in degree $n$, $l$ is the dimension of the image, and $m$ is the dimension of the cokernel. \\
 \\
 \\
 \\
 \index{PersistentHomologyOfFilteredPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{PersistentHomologyOfFilteredPureCubicalComplex(M,n)}\\
 

 Inputs a filtered pure cubical complex $M$ and a non-negative integer $n$. It returns the degree $n$ persistent homology of $ M$ with rational coefficients. \\
 \\
 \\
 \\
 \index{PersistentHomologyOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{PersistentHomologyOfPureCubicalComplex(L,n,p)}\\
 

 Inputs a positive integer $n$, a prime $p$ and an increasing chain $L=[L_1, L_2, ..., L_k]$ of subcomplexes in a pure cubical complex $L_k$. It returns the bar code of the persistent mod $p$ homology in degree $n$ of the sequence of inclusion maps. The bar code is returned as a matrix. (This
function is extremely inefficient and it is better to use
PersistentHomologyOFilteredfPureCubicalComplex. 

 \\
 \\
 \\
 \\
 \index{ZZPersistentHomologyOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ZZPersistentHomologyOfPureCubicalComplex(L,n,p)}\\
 

 Inputs a positive integer $n$, a prime $p$ and any sequence $L=[L_1, L_2, ..., L_k]$ of subcomplexes of some pure cubical complex. It returns the bar code of the
zig-zag persistent mod $p$ homology in degree $n$ of the sequence of maps $L_1 \rightarrow L_1 \cup L_2 \leftarrow L_2 \rightarrow L_2 \cup L_3
\leftarrow L_4 \rightarrow ... \leftarrow L_k$. The bar code is returned as a matrix. 

 \\
 \\
 \\
 \\
 \index{RipsHomology}::::::::::::::::::::::::\\
 \texttt{RipsHomology(G,n)}\\
 \texttt{RipsHomology(G,n,p)}\\
 

 Inputs a graph $G$, a non-negative integer $n$ (and optionally a prime number $p$). It returns the integral homology (or mod p homology) in degree $n$ of the Rips complex of $G$. \\
 \\
 \\
 \\
 \index{BarCode}::::::::::::::::::::::::\\
 \texttt{BarCode(P)}\\
 

 Inputs an integer persistence matrix P and returns the same information in the
form of a binary matrix (corresponding to the usual bar code). \\
 \\
 \\
 \\
 \index{BarCodeDisplay}::::::::::::::::::::::::\\
 \index{BarCodeCompactDisplay}::::::::::::::::::::::::\\
 \texttt{BarCodeDisplay(P)}\\
 \texttt{BarCodeDisplay(P,"mozilla")}\\
 \texttt{BarCodeCompactDisplay(P)}\\
 \texttt{BarCodeCompactDisplay(P,"mozilla")}\\
 

 Inputs an integer persistence matrix P, and an optional string specifying a
viewer/browser. It displays a picture of the bar code (using GraphViz
software). The compact display is better for large bar codes. \\
 \\
 \\
 \\
 \index{Homology}::::::::::::::::::::::::\\
 \texttt{Homology(X,n)}\\
 

 Inputs either a chain complex $X=C$ or a chain map $X=(C \longrightarrow D)$. \\
 \\
If $X=C$ then the torsion coefficients of $H_n(C)$ are retuned.\\
 \\
 If $X=(C \longrightarrow D)$ then the induced homomorphism $H_n(C) \longrightarrow H_n(D)$ is returned as a homomorphism of finitely presented groups. \\
 \\
 A $G$-complex $C$ can also be input. The homology groups of such a complex may not be abelian. \textsc{Warning:} in this case Homology(C,n) returns the abelian invariants of the $n$-th homology group of $C$. \\
 \\
 \\
 \\
 \index{HomologyPb}::::::::::::::::::::::::\\
 \texttt{HomologyPb(C,n)}\\
 

 This is a back-up function which might work in some instances where $Homology(C,n)$ fails. It is most useful for chain complexes whose boundary homomorphisms are
sparse. 

 It inputs a chain complex $C$ in characteristic $0$ and returns the torsion coefficients of $H_n(C)$ . There is a small probability that an incorrect answer could be returned. The
computation relies on probabilistic Smith Normal Form algorithms implemented
in the Simplicial Homology GAP package. This package therefore needs to be
loaded. The computation is stored as a component of $C$ so, when called a second time for a given $C$ and $n$, the calculation is recalled without rerunning the algorithm. 

 The choice of probabalistic algorithm can be changed using the command 

 SetHomologyAlgorithm(HomologyAlgorithm[i]);

 where i = 1,2,3 or 4. The upper limit for the probability of an incorrect
answer can be set to any rational number $0${\textless}$e${\textless}= $1$ using the following command. 

SetUncertaintyTolerence(e);

 See the Simplicial Homology package manual for further details. \\
 \\
 \\
 \\
 \index{HomologyVectorSpace}::::::::::::::::::::::::\\
 \texttt{HomologyVectorSpace(X,n)}\\
 

 Inputs either a chain complex $X=C$ or a chain map $X=(C \longrightarrow D)$ in prime characteristic. \\
 \\
If $X=C$ then $H_n(C)$ is retuned as a vector space.\\
 \\
 If $X=(C \longrightarrow D)$ then the induced homomorphism $H_n(C) \longrightarrow H_n(D)$ is returned as a homomorphism of vector spaces. \\
 \\
 \\
 \\
 \\
 \\
 \index{HomologyPrimePart}::::::::::::::::::::::::\\
 \texttt{HomologyPrimePart(C,n,p)}\\
 

 Inputs a chain complex $C$ in characteristic 0, a positive integer $n$, and a prime $p$. It returns a list of those torsion coefficients of $H_n(C)$ that are positive powers of $p$. The function uses the EDIM GAP package by Frank Luebeck. \\
 \\
 \\
 \\
 \index{LeibnizAlgebraHomology}::::::::::::::::::::::::\\
 \texttt{LeibnizAlgebraHomology(A,n)}\\
 

 Inputs a Lie or Leibniz algebra $X=A$ (over the ring of integers $Z$ or over a field $K$), together with a positive integer $n$. It returns the $n$-dimensional Leibniz homology of $A$. \\
 \\
 \\
 \\
 \index{LieAlgebraHomology}::::::::::::::::::::::::\\
 \texttt{LieAlgebraHomology(A,n)}\\
 

 Inputs a Lie algebra $A$ (over the integers or a field) and a positive integer $n$. It returns the homology $H_n(A,k)$ where $k$ denotes the ground ring. \\
 \\
 \\
 \\
 \index{PrimePartDerivedFunctor}::::::::::::::::::::::::\\
 \texttt{PrimePartDerivedFunctor(G,R,F,n)}\\
 

 Inputs a finite group $G$, a positive integer $n$, at least $n+1$ terms of a $ZP$-resolution for a Sylow subgroup $P${\textless}$G$ and a "mathematically suitable" covariant additive functor $F$ such as TensorWithIntegers . It returns the abelian invariants of the $p$-component of the homology $H_n(F(R))$ . 

 Warning: All calculations are assumed to be in characteristic 0. The function
should not be used if the coefficient module is over the field of $p$ elements. 

 "Mathematically suitable" means that the Cartan-Eilenberg double coset formula
must hold. \\
 \\
 \\
 \\
 \index{RankHomologyPGroup}::::::::::::::::::::::::\\
 \texttt{RankHomologyPGroup(G,n)}\\
 \texttt{RankHomologyPGroup(R,n)}\\
 \texttt{RankHomologyPGroup(G,n,"empirical")}\\
 

 Inputs a (smallish) $p$-group $G$, or $n$ terms of a minimal $Z_pG$-resolution $R$ of $Z_p$ , together with a positive integer $n$. It returns the minimal number of generators of the integral homology group $H_n(G,Z)$. 

 If an option third string argument "empirical" is included then an empirical
algorithm will be used. This is one which always seems to yield the right
answer but which we can't prove yields the correct answer. \\
 \\
 \\
 \\
 \index{RankPrimeHomology}::::::::::::::::::::::::\\
 \texttt{RankPrimeHomology(G,n)}\\
 

 Inputs a (smallish) $p$-group $G$ together with a positive integer $n$. It returns a function $dim(k)$ which gives the rank of the vector space $H_k(G,Z_p)$ for all $0$ {\textless}= $k$ {\textless}= $n$. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Poincare series}}\logpage{[ 11, 0, 0 ]}
\hyperdef{L}{X850CDAFE801E2B2A}{}
{
 \\
 \\
 \\
 \texttt{EfficientNormalSubgroups(G)}\\
 \texttt{EfficientNormalSubgroups(G,k)}\\
 

 Inputs a prime-power group $G$ and, optionally, a positive integer $k$. The default is $k=4$. The function returns a list of normal subgroups $N$ in $G$ such that the Poincare series for $G$ equals the Poincare series for the direct product $(N \times (G/N))$ up to degree $k$. \\
 \\
 \\
 \\
 \index{ExpansionOfRationalFunction}::::::::::::::::::::::::\\
 \texttt{ExpansionOfRationalFunction(f,n)}\\
 

 Inputs a positive integer $n$ and a rational function $f(x)=p(x)/q(x)$ where the degree of the polynomial $p(x)$ is less than that of $q(x)$. It returns a list $[a_0 , a_1 , a_2 , a_3 , \ldots ,a_n]$ of the first $n+1$ coefficients of the infinite expansion 

 $f(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + \ldots $ . \\
 \\
 \\
 \\
 \index{PoincareSeries}::::::::::::::::::::::::\\
 \texttt{PoincareSeries(G,n) }\\
 \texttt{ PoincareSeries(R,n) }\\
 \texttt{ PoincareSeries(L,n) }\\
 \texttt{ PoincareSeries(G) }\\
 

 Inputs a finite $p$-group $G$ and a positive integer $n$. It returns a quotient of polynomials $f(x)=P(x)/Q(x)$ whose coefficient of $x^k$ equals the rank of the vector space $H_k(G,Z_p)$ for all $k$ in the range $k=1$ to $k=n$. (The second input variable can be omitted, in which case the function tries
to choose a "reasonable" value for $n$. For $2$-groups the function PoincareSeriesLHS(G) can be used to produce an $f(x)$ that is correct in all degrees.) 

 In place of the group $G$ the function can also input (at least $n$ terms of) a minimal mod $p$ resolution $R$ for $G$. 

 Alternatively, the first input variable can be a list $L$ of integers. In this case the coefficient of $x^k$ in $f(x)$ is equal to the $(k+1)$st term in the list. \\
 \\
 \\
 \\
 \index{PoincareSeriesPrimePart}::::::::::::::::::::::::\\
 \texttt{PoincareSeriesPrimePart(G,p,n) }\\
 

 Inputs a finite group $G$, a prime $p$, and a positive integer $n$. It returns a quotient of polynomials $f(x)=P(x)/Q(x)$ whose coefficient of $x^k$ equals the rank of the vector space $H_k(G,Z_p)$ for all $k$ in the range $k=1$ to $k=n$. 

 The efficiency of this function needs to be improved. \\
 \\
 \\
 \\
 \texttt{PoincareSeriesLHS(G) }\\
 

 Inputs a finite $2$-group $G$ and returns a quotient of polynomials $f(x)=P(x)/Q(x)$ whose coefficient of $x^k$ equals the rank of the vector space $H_k(G,Z_2)$ for all $k$. 

 This function was written by \textsc{Paul Smith}. It use the Singular system for commutative algebra. \\
 \\
 \\
 \\
 \index{Prank}::::::::::::::::::::::::\\
 \texttt{Prank(G) }\\
 

 Inputs a $p$-group $G$ and returns the rank of the largest elementary abelian subgroup. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Cohomology ring structure}}\logpage{[ 12, 0, 0 ]}
\hyperdef{L}{X7A9561E47A4994F5}{}
{
 \\
 \\
 \\
 \index{IntegralCupProduct}::::::::::::::::::::::::\\
 \texttt{IntegralCupProduct(R,u,v,p,q) }\\
 \texttt{ IntegralCupProduct(R,u,v,p,q,P,Q,N) }\\
 

 (Various functions used to construct the cup product are also \href{ CR_functions.html} {available}.) 

 Inputs a $ZG$-resolution $R$, a vector $u$ representing an element in $H^p(G,Z)$, a vector $v$ representing an element in $H^q(G,Z)$ and the two integers $p,q$ {\textgreater}$ 0$. It returns a vector $w$ representing the cup product $u\cdot v$ in $H^{p+q}(G,Z)$. This product is associative and $u\cdot v = (-1)pqv\cdot u$ . It provides $H^\ast(G,Z)$ with the structure of an anti-commutative graded ring. This function
implements the cup product for characteristic 0 only. 

 The resolution $R$ needs a contracting homotopy. 

 To save the function from having to calculate the abelian groups $H^n(G,Z)$ additional input variables can be used in the form $IntegralCupProduct(R,u,v,p,q,P,Q,N)$ , where \\
 \\
 $P$ is the output of the command $CR_CocyclesAndCoboundaries(R,p,true)$ \\
 \\
 $Q$ is the output of the command $CR_CocyclesAndCoboundaries(R,q,true)$\\
 \\
$N$ is the output of the command $CR_CocyclesAndCoboundaries(R,p+q,true)$ . \\
 \\
 \\
 \\
 \\
 \\
 \index{IntegralRingGenerators}::::::::::::::::::::::::\\
 \texttt{IntegralRingGenerators(R,n) }\\
 

 Inputs at least $n+1$ terms of a $ZG$-resolution and integer $n${\textgreater} $0$. It returns a minimal list of cohomology classes in $H^n(G,Z)$ which, together with all cup products of lower degree classes, generate the
group $H^n(G,Z)$ . 

 (Let $a_i$ be the $i$-th canonical generator of the $d$-generator abelian group $H^n(G,Z)$. The cohomology class $n_1a_1 + ... +n_da_d$ is represented by the integer vector $u=(n_1, ..., n_d)$. ) \\
 \\
 \\
 \\
 \index{ModPCohomologyGenerators}::::::::::::::::::::::::\\
 \texttt{ModPCohomologyGenerators(G,n) }\\
 \texttt{ModPCohomologyGenerators(R) }\\
 

 Inputs either a $p$-group $G$ and positive integer $n$, or else $n$ terms of a minimal $Z_pG$-resolution $R$ of $Z_p$. It returns a pair whose first entry is a minimal set of homogeneous
generators for the cohomology ring $A=H^*(G,Z_p)$ modulo all elements in degree greater than $n$. The second entry of the pair is a function $deg$ which, when applied to a minimal generator, yields its degree. 

 WARNING: the following rule must be applied when multiplying generators $x_i$ together. Only products of the form $x_1*(x_2*(x_3*(x_4*...)))$ with $deg(x_i) \le deg(x_{i+1})$ should be computed (since the $x_i$ belong to a structure constant algebra with only a partially defined structure
constants table). \\
 \\
 \\
 \\
 \index{ModPCohomologyRing}::::::::::::::::::::::::\\
 \texttt{ModPCohomologyRing(G,n) }\\
 \texttt{ModPCohomologyRing(G,n,level) }\\
 \texttt{ModPCohomologyRing(R) }\\
 \texttt{ModPCohomologyRing(R,level)}\\
 

 Inputs either a $p$-group $G$ and positive integer $n$, or else $n$ terms of a minimal $Z_pG$-resolution $R$ of $Z_p$. It returns the cohomology ring $A=H^*(G,Z_p)$ modulo all elements in degree greater than $n$. 

 The ring is returned as a structure constant algebra $A$. 

 The ring $A$ is graded. It has a component $A!.degree(x)$ which is a function returning the degree of each (homogeneous) element $x$ in $GeneratorsOfAlgebra(A)$. 

 An optional input variable "level" can be set to one of the strings "medium"
or "high". These settings determine parameters in the algorithm. The default
setting is "medium". 

 When "level" is set to "high" the ring $A$ is returned with a component $A!.niceBasis$. This component is a pair $[Coeff,Bas]$. Here $Bas$ is a list of integer lists; a "nice" basis for the vector space $A$ can be constructed using the command $List(Bas,x->Product(List(x,i->Basis(A)[i]))$. The coefficients of the canonical basis element $Basis(A)[i]$ are stored as $Coeff[i]$. 

 If the ring $A$ is computed using the setting "level"="medium" then the component $A!.niceBasis$ can be added to $A$ using the command $ A:=ModPCohomologyRing_part_2(A) $. \\
 \\
 \\
 \\
 \index{ModPRingGenerators}::::::::::::::::::::::::\\
 \texttt{ModPRingGenerators(A) }\\
 

 Inputs a mod $p$ cohomology ring $A$ (created using the preceeding function). It returns a minimal generating set
for the ring $A$. Each generator is homogeneous. \\
 \\
 \\
 \\
 \texttt{Mod2CohomologyRingPresentation(G) }\\
 \texttt{Mod2CohomologyRingPresentation(G,n) }\\
 \texttt{Mod2CohomologyRingPresentation(A) }\\
 \texttt{Mod2CohomologyRingPresentation(R)}\\
 

 When applied to a finite $2$-group $G$ this function returns a presentation for the mod 2 cohomology ring $H^*(G,Z_2)$. The Lyndon-Hochschild-Serre spectral sequence is used to prove that the
presentation is correct. 

 When the function is applied to a $2$-group $G$ and positive integer $n$ the function first constructs $n$ terms of a free $Z_2G$-resolution $R$, then constructs the finite-dimensional graded algebra $A=H^(*\le n)(G,Z_2)$, and finally uses $A$ to approximate a presentation for $H^*(G,Z_2)$. For "sufficiently large" the approximation will be a correct presentation
for $H^*(G,Z_2)$. 

 Alternatively, the function can be applied directly to either the resolution $R$ or graded algebra $A$. 

This function was written by \textsc{Paul Smith}. It uses the Singular commutative algebra package to handle the
Lyndon-Hochschild-Serre spectral sequence. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Cohomology rings of $p$-groups (mainly $p=2)$}}\logpage{[ 13, 0, 0 ]}
\hyperdef{L}{X84A36BFC7E73C2BF}{}
{
 The functions on this page were written by \textsc{Paul Smith}. (They are included in HAP but they are also independently included in Paul
Smiths HAPprime package.) \\
 \\
 \\
 \index{Mod2CohomologyRingPresentation (HAPprime)}::::::::::::::::::::::::\\
 \texttt{Mod2CohomologyRingPresentation(G) }\\
 \texttt{Mod2CohomologyRingPresentation(G,n) }\\
 \texttt{Mod2CohomologyRingPresentation(A) }\\
 \texttt{Mod2CohomologyRingPresentation(R) }\\
 

 When applied to a finite $2$-group $G$ this function returns a presentation for the mod 2 cohomology ring $H^*(G,Z_2)$. The Lyndon-Hochschild-Serre spectral sequence is used to prove that the
presentation is correct. 

 When the function is applied to a $2$-group $G$ and positive integer $n$ the function first constructs $n$ terms of a free $Z_2G$-resolution $R$, then constructs the finite-dimensional graded algebra $A=H^(*\le n)(G,Z_2)$, and finally uses $A$ to approximate a presentation for $H^*(G,Z_2)$. For "sufficiently large" the approximation will be a correct presentation
for $H^*(G,Z_2)$. 

 Alternatively, the function can be applied directly to either the resolution $R$ or graded algebra $A$. 

This function was written by \textsc{Paul Smith}. It uses the Singular commutative algebra package to handle the
Lyndon-Hochschild-Serre spectral sequence. \\
 \\
 \\
 \\
 \index{PoincareSeriesLHS (HAPprime)}::::::::::::::::::::::::\\
 \texttt{PoincareSeriesLHS(G) }\\
 

 Inputs a finite $2$-group $G$ and returns a quotient of polynomials $f(x)=P(x)/Q(x)$ whose coefficient of $x^k$ equals the rank of the vector space $H_k(G,Z_2)$ for all $k$. 

 This function was written by \textsc{Paul Smith}. It use the Singular system for commutative algebra. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Commutator and nonabelian tensor computations}}\logpage{[ 14, 0, 0 ]}
\hyperdef{L}{X86DE968B7B20BD48}{}
{
 \\
 \\
 \\
 \index{BaerInvariant}::::::::::::::::::::::::\\
 \texttt{BaerInvariant(G,c) }\\
 

 Inputs a nilpotent group $G$ and integer $c${\textgreater}$0$. It returns the Baer invariant $M^(c)(G)$ defined as follows. For an arbitrary group $G$ let $L^*_{c+1}(G)$ be the $(c+1)$-st term of the upper central series of the group $U=F/[[[R,F],F]...]$ (with $c$ copies of $F$ in the denominator) where $F/R$ is any free presentation of $G$. This is an invariant of $G$ and we define $M^{(c)}(G)$ to be the kernel of the canonical homomorphism $M^{(c)}(G) \longrightarrow G$. For $c=1$ the Baer invariant $M^(1)(G)$ is isomorphic to the second integral homology $H_2(G,Z)$. 

 This function requires the NQ package. \\
 \\
 \\
 \\
 \index{BogomolovMultiplier}::::::::::::::::::::::::\\
 \texttt{BogomolovMultiplier(G) }\\
 \\
 \texttt{BogomolovMultiplier(G, "standard") }\\
 \texttt{BogomolovMultiplier(G, "homology") }\\
 \texttt{BogomolovMultiplier(G, "tensor") }\\
 

 Inputs a finite group $G$ and returns the quotient $H_2(G,Z)/K(G)$ of the second integral homology of $G$ where $K(G)$ is the subgroup of $H_2(G,Z)$ generated by the images of all homomorphisms $H_2(A,Z) \rightarrow H_2(G,Z)$ induced from abelian subgroups of $G$. 

 Three slight variants of the implementation are available. The defaults
"standard" implementation seems to work best on average. But for some groups
the "homology" implementation or the "tensor" implementation will be faster.
The variants are called by including the appropriate string as the second
argument. \\
 \\
 \\
 \\
 \index{Bogomology}::::::::::::::::::::::::\\
 \texttt{Bogomology(G,n) }\\
 

 Inputs a finite group $G$ and positive integer $n$, and returns the quotient $H_n(G,Z)/K(G)$ of the degree $n$ integral homology of $G$ where $K(G)$ is the subgroup of $H_n(G,Z)$ generated by the images of all homomorphisms $H_n(A,Z) \rightarrow H_n(G,Z)$ induced from abelian subgroups of $G$. \\
 \\
 \\
 \\
 \index{Coclass}::::::::::::::::::::::::\\
 \texttt{Coclass(G) }\\
 

 Inputs a group $G$ of prime-power order $p^n$ and nilpotency class $c$ say. It returns the integer $r=n-c$ . \\
 \\
 \\
 \\
 \index{EpiCentre}::::::::::::::::::::::::\\
 \texttt{EpiCentre(G,N) }\\
 \texttt{EpiCentre(G)}\\
 

 Inputs a finite group $G$ and normal subgroup $N$ and returns a subgroup $Z^\ast(G,N)$ of the centre of $N$. The group $Z^\ast(G,N)$ is trivial if and only if there is a crossed module $d:E \longrightarrow G$ with $N=Image(d)$ and with $Ker(d)$ equal to the subgroup of $E$ consisting of those elements on which $G$ acts trivially. 

 If no value for $N$ is entered then it is assumed that $N=G$. In this case the group $Z^\ast(G,G)$ is trivial if and only if $G$ is isomorphic to a quotient $G=E/Z(E)$ of some group $E$ by the centre of $E$. (See also the command $UpperEpicentralSeries(G,c)$. ) \\
 \\
 \\
 \\
 \index{NonabelianExteriorProduct}::::::::::::::::::::::::\\
 \texttt{NonabelianExteriorProduct(G,N) }\\
 

 Inputs a finite group $G$ and normal subgroup $N$. It returns a record $E$ with the following components. \\
 \\
 $E.homomorphism$ is a group homomorphism ${\ensuremath{\mu}} : (G \wedge N) \longrightarrow G$ from the nonabelian exterior product $(G \wedge N)$ to $G$. The kernel of ${\ensuremath{\mu}}$ is the relative Schur multiplier. \\
 \\
 $E.pairing(x,y)$ is a function which inputs an element $x$ in $G$ and an element $y$ in $N$ and returns $(x \wedge y)$ in the exterior product $(G \wedge N)$ . \\
 \\
 This function should work for reasonably small nilpotent groups or extremely
small non-nilpotent groups. \\
 \\
 \\
 \\
 \index{NonabelianSymmetricKernel}::::::::::::::::::::::::\\
 \texttt{NonabelianSymmetricKernel(G) }\\
 \texttt{NonabelianSymmetricKernel(G,m) }\\
 

 Inputs a finite or nilpotent infinite group $G$ and returns the abelian invariants of the Fourth homotopy group $SG$ of the double suspension $SSK(G,1)$ of the Eilenberg-Mac Lane space $K(G,1)$. 

 For non-nilpotent groups the implementation of the function $NonabelianSymmetricKernel(G)$ is far from optimal and will soon be improved. As a temporary solution to this
problem, an optional second variable $m$ can be set equal to $0$, and then the function efficiently returns the abelian invariants of groups $A$ and $B$ such that there is an exact sequence $0 \longrightarrow B \longrightarrow SG \longrightarrow A \longrightarrow 0$. 

 Alternatively, the optional second varible $m$ can be set equal to a positive multiple of the order of the symmetric square $(G \tilde\otimes G)$. In this case the function returns the abelian invariants of $SG$. This might help when $G$ is solvable but not nilpotent (especially if the estimated upper bound $m$ is reasonable accurate). \\
 \\
 \\
 \\
 \index{NonabelianSymmetricSquare}::::::::::::::::::::::::\\
 \texttt{NonabelianSymmetricSquare(G) }\\
 \texttt{NonabelianSymmetricSquare(G,m) }\\
 

 Inputs a finite or nilpotent infinite group $G$ and returns a record $T$ with the following components. \\
 \\
 $T.homomorphism$ is a group homomorphism ${\ensuremath{\mu}} : (G \tilde\otimes G) \longrightarrow G$ from the nonabelian symmetric square of $G$ to $G$. The kernel of ${\ensuremath{\mu}}$ is isomorphic to the fourth homotopy group of the double suspension $SSK(G,1)$ of an Eilenberg-Mac Lane space. \\
 \\
 $T.pairing(x,y)$ is a function which inputs two elements $x, y$ in $G$ and returns the tensor $(x \otimes y)$ in the symmetric square $(G \otimes G)$ . \\
 \\
 An optional second varible $m$ can be set equal to a multiple of the order of the symmetric square $(G \tilde\otimes G)$. This might help when $G$ is solvable but not nilpotent (especially if the estimated upper bound $m$ is reasonable accurate) as the bound is used in the solvable quotient
algorithm. 

 The optional second variable $m$ can also be set equal to $0$. In this case the Todd-Coxeter procedure will be used to enumerate the
symmetric square even when $G$ is solvable. 

 This function should work for reasonably small solvable groups or extremely
small non-solvable groups. \\
 \\
 \\
 \\
 \index{NonabelianTensorProduct}::::::::::::::::::::::::\\
 \texttt{NonabelianTensorProduct(G,N) }\\
 

 Inputs a finite group $G$ and normal subgroup $N$. It returns a record $E$ with the following components. \\
 \\
 $E.homomorphism$ is a group homomorphism ${\ensuremath{\mu}} : (G \otimes N ) \longrightarrow G$ from the nonabelian exterior product $(G \otimes N)$ to $G$. \\
 \\
 $E.pairing(x,y)$ is a function which inputs an element $x$ in $G$ and an element $y$ in $N$ and returns $(x \otimes y)$ in the tensor product $(G \otimes N)$ . \\
 \\
 This function should work for reasonably small nilpotent groups or extremely
small non-nilpotent groups. \\
 \\
 \\
 \\
 \index{NonabelianTensorSquare}::::::::::::::::::::::::\\
 \texttt{NonabelianTensorSquare(G) }\\
 \texttt{NonabelianTensorSquare(G,m) }\\
 

 Inputs a finite or nilpotent infinite group $G$ and returns a record $T$ with the following components. \\
 \\
 $T.homomorphism$ is a group homomorphism ${\ensuremath{\mu}} : (G \otimes G) \longrightarrow G$ from the nonabelian tensor square of $G$ to $G$. The kernel of ${\ensuremath{\mu}}$ is isomorphic to the third homotopy group of the suspension $SK(G,1)$ of an Eilenberg-Mac Lane space. \\
 \\
 $T.pairing(x,y)$ is a function which inputs two elements $x, y$ in $G$ and returns the tensor $(x \otimes y)$ in the tensor square $(G \otimes G)$ . \\
 \\
 An optional second varible $m$ can be set equal to a multiple of the order of the tensor square $(G \otimes G)$. This might help when $G$ is solvable but not nilpotent (especially if the estimated upper bound $m$ is reasonable accurate) as the bound is used in the solvable quotient
algorithm. 

 The optional second variable $m$ can also be set equal to $0$. In this case the Todd-Coxeter procedure will be used to enumerate the tensor
square even when $G$ is solvable. 

 This function should work for reasonably small solvable groups or extremely
small non-solvable groups. \\
 \\
 \\
 \\
 \index{RelativeSchurMultiplier}::::::::::::::::::::::::\\
 \texttt{RelativeSchurMultiplier(G,N) }\\
 

 Inputs a finite group $G$ and normal subgroup $N$. It returns the homology group $H_2(G,N,Z)$ that fits into the exact sequence 

 $\ldots\longrightarrow H_3(G,Z) \longrightarrow H_3(G/N,Z) \longrightarrow
H_2(G,N,Z) \longrightarrow H_3(G,Z) \longrightarrow H_3(G/N,Z) \longrightarrow
\ldots. $ 

 This function should work for reasonably small nilpotent groups $G$ or extremely small non-nilpotent groups. \\
 \\
 \\
 \\
 \index{TensorCentre}::::::::::::::::::::::::\\
 \texttt{TensorCentre(G) }\\
 

 Inputs a group $G$ and returns the largest central subgroup $N$ such that the induced homomorphism of nonabelian tensor squares $(G \otimes G) \longrightarrow (G/N \otimes G/N)$ is an isomorphism. Equivalently, $N$ is the largest central subgroup such that $\pi_3(SK(G,1)) \longrightarrow \pi_3(SK(G/N,1))$ is injective. \\
 \\
 \\
 \\
 \index{ThirdHomotopyGroupOfSuspensionB}::::::::::::::::::::::::\\
 \texttt{ThirdHomotopyGroupOfSuspensionB(G) }\\
 \texttt{ThirdHomotopyGroupOfSuspensionB(G,m) }\\
 

 Inputs a finite or nilpotent infinite group $G$ and returns the abelian invariants of the third homotopy group $JG$ of the suspension $SK(G,1)$ of the Eilenberg-Mac Lane space $K(G,1)$. 

 For non-nilpotent groups the implementation of the function $ThirdHomotopyGroupOfSuspensionB(G)$ is far from optimal and will soon be improved. As a temporary solution to this
problem, an optional second variable $m$ can be set equal to $0$, and then the function efficiently returns the abelian invariants of groups $A$ and $B$ such that there is an exact sequence $0 \longrightarrow B \longrightarrow JG \longrightarrow A \longrightarrow 0$. 

 Alternatively, the optional second varible $m$ can be set equal to a positive multiple of the order of the tensor square $(G \otimes G)$. In this case the function returns the abelian invariants of $JG$. This might help when $G$ is solvable but not nilpotent (especially if the estimated upper bound $m$ is reasonable accurate). \\
 \\
 \\
 \\
 \index{UpperEpicentralSeries}::::::::::::::::::::::::\\
 \texttt{UpperEpicentralSeries(G,c) }\\
 

 Inputs a nilpotent group $G$ and an integer $c$. It returns the $c$-th term of the upper epicentral series $1$ {\textless} $ Z_1^\ast(G)$ {\textless} $Z_2^\ast(G)$ {\textless} $ \ldots $. 

 The upper epicentral series is defined for an arbitrary group $G$. The group $Z_c^\ast (G)$ is the image in $G$ of the $c$-th term $Z_c(U)$ of the upper central series of the group $U=F/[[[R,F],F] \ldots ]$ (with $c$ copies of $F$ in the denominator) where $F/R$ is any free presentation of $G$. 

 This functions requires the NQ package. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Lie commutators and nonabelian Lie tensors}}\logpage{[ 15, 0, 0 ]}
\hyperdef{L}{X7A3DC9327EE1BE6C}{}
{
 \\
 \\
 \\
 Functions on this page are joint work with \textsc{Hamid Mohammadzadeh}, and implemented by him. \\
 \\
 \\
 \\
 \index{LieCoveringHomomorphism}::::::::::::::::::::::::\\
 \texttt{LieCoveringHomomorphism(L)}\\
 

 Inputs a finite dimensional Lie algebra $L$ over a field, and returns a surjective Lie homomorphism $phi : C\rightarrow L$ where: \\
 \\
the kernel of $phi$ lies in both the centre of $C$ and the derived subalgebra of $C$, \\
 \\
 the kernel of $phi$ is a vector space of rank equal to the rank of the second Chevalley-Eilenberg
homology of $L$. \\
 \\
 \\
 \\
 \\
 \\
 \index{LeibnizQuasiCoveringHomomorphism}::::::::::::::::::::::::\\
 \texttt{LeibnizQuasiCoveringHomomorphism(L)}\\
 

 Inputs a finite dimensional Lie algebra $L$ over a field, and returns a surjective homomorphism $phi : C\rightarrow L$ of Leibniz algebras where: \\
 \\
the kernel of $phi$ lies in both the centre of $C$ and the derived subalgebra of $C$, \\
 \\
 the kernel of $phi$ is a vector space of rank equal to the rank of the kernel $J$ of the homomorphism $L \otimes L \rightarrow L$ from the tensor square to $L$. (We note that, in general, $J$ is NOT equal to the second Leibniz homology of $L$.) \\
 \\
 \\
 \\
 \\
 \\
 \index{LieEpiCentre}::::::::::::::::::::::::\\
 \texttt{LieEpiCentre(L)}\\
 

 Inputs a finite dimensional Lie algebra $L$ over a field, and returns an ideal $Z^\ast(L)$ of the centre of $L$. The ideal $Z^\ast(L)$ is trivial if and only if $L$ is isomorphic to a quotient $L=E/Z(E)$ of some Lie algebra $E$ by the centre of $E$. \\
 \\
 \\
 \\
 \index{LieExteriorSquare}::::::::::::::::::::::::\\
 \texttt{LieExteriorSquare(L) }\\
 

 Inputs a finite dimensional Lie algebra $L$ over a field. It returns a record $E$ with the following components. \\
 \\
 $E.homomorphism$ is a Lie homomorphism ${\ensuremath{\mu}} : (L \wedge L) \longrightarrow L$ from the nonabelian exterior square $(L \wedge L)$ to $L$. The kernel of ${\ensuremath{\mu}}$ is the Lie multiplier. \\
 \\
 $E.pairing(x,y)$ is a function which inputs elements $x, y$ in $L$ and returns $(x \wedge y)$ in the exterior square $(L \wedge L)$ . \\
 \\
 \\
 \\
 \\
 \\
 \index{LieTensorSquare}::::::::::::::::::::::::\\
 \texttt{LieTensorSquare(L) }\\
 

 Inputs a finite dimensional Lie algebra $L$ over a field and returns a record $T$ with the following components. \\
 \\
 $T.homomorphism$ is a Lie homomorphism ${\ensuremath{\mu}} : (L \otimes L) \longrightarrow L$ from the nonabelian tensor square of $L$ to $L$. \\
 \\
 $T.pairing(x,y)$ is a function which inputs two elements $x, y$ in $L$ and returns the tensor $(x \otimes y)$ in the tensor square $(L \otimes L)$ . \\
 \\
 \\
 \\
 \\
 \\
 \index{LieTensorCentre}::::::::::::::::::::::::\\
 \texttt{LieTensorCentre(L) }\\
 

 Inputs a finite dimensional Lie algebra $L$ over a field and returns the largest ideal $N$ such that the induced homomorphism of nonabelian tensor squares $(L \otimes L) \longrightarrow (L/N \otimes L/N)$ is an isomorphism. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Generators and relators of groups}}\logpage{[ 16, 0, 0 ]}
\hyperdef{L}{X7A2144518112F830}{}
{
 \\
 \\
 \\
 \index{CayleyGraphOfGroupDisplay}::::::::::::::::::::::::\\
 \texttt{CayleyGraphOfGroupDisplay(G,X) }\\
 \texttt{CayleyGraphOfGroupDisplay(G,X,"mozilla") }\\
 

 Inputs a finite group $G$ together with a subset $X$ of $G$. It displays the corresponding Cayley graph as a .gif file. It uses the
Mozilla web browser as a default to view the diagram. An alternative browser
can be set using a second argument. 

 The argument $G$ can also be a finite set of elements in a (possibly infinite) group containing $X$. The edges of the graph are coloured according to which element of $X$ they are labelled by. The list $X$ corresponds to the list of colours [blue, red, green, yellow, brown, black] in
that order. 

 This function requires Graphviz software. \\
 \\
 \\
 \\
 \index{IdentityAmongRelatorsDisplay}::::::::::::::::::::::::\\
 \texttt{IdentityAmongRelatorsDisplay(R,n) }\\
 \texttt{IdentityAmongRelatorsDisplay(R,n,"mozilla") }\\
 

 Inputs a free $ZG$-resolution $R$ and an integer $n$. It displays the boundary R!.boundary(3,n) as a tessellation of a sphere. It
displays the tessellation as a .gif file and uses the Mozilla web browser as a
default display mechanism. An alternative browser can be set using a second
argument. (The resolution $R$ should be reduced and, preferably, in dimension 1 it should correspond to a
Cayley graph for $G$. ) 

This function uses GraphViz software. \\
 \\
 \\
 \\
 \index{IsAspherical}::::::::::::::::::::::::\\
 \texttt{IsAspherical(F,R) }\\
 

 Inputs a free group $F$ and a set $R$ of words in $F$. It performs a test on the 2-dimensional CW-space $K$ associated to this presentation for the group $G=F/${\textless}$R${\textgreater}$^F$. 

 The function returns "true" if $K$ has trivial second homotopy group. In this case it prints: Presentation is
aspherical. 

 Otherwise it returns "fail" and prints: Presentation is NOT piece-wise
Euclidean non-positively curved. (In this case $K$ may or may not have trivial second homotopy group. But it is NOT possible to
impose a metric on K which restricts to a Euclidean metric on each 2-cell.) 

 The function uses Polymake software. \\
 \\
 \\
 \\
 \index{PresentationOfResolution}::::::::::::::::::::::::\\
 \texttt{PresentationOfResolution(R) }\\
 

 Inputs at least two terms of a reduced $ZG$-resolution $R$ and returns a record $P$ with components \\
 \\
 $P.freeGroup$ is a free group $F$, \\
 \\
 $P.relators$ is a list $S$ of words in $F$, \\
 \\
 $P.gens$ is a list of positive integers such that the $i$-th generator of the presentation corresponds to the group element
R!.elts[P[i]] . \\
 \\
 where $G$ is isomorphic to $F$ modulo the normal closure of $S$. This presentation for $G$ corresponds to the 2-skeleton of the classifying CW-space from which $R$ was constructed. The resolution $R$ requires no contracting homotopy. \\
 \\
 \\
 \\
 \index{TorsionGeneratorsAbelianGroup}::::::::::::::::::::::::\\
 \texttt{TorsionGeneratorsAbelianGroup(G) }\\
 

 Inputs an abelian group $G$ and returns a generating set $[x_1, \ldots ,x_n]$ where no pair of generators have coprime orders. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Orbit polytopes and fundamental domains}}\logpage{[ 17, 0, 0 ]}
\hyperdef{L}{X7CD67FEA7A1B6345}{}
{
 \\
 \\
 \\
 \index{CoxeterComplex}::::::::::::::::::::::::\\
 \texttt{CoxeterComplex(D)}\\
 \texttt{CoxeterComplex(D,n)}\\
 

 Inputs a Coxeter diagram $D$ of finite type. It returns a non-free ZW-resolution for the associated Coxeter
group $W$. The non-free resolution is obtained from the permutahedron of type $W$. A positive integer $n$ can be entered as an optional second variable; just the first $n$ terms of the non-free resolution are then returned. \\
 \\
 \\
 \\
 \index{ContractibleGcomplex}::::::::::::::::::::::::\\
 \texttt{ContractibleGcomplex("PSL(4,Z)")}\\
 

 Inputs one of the following strings: \\
\\
 "SL(2,Z)" , "SL(3,Z)" , "PGL(3,Z[i])" ,
"PGL(3,Eisenstein{\textunderscore}Integers)" , "PSL(4,Z)" ,
"PSL(4,Z){\textunderscore}b" , "PSL(4,Z){\textunderscore}c" ,
"PSL(4,Z){\textunderscore}d" , "Sp(4,Z)" \\
\\
 or one of the following strings \\
\\
 "SL(2,O-2)" , "SL(2,O-7)" , "SL(2,O-11)" , "SL(2,O-19)" , "SL(2,O-43)" ,
"SL(2,O-67)" , "SL(2,O-163)" \\
\\
 It returns a non-free ZG-resolution for the group $G$ described by the string. The stabilizer groups of cells are finite.
(Subscripts {\textunderscore}b , {\textunderscore}c , {\textunderscore}d
denote alternative non-free ZG-resolutions for a given group G.)\\
\\
 Data for the first list of non-free resolutions was provided provided by \textsc{Mathieu Dutour}. Data for the second list was provided by \textsc{Alexander Rahm}. \\
 \\
 \\
 \\
 \index{QuotientOfContractibleGcomplex}::::::::::::::::::::::::\\
 \texttt{QuotientOfContractibleGcomplex(C,D)}\\
 

 Inputs a non-free $ZG$-resolution $C$ and a finite subgroup $D$ of $G$ which is a subgroup of each cell stabilizer group for $C$. Each element of $D$ must preserves the orientation of any cell stabilized by it. It returns the
corresponding non-free $Z(G/D)$-resolution. (So, for instance, from the $SL(2,O)$ complex $C=ContractibleGcomplex("SL(2,O-2)");$ we can construct a $PSL(2,O)$-complex using this function.) \\
 \\
 \\
 \\
 \index{TruncatedGComplex}::::::::::::::::::::::::\\
 \texttt{TruncatedGComplex(R,m,n)}\\
 

 Inputs a non-free $ZG$-resolution $R$ and two positive integers $m $ and $ n $. It returns the non-free $ZG$-resolution consisting of those modules in $R$ of degree at least $m$ and at most $n$. \\
 \\
 \\
 \\
 \index{FundamentalDomainStandardSpaceGroup (HAPcryst)}::::::::::::::::::::::::\\
 \texttt{FundamentalDomainStandardSpaceGroup(v,G)}\\
 

 Inputs a crystallographic group G (represented using AffineCrystGroupOnRight
as in the GAP package Cryst). It also inputs a choice of vector v in the
euclidean space $R^n$ on which $G$ acts. It returns the Dirichlet-Voronoi fundamental cell for the action of $G$ on euclidean space corresponding to the vector $v$. The fundamental cell is a fundamental domain if $G$ is Bieberbach. The fundamental cell/domain is returned as a ``Polymake object''. Currently the function only applies to certain crystallographic groups. See
the manuals to HAPcryst and HAPpolymake for full details. 

 This function is part of the HAPcryst package written by \textsc{Marc Roeder} and is thus only available if HAPcryst is loaded. 

 The function requires the use of Polymake software. \\
 \\
 \\
 \\
 \index{OrbitPolytope}::::::::::::::::::::::::\\
 \texttt{OrbitPolytope(G,v,L) }\\
 

 Inputs a permutation group or matrix group $G$ of degree $n$ and a rational vector $v$ of length $n$. In both cases there is a natural action of $G$ on $v$. Let $P(G,v)$ be the convex polytope arising as the convex hull of the Euclidean points in
the orbit of $v$ under the action of $G$. The function also inputs a sublist $L$ of the following list of strings: 

 ["dimension","vertex{\textunderscore}degree", "visual{\textunderscore}graph",
"schlegel","visual"] 

 Depending on the sublist, the function: \\
 \\
 prints the dimension of the orbit polytope $P(G,v)$;\\
 \\
 prints the degree of a vertex in the graph of $P(G,v)$;\\
 \\
 visualizes the graph of $P(G,v)$;\\
 \\
 visualizes the Schlegel diagram of $P(G,v)$;\\
 \\
 visualizes $P(G,v)$ if the polytope is of dimension 2 or 3.\\
 \\
 The function uses Polymake software. \\
 \\
 \\
 \\
 \index{PolytopalComplex}::::::::::::::::::::::::\\
 \texttt{PolytopalComplex(G,v) }\\
 \texttt{PolytopalComplex(G,v,n) }\\
 

 Inputs a permutation group or matrix group $G$ of degree $n$ and a rational vector $v$ of length $n$. In both cases there is a natural action of $G$ on $v$. Let $P(G,v)$ be the convex polytope arising as the convex hull of the Euclidean points in
the orbit of $v$ under the action of $G$. The cellular chain complex $C_*=C_*(P(G,v))$ is an exact sequence of (not necessarily free) $ZG$-modules. The function returns a component object $R$ with components: \\
 \\
 $R!.dimension(k)$ is a function which returns the number of $G$-orbits of the $k$-dimensional faces in $P(G,v)$. If each $k$-face has trivial stabilizer subgroup in $G$ then $C_k$ is a free $ZG$-module of rank $R.dimension(k)$. \\
 \\
 $R!.stabilizer(k,n)$ is a function which returns the stabilizer subgroup for a face in the $n$-th orbit of $k$-faces. \\
 \\
 If all faces of dimension {\textless}$k+1$ have trivial stabilizer group then the first $k$ terms of $C_*$ constitute part of a free $ZG$-resolution. The boundary map is described by the function $boundary(k,n)$ . (If some faces have non-trivial stabilizer group then $C_*$ is not free and no attempt is made to determine signs for the boundary map.) \\
 \\
 $R!.elements$, $R!.group$, $R!.properties$ are as in a $ZG$-resolution. \\
 \\
 If an optional third input variable $n$ is used, then only the first $n$ terms of the resolution $C_*$ will be computed. 

 The function uses Polymake software. \\
 \\
 \\
 \\
 \index{PolytopalGenerators}::::::::::::::::::::::::\\
 \texttt{PolytopalGenerators(G,v) }\\
 

 Inputs a permutation group or matrix group $G$ of degree $n$ and a rational vector $v$ of length $n$. In both cases there is a natural action of $G$ on $v$, and the vector $v$ must be chosen so that it has trivial stabilizer subgroup in $G$. Let $P(G,v)$ be the convex polytope arising as the convex hull of the Euclidean points in
the orbit of $v$ under the action of $G$. The function returns a record $P$ with components: \\
 \\
 $P.generators$ is a list of all those elements $g$ in $G$ such that $g\cdot v$ has an edge in common with $v$. The list is a generating set for $G$.\\
 \\
 $P.vector$ is the vector $v$.\\
 \\
$P.hasseDiagram$ is the Hasse diagram of the cone at $v$. \\
 \\
 The function uses Polymake software. The function is joint work with Seamus
Kelly. \\
 \\
 \\
 \\
 \index{VectorStabilizer}::::::::::::::::::::::::\\
 \texttt{VectorStabilizer(G,v) }\\
 

 Inputs a permutation group or matrix group $G$ of degree $n$ and a rational vector of degree $n$. In both cases there is a natural action of $G$ on $v$ and the function returns the group of elements in $G$ that fix $v$. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Cocycles}}\logpage{[ 18, 0, 0 ]}
\hyperdef{L}{X85A9B66278AF63D9}{}
{
 \\
 \\
 \\
 \index{CcGroup (HAPcocyclic)}::::::::::::::::::::::::\\
 \texttt{CcGroup(A,f) }\\
 

 Inputs a $G$-module $A$ (i.e. an abelian $G$-outer group) and a standard 2-cocycle f $G x G ---> A$. It returns the extension group determined by the cocycle. The group is
returned as a CcGroup. 

 This is a HAPcocyclic function and thus only works when HAPcocyclic is loaded. \\
 \\
 \\
 \\
 \index{CocycleCondition}::::::::::::::::::::::::\\
 \texttt{CocycleCondition(R,n) }\\
 

 Inputs a resolution $R$ and an integer $n${\textgreater}$0$. It returns an integer matrix $M$ with the following property. Suppose $d=R.dimension(n)$. An integer vector $f=[f_1, \ldots , f_d]$ then represents a $ZG$-homomorphism $R_n \longrightarrow Z_q$ which sends the $i$th generator of $R_n$ to the integer $f_i$ in the trivial $ZG$-module $Z_q$ (where possibly $q=0$ ). The homomorphism $f$ is a cocycle if and only if $M^tf=0$ mod $q$. \\
 \\
 \\
 \\
 \index{StandardCocycle}::::::::::::::::::::::::\\
 \texttt{StandardCocycle(R,f,n) }\\
 \\
 \texttt{StandardCocycle(R,f,n,q) }\\
 

 Inputs a $ZG$-resolution $R$ (with contracting homotopy), a positive integer $n$ and an integer vector $f$ representing an $n$-cocycle $R_n \longrightarrow Z_q$ where $G$ acts trivially on $Z_q$. It is assumed $q=0$ unless a value for $q$ is entered. The command returns a function $F(g_1, ..., g_n)$ which is the standard cocycle $G_n \longrightarrow Z_q$ corresponding to $f$. At present the command is implemented only for $n=2$ or $3$. \\
 \\
 \\
 \\
 \index{Syzygy}::::::::::::::::::::::::\\
 \texttt{Syzygy(R,g) }\\
 

 Inputs a $ZG$-resolution $R$ (with contracting homotopy) and a list $g = [g[1], ..., g[n]]$ of elements in $G$. It returns a word $w$ in $R_n$. The word $w$ is the image of the $n$-simplex in the standard bar resolution corresponding to the $n$-tuple $g$. This function can be used to construct explicit standard $n$-cocycles. (Currently implemented only for n{\textless}4.) \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Words in free $ZG$-modules }}\logpage{[ 19, 0, 0 ]}
\hyperdef{L}{X78CFBBCC85F3EE32}{}
{
 \\
 \\
 \\
 \index{AddFreeWords}::::::::::::::::::::::::\\
 \texttt{AddFreeWords(v,w) }\\
 

 Inputs two words $v,w$ in a free $ZG$-module and returns their sum $v+w$. If the characteristic of $Z$ is greater than $0$ then the next function might be more efficient. \\
 \\
 \\
 \\
 \index{AddFreeWordsModP}::::::::::::::::::::::::\\
 \texttt{AddFreeWordsModP(v,w,p) }\\
 

 Inputs two words $v,w$ in a free $ZG$-module and the characteristic $p$ of $Z$. It returns the sum $v+w$. If $p=0$ the previous function might be fractionally quicker. \\
 \\
 \\
 \\
 \index{AlgebraicReduction}::::::::::::::::::::::::\\
 \texttt{AlgebraicReduction(w) }\\
 \\
 \texttt{AlgebraicReduction(w,p) }\\
 

 Inputs a word $w$ in a free $ZG$-module and returns a reduced version of the word in which all pairs of
mutually inverse letters have been cancelled. The reduction is performed in a
free abelian group unless the characteristic $p$ of $Z$ is entered. \\
 \\
 \\
 \\
 \index{MultiplyWord}::::::::::::::::::::::::\\
 \texttt{Multiply Word(n,w) }\\
 

 Inputs a word $w$ and integer $n$. It returns the scalar multiple $n\cdot w$. \\
 \\
 \\
 \\
 \index{Negate}::::::::::::::::::::::::\\
 \texttt{Negate([i,j]) }\\
 

 Inputs a pair $[i,j]$ of integers and returns $[-i,j]$. \\
 \\
 \\
 \\
 \index{NegateWord}::::::::::::::::::::::::\\
 \texttt{NegateWord(w) }\\
 

 Inputs a word $w$ in a free $ZG$-module and returns the negated word $-w$. \\
 \\
 \\
 \\
 \index{PrintZGword}::::::::::::::::::::::::\\
 \texttt{PrintZGword(w,elts) }\\
 

 Inputs a word $w$ in a free $ZG$-module and a (possibly partial but sufficient) listing elts of the elements
of $G$. The function prints the word $w$ to the screen in the form 

 $r_1E_1 + \ldots + r_nE_n$ 

 where $r_i$ are elements in the group ring $ZG$, and $E_i$ denotes the $i$-th free generator of the module. \\
 \\
 \\
 \\
 \index{TietzeReduction}::::::::::::::::::::::::\\
 \texttt{TietzeReduction(S,w) }\\
 

 Inputs a set $S$ of words in a free $ZG$-module, and a word $w$ in the module. The function returns a word $w'$ such that \texttt{\symbol{123}}$S,w'$\texttt{\symbol{125}} generates the same abelian group as
\texttt{\symbol{123}}$S,w$\texttt{\symbol{125}}. The word $w'$ is possibly shorter (and certainly no longer) than $w$. This function needs to be improved! \\
 \\
 \\
 \\
 \index{ResolutionBoundaryOfWord}::::::::::::::::::::::::\\
 \texttt{ResolutionBoundaryOfWord(R,n,w)}\\
 

 Inputs a resolution $R$, a positive integer $n$ and a list $w$ representing a word in the free module $R_n$. It returns the image of $w$ under the $n$-th boundary homomorphism. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ $FpG$-modules}}\logpage{[ 20, 0, 0 ]}
\hyperdef{L}{X7A7916087F55765C}{}
{
 \\
 \\
 \\
 \index{CompositionSeriesOfFpGModules}::::::::::::::::::::::::\\
 \texttt{CompositionSeriesOfFpGModules(M) }\\
 

 Inputs an $FpG$-module $M$ and returns a list of $FpG$-modules that constitute a composition series for $M$. \\
 \\
 \\
 \\
 \index{DirectSumOfFpGModules}::::::::::::::::::::::::\\
 \texttt{DirectSumOfFpGModules(M,N) }\\
 \texttt{DirectSumOfFpGModules([ M[1], M[2], ..., M[k] ])) }\\
 

 Inputs two $FpG$-modules $M$ and $N$ with common group and characteristic. It returns the direct sum of $M$ and $N$ as an $FpG$-Module. 

 Alternatively, the function can input a list of $FpG$-modules with common group $G$. It returns the direct sum of the list. \\
 \\
 \\
 \\
 \index{FpGModule}::::::::::::::::::::::::\\
 \texttt{FpGModule(A,P) }\\
 \texttt{FpGModule(A,G,p) }\\
 

 Inputs a $p$-group $P$ and a matrix $A$ whose rows have length a multiple of the order of $G$. It returns the ``canonical'' $FpG$-module generated by the rows of $A$. 

 A small non-prime-power group $G$ can also be input, provided the characteristic $p$ is entered as a third input variable. \\
 \\
 \\
 \\
 \index{FpGModuleDualBasis}::::::::::::::::::::::::\\
 \texttt{FpGModuleDualBasis(M) }\\
 

 Inputs an $FpG$-module $M$. It returns a record $R$ with two components: \\
 \\
$R.freeModule$ is the free module $FG$ of rank one.\\
 \\
$R.basis$ is a list representing an $F$-basis for the module $Hom_{FG}(M,FG)$. Each term in the list is a matrix $A$ whose rows are vectors in $FG$ such that $M!.generators[i] \longrightarrow A[i]$ extends to a module homomorphism $M \longrightarrow FG$. \\
 \\
 \\
 \\
 \\
 \\
 \index{FpGModuleHomomorphism}::::::::::::::::::::::::\\
 \texttt{FpGModuleHomomorphism(M,N,A) }\\
 \texttt{FpGModuleHomomorphismNC(M,N,A) }\\
 

 Inputs $FpG$-modules $M$ and $N$ over a common $p$-group $G$. Also inputs a list $A$ of vectors in the vector space spanned by $N!.matrix$. It tests that the function 

 $ M!.generators[i] \longrightarrow A[i]$ 

 extends to a homomorphism of $FpG$-modules and, if the test is passed, returns the corresponding $FpG$-module homomorphism. If the test is failed it returns fail. 

 The "NC" version of the function assumes that the input defines a homomorphism
and simply returns the $FpG$-module homomorphism. \\
 \\
 \\
 \\
 \index{DesuspensionFpGModule}::::::::::::::::::::::::\\
 \texttt{ DesuspensionFpGModule(M,n)}\\
 \texttt{DesuspensionFpGModule(R,n) }\\
 

 Inputs a positive integer $n$ and and FpG-module $M$. It returns an FpG-module $D^nM$ which is mathematically related to $M$ via an exact sequence $ 0 \longrightarrow D^nM \longrightarrow R_n \longrightarrow \ldots
\longrightarrow R_0 \longrightarrow M \longrightarrow 0$ where $R_\ast$ is a free resolution. (If $G=Group(M)$ is of prime-power order then the resolution is minimal.) 

 Alternatively, the function can input a positive integer $n$ and at least $n$ terms of a free resolution $R$ of $M$. \\
 \\
 \\
 \\
 \index{RadicalOfFpGModule}::::::::::::::::::::::::\\
 \texttt{RadicalOfFpGModule(M) }\\
 

 Inputs an $FpG$-module $M$ with $G$ a $p$-group, and returns the Radical of $M$ as an $FpG$-module. (Ig $G$ is not a $p$-group then a submodule of the radical is returned. \\
 \\
 \\
 \\
 \index{RadicalSeriesOfFpGModule}::::::::::::::::::::::::\\
 \texttt{RadicalSeriesOfFpGModule(M) }\\
 

 Inputs an $FpG$-module $M$ and returns a list of $FpG$-modules that constitute the radical series for $M$. \\
 \\
 \\
 \\
 \index{GeneratorsOfFpGModule}::::::::::::::::::::::::\\
 \texttt{GeneratorsOfFpGModule(M) }\\
 

 Inputs an $FpG$-module $M$ and returns a matrix whose rows correspond to a minimal generating set for $M$. \\
 \\
 \\
 \\
 \index{ImageOfFpGModuleHomomorphism}::::::::::::::::::::::::\\
 \texttt{ImageOfFpGModuleHomomorphism(f) }\\
 

 Inputs an $FpG$-module homomorphism $f:M \longrightarrow N$ and returns its image $f(M)$ as an $FpG$-module. \\
 \\
 \\
 \\
 \index{GroupAlgebraAsFpGModule}::::::::::::::::::::::::\\
 \texttt{GroupAlgebraAsFpGModule(G) }\\
 

 Inputs a $p$-group $G$ and returns its mod $p$ group algebra as an $FpG$-module. \\
 \\
 \\
 \\
 \index{IntersectionOfFpGModules}::::::::::::::::::::::::\\
 \texttt{IntersectionOfFpGModules(M,N) }\\
 

 Inputs two $FpG$-modules $M, N$ arising as submodules in a common free module $(FG)^n$ where $G$ is a finite group and $F$ the field of $p$-elements. It returns the $FpG$-module arising as the intersection of $M$ and $N$. \\
 \\
 \\
 \\
 \index{IsFpGModuleHomomorphismData}::::::::::::::::::::::::\\
 \texttt{IsFpGModuleHomomorphismData(M,N,A) }\\
 

 Inputs $FpG$-modules $M$ and $N$ over a common $p$-group $G$. Also inputs a list $A$ of vectors in the vector space spanned by $N!.matrix$. It returns true if the function 

 $ M!.generators[i] \longrightarrow A[i]$ 

 extends to a homomorphism of $FpG$-modules. Otherwise it returns false. \\
 \\
 \\
 \\
 \index{MaximalSubmoduleOfFpGModule}::::::::::::::::::::::::\\
 \texttt{MaximalSubmoduleOfFpGModule(M) }\\
 

 Inputs an $FpG$-module $M$ and returns one maximal $FpG$-submodule of $M$. \\
 \\
 \\
 \\
 \index{MaximalSubmodulesOfFpGModule}::::::::::::::::::::::::\\
 \texttt{MaximalSubmodulesOfFpGModule(M) }\\
 

 Inputs an $FpG$-module $M$ and returns the list of maximal $FpG$-submodules of $M$. \\
 \\
 \\
 \\
 \index{MultipleOfFpGModule}::::::::::::::::::::::::\\
 \texttt{MultipleOfFpGModule(w,M) }\\
 

 Inputs an $FpG$-module $M$ and a list $w:=[g_1 , ..., g_t]$ of elements in the group $G=M!.group$. The list $w$ can be thought of as representing the element $w=g_1 + \ldots + g_t$ in the group algebra $FG$, and the function returns a semi-echelon matrix $B$ which is a basis for the vector subspace $wM$ . \\
 \\
 \\
 \\
 \index{ProjectedFpGModule}::::::::::::::::::::::::\\
 \texttt{ProjectedFpGModule(M,k) }\\
 

 Inputs an $FpG$-module $M$ of ambient dimension $n|G|$, and an integer $k$ between $1$ and $n$. The module $M$ is a submodule of the free module $(FG)^n$ . Let $M_k$ denote the intersection of $M$ with the last $k$ summands of $(FG)^n$ . The function returns the image of the projection of $M_k$ onto the $k$-th summand of $(FG)^n$ . This image is returned an $FpG$-module with ambient dimension $|G|$. \\
 \\
 \\
 \\
 \index{RandomHomomorphismOfFpGModules}::::::::::::::::::::::::\\
 \texttt{RandomHomomorphismOfFpGModules(M,N) }\\
 

 Inputs two $FpG$-modules $M$ and $N$ over a common group $G$. It returns a random matrix $A$ whose rows are vectors in $N$ such that the function 

 $ M!.generators[i] \longrightarrow A[i]$ 

 extends to a homomorphism $M \longrightarrow N$ of $FpG$-modules. (There is a problem with this function at present.) \\
 \\
 \\
 \\
 \index{Rank}::::::::::::::::::::::::\\
 \texttt{Rank(f) }\\
 

 Inputs an $FpG$-module homomorphism $f:M \longrightarrow N$ and returns the dimension of the image of $f$ as a vector space over the field $F$ of $p$ elements. \\
 \\
 \\
 \\
 \index{SumOfFpGModules}::::::::::::::::::::::::\\
 \texttt{SumOfFpGModules(M,N) }\\
 

 Inputs two $FpG$-modules $M, N$ arising as submodules in a common free module $(FG)^n$ where $G$ is a finite group and $F$ the field of $p$-elements. It returns the $FpG$-Module arising as the sum of $M$ and $N$. \\
 \\
 \\
 \\
 \index{SumOp}::::::::::::::::::::::::\\
 \texttt{SumOp(f,g) }\\
 

 Inputs two $FpG$-module homomorphisms $f,g:M \longrightarrow N$ with common sorce and common target. It returns the sum $f+g:M \longrightarrow N$ . (This operation is also available using "+". \\
 \\
 \\
 \\
 \index{VectorsToFpGModuleWords}::::::::::::::::::::::::\\
 \texttt{VectorsToFpGModuleWords(M,L) }\\
 

 Inputs an $FpG$-module $M$ and a list $L=[v_1,\ldots ,v_k]$ of vectors in $M$. It returns a list $L'= [x_1,...,x_k]$ . Each $x_j=[[W_1,G_1],...,[W_t,G_t]]$ is a list of integer pairs corresponding to an expression of $v_j$ as a word 

 $ v_j = g_1*w_1 + g_2*w_1 + ... + g_t*w_t $ 

 where 

 $g_i=Elements(M!.group)[G_i]$ 

 $w_i=GeneratorsOfFpGModule(M)[W_i]$ . \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Meataxe modules}}\logpage{[ 21, 0, 0 ]}
\hyperdef{L}{X85B05BBA78ED7BE2}{}
{
 \\
 \\
 \\
 \index{DesuspensionMtxModule}::::::::::::::::::::::::\\
 \texttt{DesuspensionMtxModule(M)}\\
 

 Inputs a meataxe module $M$ over the field of $p$ elements and returns an FpG-module DM. The two modules are related
mathematically by the existence of a short exact sequence $DM \longrightarrow FM \longrightarrow M$ with $FM$ a free module. Thus the homological properties of $DM$ are equal to those of $M$ with a dimension shift. 

 (If $G:=Group(M.generators)$ is a $p$-group then $FM$ is a projective cover of $M$ in the sense that the homomorphism $FM \longrightarrow M$ does not factor as $FM \longrightarrow P \longrightarrow M$ for any projective module $P$.) \\
 \\
 \\
 \\
 \index{FpG{\textunderscore}to{\textunderscore}MtxModule}::::::::::::::::::::::::\\
 \texttt{FpG{\textunderscore}to{\textunderscore}MtxModule(M)}\\
 

 Inputs an FpG-module $M$ and returns an isomorphic meataxe module. \\
 \\
 \\
 \\
 \index{GeneratorsOfMtxModule}::::::::::::::::::::::::\\
 \texttt{GeneratorsOfMtxModule(M)}\\
 

 Inputs a meataxe module $M$ acting on, say, the vector space $V$. The function returns a minimal list of row vectors in $V$ which generate $V$ as a $G$-module (where G=Group(M.generators) ). \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ G-Outer Groups}}\logpage{[ 22, 0, 0 ]}
\hyperdef{L}{X7D02CE0A83211FB7}{}
{
 \\
 \\
 \\
 \index{GOuterGroup}::::::::::::::::::::::::\\
 \texttt{GOuterGroup(E,N)}\\
 \texttt{GOuterGroup()}\\
 

 Inputs a group $E$ and normal subgroup $N$. It returns $N$ as a $G$-outer group where $G=E/N$. 

 The function can be used without an argument. In this case an empty outer
group $C$ is returned. The components must be set using SetActingGroup(C,G),
SetActedGroup(C,N) and SetOuterAction(C,alpha). \\
 \\
 \\
 \\
 \index{GOuterGroupHomomorphismNC}::::::::::::::::::::::::\\
 \texttt{GOuterGroupHomomorphismNC(A,B,phi)}\\
 \texttt{GOuterGroupHomomorphismNC()}\\
 

 Inputs G-outer groups $A$ and $B$ with common acting group, and a group homomorphism phi:ActedGroup(A)
--{\textgreater} ActedGroup(B). It returns the corresponding G-outer
homomorphism PHI:A--{\textgreater} B. No check is made to verify that phi is
actually a group homomorphism which preserves the G-action. 

 The function can be used without an argument. In this case an empty outer
group homomorphism $PHI$ is returned. The components must then be set. \\
 \\
 \\
 \\
 \index{GOuterHomomorphismTester}::::::::::::::::::::::::\\
 \texttt{GOuterHomomorphismTester(A,B,phi)}\\
 

 Inputs G-outer groups $A$ and $B$ with common acting group, and a group homomorphism phi:ActedGroup(A)
--{\textgreater} ActedGroup(B). It tests whether phi is a group homomorphism
which preserves the G-action. 

 The function can be used without an argument. In this case an empty outer
group homomorphism $PHI$ is returned. The components must then be set. \\
 \\
 \\
 \\
 \index{Centre}::::::::::::::::::::::::\\
 \texttt{Centre(A)}\\
 

 Inputs G-outer group $A$ and returns the group theoretic centre of ActedGroup(A) as a G-outer group. \\
 \\
 \\
 \\
 \index{DirectProductGog}::::::::::::::::::::::::\\
 \texttt{DirectProductGog(A,B)}\\
 \texttt{DirectProductGog(Lst)}\\
 

 Inputs G-outer groups $A$ and $B$ with common acting group, and returns their group-theoretic direct product as
a G-outer group. The outer action on the direct product is the diagonal one. 

 The function also applies to a list Lst of G-outer groups with common acting
group. 

 For a direct product D constructed using this function, the embeddings and
projections can be obtained (as G-outer group homomorphisms) using the
functions Embedding(D,i) and Projection(D,i). \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Cat-1-groups}}\logpage{[ 23, 0, 0 ]}
\hyperdef{L}{X7B54B8CA841C517B}{}
{
 \\
 \\
 \\
 \index{AutomorphismGroupAsCatOneGroup}::::::::::::::::::::::::\\
 \texttt{AutomorphismGroupAsCatOneGroup(G)}\\
 

 Inputs a group $G$ and returns the Cat-1-group $C$ corresponding to the crossed module $G\rightarrow Aut(G)$. \\
 \\
 \\
 \\
 \index{HomotopyGroup}::::::::::::::::::::::::\\
 \texttt{HomotopyGroup(C,n)}\\
 

 Inputs a cat-1-group $C$ and an integer n. It returns the $n$th homotopy group of $C$. \\
 \\
 \\
 \\
 \index{HomotopyModule}::::::::::::::::::::::::\\
 \texttt{HomotopyModule(C,2)}\\
 

 Inputs a cat-1-group $C$ and an integer n=2. It returns the second homotopy group of $C$ as a G-module (i.e. abelian G-outer group) where G is the fundamental group of
C. \\
 \\
 \\
 \\
 \index{QuasiIsomorph}::::::::::::::::::::::::\\
 \texttt{QuasiIsomorph(C)}\\
 

 Inputs a cat-1-group $C$ and returns a cat-1-group $D$ for which there exists some homomorphism $C\rightarrow D$ that induces isomorphisms on homotopy groups. 

 This function was implemented by \textsc{Le Van Luyen}. \\
 \\
 \\
 \\
 \index{ModuleAsCatOneGroup}::::::::::::::::::::::::\\
 \texttt{ModuleAsCatOneGroup(G,alpha,M)}\\
 

 Inputs a group $G$, an abelian group $M$ and a homomorphism $\alpha\colon G\rightarrow Aut(M)$. It returns the Cat-1-group $C$ corresponding th the zero crossed module $0\colon M\rightarrow G$. \\
 \\
 \\
 \\
 \index{MooreComplex}::::::::::::::::::::::::\\
 \texttt{MooreComplex(C)}\\
 

 Inputs a cat-1-group $C$ and returns its Moore complex as a G-complex (i.e. as a complex of groups
considered as 1-outer groups). \\
 \\
 \\
 \\
 \index{NormalSubgroupAsCatOneGroup}::::::::::::::::::::::::\\
 \texttt{NormalSubgroupAsCatOneGroup(G,N)}\\
 

 Inputs a group $G$ with normal subgroup $N$. It returns the Cat-1-group $C$ corresponding th the inclusion crossed module $ N\rightarrow G$. \\
 \\
 \\
 \\
 \index{XmodToHAP}::::::::::::::::::::::::\\
 \texttt{XmodToHAP(C)}\\
 

 Inputs a cat-1-group $C$ obtained from the Xmod package and returns a cat-1-group $D$ for which IsHapCatOneGroup(D) returns true. 

 It returns "fail" id $C$ has not been produced by the Xmod package. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Simplicial groups}}\logpage{[ 24, 0, 0 ]}
\hyperdef{L}{X7D818E5F80F4CF63}{}
{
 \\
 \\
 \\
 \index{NerveOfCatOneGroup}::::::::::::::::::::::::\\
 \texttt{NerveOfCatOneGroup(G,n)}\\
 

 Inputs a cat-1-group $G$ and a positive integer $n$. It returns the low-dimensional part of the nerve of $G$ as a simplicial group of length $n$. \\
 \\
 This function applies both to cat-1-groups for which IsHapCatOneGroup(G) is
true, and to cat-1-groups produced using the Xmod package. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{EilenbergMacLaneSimplicialGroup}::::::::::::::::::::::::\\
 \texttt{EilenbergMacLaneSimplicialGroup(G,n,dim)}\\
 

 Inputs a group $G$, a positive integer $n$, and a positive integer $dim $. The function returns the first $1+dim$ terms of a simplicial group with $n-1$st homotopy group equal to $G$ and all other homotopy groups equal to zero. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{EilenbergMacLaneSimplicialGroupMap}::::::::::::::::::::::::\\
 \texttt{EilenbergMacLaneSimplicialGroupMap(f,n,dim)}\\
 

 Inputs a group homomorphism $f:G\rightarrow Q$, a positive integer $n$, and a positive integer $dim $. The function returns the first $1+dim$ terms of a simplicial group homomorphism $f:K(G,n) \rightarrow K(Q,n)$ of Eilenberg-MacLane simplicial groups. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{MooreComplex}::::::::::::::::::::::::\\
 \texttt{MooreComplex(G)}\\
 

 Inputs a simplicial group $G$ and returns its Moore complex as a $G$-complex. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{ChainComplexOfSimplicialGroup}::::::::::::::::::::::::\\
 \texttt{ChainComplexOfSimplicialGroup(G)}\\
 

 Inputs a simplicial group $G$ and returns the cellular chain complex $C$ of a CW-space $X$ represented by the homotopy type of the simplicial group. Thus the homology
groups of $C$ are the integral homology groups of $X$. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{SimplicialGroupMap}::::::::::::::::::::::::\\
 \texttt{SimplicialGroupMap(f)}\\
 

 Inputs a homomorphism $f:G\rightarrow Q$ of simplicial groups. The function returns an induced map $f:C(G) \rightarrow C(Q)$ of chain complexes whose homology is the integral homology of the simplicial
group G and Q respectively. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{HomotopyGroup}::::::::::::::::::::::::\\
 \texttt{HomotopyGroup(G,n)}\\
 

 Inputs a simplicial group $G$ and a positive integer $n$. The integer $n$ must be less than the length of $G$. It returns, as a group, the (n)-th homology group of its Moore complex. Thus
HomotopyGroup(G,0) returns the "fundamental group" of $G$. \\
 \\
 \\
 \\
 \index{Bar Resolution}::::::::::::::::::::::::\\
 \texttt{Representation of elements in the bar resolution}\\
 

 For a group G we denote by $B_n(G)$ the free $\mathbb ZG$-module with basis the lists $[g_1 | g_2 | ... | g_n]$ where the $g_i$ range over $G$. \\
 \\
 We represent a word \\
 \\
 $w = h_1.[g_{11} | g_{12} | ... | g_{1n}] - h_2.[g_{21} | g_{22} | ... |
g_{2n}] + ... + h_k.[g_{k1} | g_{k2} | ... | g_{kn}] $ \\
 \\
 in $B_n(G)$ as a list of lists: \\
 \\
 $ [ [+1,h_1,g_{11} , g_{12} , ... , g_{1n}] , [-1, h_2,g_{21} , g_{22} , ... |
g_{2n}] + ... + [+1, h_k,g_{k1} , g_{k2} , ... , g_{kn}] $. \\
 \\
 \\
 \\
 \index{BarResolutionBoundary}::::::::::::::::::::::::\\
 \texttt{BarResolutionBoundary(w)}\\
 

 This function inputs a word $w$ in the bar resolution module $B_n(G)$ and returns its image under the boundary homomorphism $d_n\colon B_n(G) \rightarrow B_{n-1}(G)$ in the bar resolution. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{BarResolutionHomotopy}::::::::::::::::::::::::\\
 \texttt{BarResolutionHomotopy(w)}\\
 

 This function inputs a word $w$ in the bar resolution module $B_n(G)$ and returns its image under the contracting homotopy $h_n\colon B_n(G) \rightarrow B_{n+1}(G)$ in the bar resolution. \\
 \\
 This function is currently being implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{Bar Complex}::::::::::::::::::::::::\\
 \texttt{Representation of elements in the bar complex}\\
 

 For a group G we denote by $BC_n(G)$ the free abelian group with basis the lists $[g_1 | g_2 | ... | g_n]$ where the $g_i$ range over $G$. \\
 \\
 We represent a word \\
 \\
 $w = [g_{11} | g_{12} | ... | g_{1n}] - [g_{21} | g_{22} | ... | g_{2n}] + ...
+ [g_{k1} | g_{k2} | ... | g_{kn}] $ \\
 \\
 in $BC_n(G)$ as a list of lists: \\
 \\
 $ [ [+1,g_{11} , g_{12} , ... , g_{1n}] , [-1, g_{21} , g_{22} , ... | g_{2n}] +
... + [+1, g_{k1} , g_{k2} , ... , g_{kn}] $. \\
 \\
 \\
 \\
 \index{BarComplexBoundary}::::::::::::::::::::::::\\
 \texttt{BarComplexBoundary(w)}\\
 

 This function inputs a word $w$ in the n-th term of the bar complex $BC_n(G)$ and returns its image under the boundary homomorphism $d_n\colon BC_n(G) \rightarrow BC_{n-1}(G)$ in the bar complex. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{BarResolutionEquivalence}::::::::::::::::::::::::\\
 \texttt{BarResolutionEquivalence(R)}\\
 

 This function inputs a free $ZG$-resolution $R$. It returns a component object HE with components \\
 \\
 HE!.phi(n,w) is a function which inputs a non-negative integer $n$ and a word $w$ in $B_n(G)$. It returns the image of $w$ in $R_n$ under a chain equivalence $\phi\colon B_n(G) \rightarrow R_n$.\\
 \\
 HE!.psi(n,w) is a function which inputs a non-negative integer $n$ and a word $w$ in $R_n$. It returns the image of $w$ in $B_n(G)$ under a chain equivalence $\psi\colon R_n \rightarrow B_n(G)$.\\
 \\
 HE!.equiv(n,w) is a function which inputs a non-negative integer $n$ and a word $w$ in $B_n(G)$. It returns the image of $w$ in $B_{n+1}(G)$ under a $ZG$-equivariant homomorphism \\
 \\
 $equiv(n,-) \colon B_n(G) \rightarrow B_{n+1}(G)$ \\
 \\
 satisfying 
\[w - \psi ( \phi (w)) = d(n+1, equiv(n,w)) + equiv(n-1,d(n,w)) . \]
 where $d(n,-)\colon B_n(G) \rightarrow B_{n-1}(G)$ is the boundary homomorphism in the bar resolution. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{BarComplexEquivalence}::::::::::::::::::::::::\\
 \texttt{BarComplexEquivalence(R)}\\
 

 This function inputs a free $ZG$-resolution $R$. It first constructs the chain complex $T=TensorWithIntegerts(R)$. The function returns a component object HE with components \\
 \\
 HE!.phi(n,w) is a function which inputs a non-negative integer $n$ and a word $w$ in $BC_n(G)$. It returns the image of $w$ in $T_n$ under a chain equivalence $\phi\colon BC_n(G) \rightarrow T_n$.\\
 \\
 HE!.psi(n,w) is a function which inputs a non-negative integer $n$ and an element $w$ in $T_n$. It returns the image of $w$ in $BC_n(G)$ under a chain equivalence $\psi\colon T_n \rightarrow BC_n(G)$.\\
 \\
 HE!.equiv(n,w) is a function which inputs a non-negative integer $n$ and a word $w$ in $BC_n(G)$. It returns the image of $w$ in $BC_{n+1}(G)$ under a homomorphism \\
 \\
 $equiv(n,-) \colon BC_n(G) \rightarrow BC_{n+1}(G)$ \\
 \\
 satisfying 
\[w - \psi ( \phi (w)) = d(n+1, equiv(n,w)) + equiv(n-1,d(n,w)) . \]
 where $d(n,-)\colon BC_n(G) \rightarrow BC_{n-1}(G)$ is the boundary homomorphism in the bar complex. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 \\
 \index{Bar Cocomplex}::::::::::::::::::::::::\\
 \texttt{Representation of elements in the bar cocomplex}\\
 

 For a group G we denote by $BC^n(G)$ the free abelian group with basis the lists $[g_1 | g_2 | ... | g_n]$ where the $g_i$ range over $G$. \\
 \\
 We represent a word \\
 \\
 $w = [g_{11} | g_{12} | ... | g_{1n}] - [g_{21} | g_{22} | ... | g_{2n}] + ...
+ [g_{k1} | g_{k2} | ... | g_{kn}] $ \\
 \\
 in $BC^n(G)$ as a list of lists: \\
 \\
 $ [ [+1,g_{11} , g_{12} , ... , g_{1n}] , [-1, g_{21} , g_{22} , ... | g_{2n}] +
... + [+1, g_{k1} , g_{k2} , ... , g_{kn}] $. \\
 \\
 \\
 \\
 \index{BarCocomplexCoboundary}::::::::::::::::::::::::\\
 \texttt{BarCocomplexCoboundary(w)}\\
 

 This function inputs a word $w$ in the n-th term of the bar cocomplex $BC^n(G)$ and returns its image under the coboundary homomorphism $d^n\colon BC^n(G) \rightarrow BC^{n+1}(G)$ in the bar cocomplex. \\
 \\
 This function was implemented by \textsc{Van Luyen Le}. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Coxeter diagrams and graphs of groups}}\logpage{[ 25, 0, 0 ]}
\hyperdef{L}{X79D0502085B6734A}{}
{
 \\
 \\
 \\
 \index{CoxeterDiagramComponents}::::::::::::::::::::::::\\
 \texttt{CoxeterDiagramComponents(D) }\\
 

 Inputs a Coxeter diagram $D$ and returns a list $[D_1, ..., D_d]$ of the maximal connected subgraphs $D_i$. \\
 \\
 \\
 \\
 \index{CoxeterDiagramDegree}::::::::::::::::::::::::\\
 \texttt{CoxeterDiagramDegree(D,v) }\\
 

 Inputs a Coxeter diagram $D$ and vertex $v$. It returns the degree of $v$ (i.e. the number of edges incident with $v$). \\
 \\
 \\
 \\
 \index{CoxeterDiagramDisplay}::::::::::::::::::::::::\\
 \texttt{CoxeterDiagramDisplay(D) }\\
 \texttt{CoxeterDiagramDisplay(D,"web browser") }\\
 

 Inputs a Coxeter diagram $D$ and displays it as a .gif file. It uses the Mozilla web browser as a default
to view the diagram. An alternative browser can be set using a second
argument. 

 This function requires Graphviz software. \\
 \\
 \\
 \\
 \index{CoxeterDiagramFpArtinGroup}::::::::::::::::::::::::\\
 \texttt{CoxeterDiagramFpArtinGroup(D) }\\
 

 Inputs a Coxeter diagram $D$ and returns the corresponding finitely presented Artin group. \\
 \\
 \\
 \\
 \index{CoxeterDiagramFpCoxeterGroup}::::::::::::::::::::::::\\
 \texttt{CoxeterDiagramFpCoxeterGroup(D) }\\
 

 Inputs a Coxeter diagram $D$ and returns the corresponding finitely presented Coxeter group. \\
 \\
 \\
 \\
 \index{CoxeterDiagramIsSpherical}::::::::::::::::::::::::\\
 \texttt{CoxeterDiagramIsSpherical(D) }\\
 

 Inputs a Coxeter diagram $D$ and returns "true" if the associated Coxeter groups is finite, and returns
"false" otherwise. \\
 \\
 \\
 \\
 \index{CoxeterDiagramMatrix}::::::::::::::::::::::::\\
 \texttt{CoxeterDiagramMatrix(D) }\\
 

 Inputs a Coxeter diagram $D$ and returns a matrix representation of it. The matrix is given as a function $DiagramMatrix(D)(i,j)$ where $i,j$ can range over the vertices. \\
 \\
 \\
 \\
 \index{CoxeterSubDiagram}::::::::::::::::::::::::\\
 \texttt{CoxeterSubDiagram(D,V) }\\
 

 Inputs a Coxeter diagram $D$ and a subset $V$ of its vertices. It returns the full sub-diagram of $D$ with vertex set $V$. \\
 \\
 \\
 \\
 \index{CoxeterDiagramVertices}::::::::::::::::::::::::\\
 \texttt{CoxeterDiagramVertices(D) }\\
 

 Inputs a Coxeter diagram $D$ and returns its set of vertices. \\
 \\
 \\
 \\
 \index{EvenSubgroup}::::::::::::::::::::::::\\
 \texttt{EvenSubgroup(G) }\\
 

 Inputs a group $G$ and returns a subgroup $G^+$. The subgroup is that generated by all products $xy$ where $x$ and $y$ range over the generating set for $G$ stored by GAP. The subgroup is probably only meaningful when $G$ is an Artin or Coxeter group. \\
 \\
 \\
 \\
 \index{GraphOfGroupsDisplay}::::::::::::::::::::::::\\
 \texttt{ GraphOfGroupsDisplay(D) }\\
 \texttt{GraphOfGroupsDisplay(D,"web browser") }\\
 

 Inputs a graph of groups $D$ and displays it as a .gif file. It uses the Mozilla web browser as a default
to view the diagram. An alternative browser can be set using a second
argument. 

 This function requires Graphviz software. \\
 \\
 \\
 \\
 \index{GraphOfResolutions}::::::::::::::::::::::::\\
 \texttt{ GraphOfResolutions(D,n) }\\
 

 Inputs a graph of groups $D$ and a positive integer $n$. It returns a graph of resolutions, each resolution being of length $n$. It uses the function ResolutionGenericGroup() to produce the resolutions. \\
 \\
 \\
 \\
 \index{GraphOfGroups}::::::::::::::::::::::::\\
 \texttt{ GraphOfGroups(D) }\\
 

 Inputs a graph of resolutions $D$ and returns the corresponding graph of groups. \\
 \\
 \\
 \\
 \index{GraphOfResolutionsDisplay}::::::::::::::::::::::::\\
 \texttt{ GraphOfResolutionsDisplay(D) }\\
 

 Inputs a graph of resolutions $D$ and displays it as a .gif file. It uses the Mozilla web browser as a default
to view the diagram. 

 This function requires Graphviz software. \\
 \\
 \\
 \\
 \index{GraphOfGroupsTest}::::::::::::::::::::::::\\
 \texttt{GraphOfGroupsTest(D) }\\
 

 Inputs an object $D$ and itries to test whether it is a Graph of Groups. However, it DOES NOT test
the injectivity of any homomorphisms. It returns true if $D$ passes the test, and false otherwise. 

 Note that there is no function $IsHapGraphOfGroups()$ because no special data type has been created for these graphs. \\
 \\
 \\
 \\
 \index{TreeOfGroupsToContractibleGcomplex}::::::::::::::::::::::::\\
 \texttt{TreeOfGroupsToContractibleGcomplex(D,G) }\\
 

 Inputs a graph of groups $D$ which is a tree, and also inputs the fundamental group $G$ of the tree in a form which contains each of the groups in the graph as
subgroups. It returns a corresponding contractible G-complex. \\
 \\
 \\
 \\
 \index{TreeOfResolutionsToContractibleGcomplex}::::::::::::::::::::::::\\
 \texttt{TreeOfResolutionsToContractibleGcomplex(D,G) }\\
 

 Inputs a graph of resolutions $D$ which is a tree, and also inputs the fundamental group $G$ of the tree in a form which contains each of the groups in the graph as
subgroups. It returns a corresponding contractible G-complex. The resolutions
are stored as a component of the contractible $G$-complex. \\
 \\
 \\
 }

 \# 
\chapter{\textcolor{Chapter }{Torsion subcomplexes}}\logpage{[ 26, 0, 0 ]}
\hyperdef{L}{X8213E6467969C33F}{}
{
 \begin{center}
\begin{tabular}{|l|} The torsion subcomplexes subpackage has been conceived and implemented by \textsc{Alexander D. Rahm}. \\
 \index{IsPnormal} \texttt{IsPnormal( G, p)} 

 Inputs a finite group $G$ and a prime $p$. Checks if the group G is p-normal for the prime p. Zassenhaus defines a
finite group to be p-normal if the center of one of its Sylow p-groups is the
center of every Sylow p-group in which it is contained. \\
 \index{TorsionSubcomplex} \texttt{TorsionSubcomplex( groupName, p)} 

 Inputs a cell complex with action of a group. In HAP, presently the following
cell complexes with stabilisers fixing their cells pointwise are available,
specified by the following "groupName" strings: \\
\\
 "SL(2,O-2)" , "SL(2,O-7)" , "SL(2,O-11)" , "SL(2,O-19)" , "SL(2,O-43)" ,
"SL(2,O-67)" , "SL(2,O-163)", \\
\\
 where the symbol O[-m] stands for the ring of integers in the imaginary
quadratic number field Q(sqrt(-m)), the latter being the extension of the
field of rational numbers by the square root of minus the square-free positive
integer m. The additive structure of this ring O[-m] is given as the module
Z[omega] over the natural integers Z with basis \texttt{\symbol{123}}1,
omega\texttt{\symbol{125}}, and omega being the square root of minus m if m is
congruent to 1 or 2 modulo four; else, in the case m congruent 3 modulo 4, the
element omega is the arithmetic mean with 1, namely $(1+sqrt(-m))/2$. \\
\\
 The function TorsionSubcomplex prints the cells with p-torsion in their
stabilizer on the screen and returns the incidence matrix of the 1-skeleton of
this cellular subcomplex, as well as a Boolean value on whether the cell
complex has its cell stabilisers fixing their cells pointwise. \\
\\
 It is also possible to input the cell complexes \\
\\
 "SL(2,Z)" , "SL(3,Z)" , "PGL(3,Z[i])" ,
"PGL(3,Eisenstein{\textunderscore}Integers)" , "PSL(4,Z)" ,
"PSL(4,Z){\textunderscore}b" , "PSL(4,Z){\textunderscore}c" ,
"PSL(4,Z){\textunderscore}d" , "Sp(4,Z)" \\
\\
 provided by \textsc{Mathieu Dutour}. \\
 \index{DisplayAvailableCellComplexes} \texttt{DisplayAvailableCellComplexes();} 

 Displays the cell complexes that are available in HAP. \\
 \index{VisualizeTorsionSkeleton} \texttt{VisualizeTorsionSkeleton( groupName, p)} 

 Executes the function TorsionSubcomplex( groupName, p) and visualizes its
output, namely the incidence matrix of the 1-skeleton of the p-torsion
subcomplex, as a graph. \\
 \index{ReduceTorsionSubcomplex} \texttt{ReduceTorsionSubcomplex( groupName, p)} 

 This function start with the same operations as the function
TorsionSubcomplex( groupName, p), and if the cell stabilisers are fixing their
cells pointwise, it continues as follows. \\
\\
 It prints on the screen which cells to merge and which edges to cut off in
order to reduce the p-torsion subcomplex without changing the equivariant
Farrell cohomology. Finally, it prints the representative cells, their
stabilizers and the Abelianization of the latter. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Simplicial Complexes}}\logpage{[ 27, 0, 0 ]}
\hyperdef{L}{X7AC76D657C578FEE}{}
{
 \\
 \\
 \\
 \texttt{Homology(T,n)}\\
 \texttt{Homology(T)}\\
 

 Inputs a pure cubical complex, or cubical complex, or simplicial complex $T$ and a non-negative integer $n$. It returns the n-th integral homology of $T$ as a list of torsion integers. If no value of $n$ is input then the list of all homologies of $T$ in dimensions 0 to Dimension(T) is returned . \\
 \\
 \\
 \\
 \texttt{RipsHomology(G,n)}\\
 \texttt{RipsHomology(G,n,p)}\\
 

 Inputs a graph $G$, a non-negative integer $n$ (and optionally a prime number $p$). It returns the integral homology (or mod p homology) in degree $n$ of the Rips complex of $G$. \\
 \\
 \\
 \\
 \index{Bettinumbers}::::::::::::::::::::::::\\
 \texttt{ Bettinumbers(T,n)}\\
 \texttt{ Bettinumbers(T)}\\
 

 Inputs a pure cubical complex, or cubical complex, simplicial complex or chain
complex $T$ and a non-negative integer $n$. The rank of the n-th rational homology group $H_n(T,\mathbb Q)$ is returned. If no value for n is input then the list of Betti numbers in
dimensions 0 to Dimension(T) is returned . \\
 \\
 \\
 \\
 \texttt{ChainComplex(T)}\\
 

 Inputs a pure cubical complex, or cubical complex, or simplicial complex $T$ and returns the (often very large) cellular chain complex of $T$. \\
 \\
 \\
 \\
 \index{CechComplexOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{CechComplexOfPureCubicalComplex(T)}\\
 

 Inputs a d-dimensional pure cubical complex $T$ and returns a simplicial complex $S$. The simplicial complex $S$ has one vertex for each d-cube in $T$, and an n-simplex for each collection of n+1 d-cubes with non-trivial common
intersection. The homotopy types of $T$ and $S$ are equal. \\
 \\
 \\
 \\
 \index{PureComplexToSimplicialComplex}::::::::::::::::::::::::\\
 \texttt{PureComplexToSimplicialComplex(T,k)}\\
 

 Inputs either a d-dimensional pure cubical complex $T$ or a d-dimensional pure permutahedral complex $T$ together with a non-negative integer $k$. It returns the first $k$ dimensions of a simplicial complex $S$. The simplicial complex $S$ has one vertex for each d-cell in $T$, and an n-simplex for each collection of n+1 d-cells with non-trivial common
intersection. The homotopy types of $T$ and $S$ are equal. 

 For a pure cubical complex $T$ this uses a slightly different algorithm to the function
CechComplexOfPureCubicalComplex(T) but constructs the same simplicial complex. \\
 \\
 \\
 \\
 \index{RipsChainComplex}::::::::::::::::::::::::\\
 \texttt{RipsChainComplex(G,n)}\\
 

 Inputs a graph $G$ and a non-negative integer $n$. It returns $n+1$ terms of a chain complex whose homology is that of the nerve (or Rips complex)
of the graph in degrees up to $n$. \\
 \\
 \\
 \\
 \index{VectorsToSymmetricMatrix}::::::::::::::::::::::::\\
 \texttt{VectorsToSymmetricMatrix(M)}\\
 \texttt{VectorsToSymmetricMatrix(M,distance)}\\
 

 Inputs a matrix $M$ of rational numbers and returns a symmetric matrix $S$ whose $(i,j)$ entry is the distance between the $i$-th row and $j$-th rows of $M$ where distance is given by the sum of the absolute values of the coordinate
differences. 

 Optionally, a function distance(v,w) can be entered as a second argument. This
function has to return a rational number for each pair of rational vectors $v,w$ of length Length(M[1]). \\
 \\
 \\
 \\
 \index{EulerCharacteristic}::::::::::::::::::::::::\\
 \texttt{EulerCharacteristic(T)}\\
 

 Inputs a pure cubical complex, or cubical complex, or simplicial complex $T$ and returns its Euler characteristic. \\
 \\
 \\
 \\
 \index{MaximalSimplicesToSimplicialComplex}::::::::::::::::::::::::\\
 \texttt{MaximalSimplicesToSimplicialComplex(L)}\\
 

 Inputs a list L whose entries are lists of vertices representing the maximal
simplices of a simplicial complex. The simplicial complex is returned. Here a
"vertex" is a GAP object such as an integer or a subgroup. \\
 \\
 \\
 \\
 \index{SkeletonOfSimplicialComplex}::::::::::::::::::::::::\\
 \texttt{SkeletonOfSimplicialComplex(S,k)}\\
 

 Inputs a simplicial complex $S$ and a positive integer $k$ less than or equal to the dimension of $S$. It returns the truncated $k$-dimensional simplicial complex $S^k$ (and leaves $S$ unchanged). \\
 \\
 \\
 \\
 \index{GraphOfSimplicialComplex}::::::::::::::::::::::::\\
 \texttt{GraphOfSimplicialComplex(S)}\\
 

 Inputs a simplicial complex $S$ and returns the graph of $S$. \\
 \\
 \\
 \\
 \index{ContractibleSubcomplexOfSimplicialComplex}::::::::::::::::::::::::\\
 \texttt{ContractibleSubcomplexOfSimplicialComplex(S)}\\
 

 Inputs a simplicial complex $S$ and returns a (probably maximal) contractible subcomplex of $S$. \\
 \\
 \\
 \\
 \index{PathComponentsOfSimplicialComplex}::::::::::::::::::::::::\\
 \texttt{PathComponentsOfSimplicialComplex(S,n)}\\
 

 Inputs a simplicial complex $S$ and a nonnegative integer $n$. If $n=0$ the number of path components of $S$ is returned. Otherwise the n-th path component is returned (as a simplicial
complex). \\
 \\
 \\
 \\
 \index{QuillenComplex}::::::::::::::::::::::::\\
 \texttt{QuillenComplex(G)}\\
 

 Inputs a finite group $G$ and returns, as a simplicial complex, the order complex of the poset of
non-trivial elementary abelian subgroups of $G$. \\
 \\
 \\
 \\
 \index{SymmetricMatrixToIncidenceMatrix}::::::::::::::::::::::::\\
 \texttt{SymmetricMatrixToIncidenceMatrix(S,t)}\\
 \texttt{SymmetricMatrixToIncidenceMatrix(S,t,d)}\\
 

 Inputs a symmetric integer matrix S and an integer t. It returns the matrix $M$ with $M_{ij}=1$ if $I_{ij}$ is less than $ t$ and $I_{ij}=1$ otherwise. 

 An optional integer $d$ can be given as a third argument. In this case the incidence matrix should
have roughly at most $d$ entries in each row (corresponding to the \$d\$ smallest entries in each row
of $S$). \\
 \\
 \\
 \\
 \index{IncidenceMatrixToGraph}::::::::::::::::::::::::\\
 \texttt{IncidenceMatrixToGraph(M)}\\
 

 Inputs a symmetric 0/1 matrix M. It returns the graph with one vertex for each
row of $M$ and an edges between vertices $i$ and $j$ if the $(i,j)$ entry in $M$ equals 1. \\
 \\
 \\
 \\
 \index{CayleyGraphOfGroup}::::::::::::::::::::::::\\
 \texttt{CayleyGraphOfGroup(G,A)}\\
 

 Inputs a group $G$ and a set $A$ of generators. It returns the Cayley graph. \\
 \\
 \\
 \\
 \index{PathComponentsOfGraph}::::::::::::::::::::::::\\
 \texttt{PathComponentsOfGraph(G,n)}\\
 

 Inputs a graph $G$ and a nonnegative integer $n$. If $n=0$ the number of path components is returned. Otherwise the n-th path component
is returned (as a graph). \\
 \\
 \\
 \\
 \index{ContractGraph}::::::::::::::::::::::::\\
 \texttt{ContractGraph(G)}\\
 

 Inputs a graph $G$ and tries to remove vertices and edges to produce a smaller graph $G'$ such that the indlusion $G' \rightarrow G$ induces a homotopy equivalence $RG \rightarrow RG'$ of Rips complexes. If the graph $G$ is modified the function returns true, and otherwise returns false. \\
 \\
 \\
 \\
 \index{GraphDisplay}::::::::::::::::::::::::\\
 \texttt{GraphDisplay(G)}\\
 

 This function uses GraphViz software to display a graph $G$. \\
 \\
 \\
 \\
 \index{SimplicialMap}::::::::::::::::::::::::\\
 \index{SimplicialMapNC}::::::::::::::::::::::::\\
 \texttt{SimplicialMap(K,L,f)}\\
 \texttt{SimplicialMapNC(K,L,f)}\\
 

 Inputs simplicial complexes $K$ , $L$ and a function $f\colon K!.vertices \rightarrow L!.vertices$ representing a simplicial map. It returns a simplicial map $K \rightarrow L$. If $f$ does not happen to represent a simplicial map then SimplicialMap(K,L,f) will
return fail; SimplicialMapNC(K,L,f) will not do any check and always return
something of the data type "simplicial map". \\
 \\
 \\
 \\
 \index{ChainMapOfSimplicialMap}::::::::::::::::::::::::\\
 \texttt{ChainMapOfSimplicialMap(f)}\\
 

 Inputs a simplicial map $f\colon K \rightarrow L$ and returns the corresponding chain map $C_\ast(f) \colon C_\ast(K) \rightarrow C_\ast(L)$ of the simplicial chain complexes.. \\
 \\
 \\
 \\
 \index{SimplicialNerveOfGraph}::::::::::::::::::::::::\\
 \texttt{SimplicialNerveOfGraph(G,d)}\\
 

 Inputs a graph $G$ and returns a $d$-dimensional simplicial complex $K$ whose 1-skeleton is equal to $G$. There is a simplicial inclusion $K \rightarrow RG$ where: (i) the inclusion induces isomorphisms on homotopy groups in dimensions
less than $d$; (ii) the complex $RG$ is the Rips complex (with one $n$-simplex for each complete subgraph of $G$ on $n+1$ vertices). \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{Cubical Complexes}}\logpage{[ 28, 0, 0 ]}
\hyperdef{L}{X7D67D5F3820637AD}{}
{
 \\
 \\
 \\
 \index{ArrayToPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ArrayToPureCubicalComplexA,n)}\\
 

 Inputs an integer array $A$ of dimension $d$ and an integer $n$. It returns a d-dimensional pure cubical complex corresponding to the
black/white "image" determined by the threshold $n$ and the values of the entries in $A$. (Integers below the threshold correspond to a black pixel, and higher
integers correspond to a white pixel.) \\
 \\
 \\
 \\
 \index{PureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{PureCubicalComplexA,n)}\\
 

 Inputs a binary array $A$ of dimension $d$. It returns the corresponding d-dimensional pure cubical complex. \\
 \\
 \\
 \\
 \index{FramedPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{FramedPureCubicalComplex(M)}\\
 

 Inputs a pure cubical complex $M$ and returns the pure cubical complex with a border of zeros attached the each
face of the boundary array M!.boundaryArray. This function just adds a bit of
space for performing operations such as thickenings to $M$. \\
 \\
 \\
 \\
 \index{RandomCubeOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{RandomCubeOfPureCubicalComplex(M)}\\
 

 Inputs a pure cubical complex $M$ and returns a pure cubical complex $R$ with precisely the same dimensions as $M$. The complex $R$ consist of one cube selected at random from $M$. \\
 \\
 \\
 \\
 \index{PureCubicalComplexIntersection}::::::::::::::::::::::::\\
 \texttt{PureCubicalComplexIntersection(S,T)}\\
 

 Inputs two pure cubical complexes with common dimension and array size. It
returns the intersection of the two complexes. (An entry in the binary array
of the intersection has value 1 if and only if the corresponding entries in
the binary arrays of S and T both have value 1.) \\
 \\
 \\
 \\
 \index{PureCubicalComplexUnion}::::::::::::::::::::::::\\
 \texttt{PureCubicalComplexUnion(S,T)}\\
 

 Inputs two pure cubical complexes with common dimension and array size. It
returns the union of the two complexes. (An entry in the binary array of the
union has value 1 if and only if at least one of the corresponding entries in
the binary arrays of S and T has value 1.) \\
 \\
 \\
 \\
 \index{PureCubicalComplexDifference}::::::::::::::::::::::::\\
 \texttt{PureCubicalComplexDifference(S,T)}\\
 

 Inputs two pure cubical complexes with common dimension and array size. It
returns the difference S-T. (An entry in the binary array of the difference
has value 1 if and only if the corresponding entry in the binary array of S is
1 and the corresponding entry in the binary array of T is 0.) \\
 \\
 \\
 \\
 \index{ReadImageAsPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ ReadImageAsPureCubicalComplex("file.png",n)}\\
 

 Reads an image file ("file.png", "file.eps", "file.bmp" etc) and an integer $n$ between 0 and 765. It returns a 2-dimensional pure cubical complex based on
the black/white version of the image determined by the threshold $n$. \\
 \\
 \\
 \\
 \index{ReadLinkImageAsPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ ReadLinkImageAsPureCubicalComplex("file.png")}\\
 \texttt{ ReadLinkImageAsPureCubicalComplex("file.png",n)}\\
 

 Reads an image file ("file.png", "file.eps", "file.bmp" etc) containing a knot
or link diagram, and optionally a positive integer $n$. The integer $n$ should be a little larger than the line thickness in the link diagram, and if
not provided then $n$ is set equal to 10. The function tries to output the corresponding knot or
link as a 3-dimensional pure cubical complex. Ideally the link diagram should
be produced with line thickness 6 in Xfig, and the under-crossing spaces
should not be too large or too small or too near one another. The function
does not always succeed: it applies several checks, and if one of these checks
fails then the function returns "fail". \\
 \\
 \\
 \\
 \index{ReadImageSequenceAsPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ReadImageSequenceAsPureCubicalComplex("directory",n)}\\
 

 Reads the name of a directory containing a sequence of image files (ordered
alphanumerically), and an integer $n$ between 0 and 765. It returns a 3-dimensional pure cubical complex based on
the black/white version of the images determined by the threshold $n$. \\
 \\
 \\
 \\
 \texttt{Size(T)}\\
 

 This returns the number of non-zero entries in the binary array of the cubical
complex, or pure cubical complex T. \\
 \\
 \\
 \\
 \texttt{Dimension(T)}\\
 

 This returns the dimension of the cubical complex, or pure cubical complex T. \\
 \\
 \\
 \\
 \index{WritePureCubicalComplexAsImage}::::::::::::::::::::::::\\
 \texttt{WritePureCubicalComplexAsImage(T,"filename","ext")}\\
 

 Inputs a 2-dimensional pure cubical complex T, and a filename followed by its
extension (e.g. "myfile" followed by "png"). A black/white image is saved to
the file. \\
 \\
 \\
 \\
 \index{ViewPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ViewPureCubicalComplex(T)}\\
 \texttt{ViewPureCubicalComplex(T,"mozilla")}\\
 

 Inputs a 2-dimensional pure cubical complex T, and optionally a command such
as "mozilla" for viewing image files. A black/white image is displayed. \\
 \\
 \\
 \\
 \index{Homology}::::::::::::::::::::::::\\
 \texttt{Homology(T,n)}\\
 \texttt{Homology(T)}\\
 

 Inputs a pure cubical complex, or cubical complex, or simplicial complex $T$ and a non-negative integer $n$. It returns the n-th integral homology of $T$ as a list of torsion integers. If no value of $n$ is input then the list of all homologies of $T$ in dimensions 0 to Dimension(T) is returned . \\
 \\
 \\
 \\
 \index{Bettinumbers}::::::::::::::::::::::::\\
 \texttt{Bettinumbers(T,n)}\\
 \texttt{Bettinumbers(T)}\\
 

 Inputs a pure cubical complex, or cubical complex, simplicial complex or chain
complex $T$ and a non-negative integer $n$. The rank of the n-th rational homology group $H_n(T,\mathbb Q)$ is returned. If no value for n is input then the list of Betti numbers in
dimensions 0 to Dimension(T) is returned . \\
 \\
 \\
 \\
 \index{DirectProductOfPureCubicalComplexes}::::::::::::::::::::::::\\
 \texttt{DirectProductOfPureCubicalComplexes(M,N)}\\
 

 Inputs two pure cubical complexes $M,N$ and returns their direct product $D$ as a pure cubical complex. The dimension of $D$ is the sum of the dimensions of $M$ and $N$. \\
 \\
 \\
 \\
 \index{SuspensionOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{SuspensionOfPureCubicalComplex(M)}\\
 

 Inputs a pure cubical complex $M$ and returns a pure cubical complex with the homotopy type of the suspension of $M$. \\
 \\
 \\
 \\
 \texttt{EulerCharacteristic(T)}\\
 

 Inputs a pure cubical complex, or cubical complex, or simplicial complex $T$ and returns its Euler characteristic. \\
 \\
 \\
 \\
 \index{PathComponentOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{PathComponentOfPureCubicalComplex(T,n)}\\
 

 Inputs a pure cubical complex $T$ and an integer $n$ in the rane 1, ..., Bettinumbers(T)[1] . It returns the n-th path component of $T$ as a pure cubical complex. The value $n=0$ is also allowed, in which case the number of path components is returned. \\
 \\
 \\
 \\
 \texttt{ChainComplex(T)}\\
 

 Inputs a pure cubical complex, or cubical complex, or simplicial complex $T$ and returns the (often very large) cellular chain complex of $T$. \\
 \\
 \\
 \\
 \texttt{ChainComplexOfPair(T,S)}\\
 

 Inputs a pure cubical complex or cubical complex $T$ and subcomplex $S$. It returns the quotient $C(T)/C(S)$ of cellular chain complexes. \\
 \\
 \\
 \\
 \texttt{ExcisedPureCubicalPair(T,S)}\\
 

 Inputs a pure cubical complex $T$ and subcomplex $S$. It returns the pair $[T\setminus intS, S\setminus intS])$ of pure cubical complexes where $intS$ is the pure cubical complex obtained from $S$ by removing its boundary. \\
 \\
 \\
 \\
 \index{ChainInclusionOfPureCubicalPair}::::::::::::::::::::::::\\
 \texttt{ChainInclusionOfPureCubicalPair(S,T)}\\
 

 Inputs a pure cubical complex $T$ and subcomplex $S$. It returns the chain inclusion $C(S) \rightarrow C(T)$ of cellular chain complexes. \\
 \\
 \\
 \\
 \index{ChainMapOfPureCubicalPairs}::::::::::::::::::::::::\\
 \texttt{ChainMapOfPureCubicalPairs(M,S,N,T)}\\
 

 Inputs a pure cubical complex $N$ and subcomplexes $M$, $T$ and $S$ in $T$. It returns the chain map $C(M/S) \rightarrow C(N/T)$ of quotient cellular chain complexes. \\
 \\
 \\
 \\
 \index{ContractPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ContractPureCubicalComplex(T)}\\
 

 Inputs a pure cubical complex $T$ of dimension $d$ and removes $d$-dimensional cells from $T$ without changing the homotopy type of $T$. When the function has been applied, no further $d$-cells can be removed from $T$ without changing its homotopy type. This function modifies $T$. \\
 \\
 \\
 \\
 \index{ContractedComplex}::::::::::::::::::::::::\\
 \texttt{ContractedComplex(T)}\\
 

 Inputs a pure cubical complex $T$ and returns a structural copy of the complex obtained from $T$ by applying the function ContractPureCubicalComplex(T). \\
 \\
 \\
 \\
 \index{ZigZagContractedPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ZigZagContractedPureCubicalComplex(T)}\\
 

 Inputs a pure cubical complex $T$ and returns a homotopy equivalent pure cubical complex $S$. The aim is for $S$ to involve fewer cells than $T$ and certainly to involve no more cells than $T$. \\
 \\
 \\
 \\
 \index{ContractCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ContractCubicalComplex(T)}\\
 

 Inputs a cubical complex $T$ and removes cells without changing the homotopy type of $T$. It changes $T$. In particular, it adds the components T.vectors and T.rewrite of a discrete
vector field. 

 At present this function only works for cubical complexes of dimension 2 or 3. \\
 \\
 \\
 \\
 \index{DVFReducedCubicalComplex}::::::::::::::::::::::::\\
 \texttt{DVFReducedCubicalComplex(T)}\\
 

 Inputs a cubical complex $T$ and returns a non-regular cubical complex $R$ by constructing a discrete vector field. The vector field is designed to
minimize the number of critical cells in $R$ at the cost of allowing cell attaching maps that are not homeomorphisms on
boundaries. 

 At present this function works only for 2- and 3-dimensional cubical
complexes. 

 The function ChainComplex(R) can be used to obtain the cellular chain complex
of $R$. \\
 \\
 \\
 \\
 \index{SkeletonOfCubicalComplex}::::::::::::::::::::::::\\
 \texttt{SkeletonOfCubicalComplex(T,n)}\\
 

 Inputs a cubical complex, or pure cubical complex $T$ and positive integer $n$. It returns the $n$-skeleton of $T$ as a cubical complex. \\
 \\
 \\
 \\
 \index{ContractibleSubomplexOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ContractibleSubomplexOfPureCubicalComplex(T)}\\
 

 Inputs a pure cubical complex $T$ and returns a maximal contractible pure cubical subcomplex. \\
 \\
 \\
 \\
 \index{AcyclicSubomplexOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{AcyclicSubomplexOfPureCubicalComplex(T)}\\
 

 Inputs a pure cubical complex $T$ and returns a (not necessarily connected) pure cubical subcomplex having
trivial homology in all degrees greater than $0$. \\
 \\
 \\
 \\
 \index{HomotopyEquivalentMaximalPureCubicalSubcomplex}::::::::::::::::::::::::\\
 \texttt{HomotopyEquivalentMaximalPureCubicalSubcomplex(T,S)}\\
 

 Inputs a pure cubical complex $T$ together with a pure cubical subcomplex $S$. It returns a pure cubical subcomplex $H$ of $T$ which contains $S$ and is maximal with respect to the property that it is homotopy equivalent to $S$. \\
 \\
 \\
 \\
 \index{HomotopyEquivalentMinimalPureCubicalSubcomplex}::::::::::::::::::::::::\\
 \texttt{HomotopyEquivalentMinimalPureCubicalSubcomplex(T,S)}\\
 

 Inputs a pure cubical complex $T$ together with a pure cubical subcomplex $S$. It returns a pure cubical subcomplex $H$ of $T$ which contains $S$ and is minimal with respect to the property that it is homotopy equivalent to $T$. \\
 \\
 \\
 \\
 \index{BoundaryOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{BoundaryOfPureCubicalComplex(T)}\\
 

 Inputs a pure cubical complex $T$ and returns its boundary as a pure cubical complex. The boundary consists of
all cubes which have one or more facets that lie in just the one cube. \\
 \\
 \\
 \\
 \index{SingularitiesOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{SingularitiesOfPureCubicalComplex(T,radius,tolerance)}\\
 

 Inputs a pure cubical complex $T$ together with a positive integer "radius" and an integer "tolerance" in the
range 1..100. It returns the pure cubical subcomplex of those cells in the
boundary where the boundary is not differentiable. (The method for deciding
differentiability at a point is crude/discrete, prone to errors and depends on
the radius and tolerance.) \\
 \\
 \\
 \\
 \index{ThickenedPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ThickenedPureCubicalComplex(T)}\\
 

 Inputs a pure cubical complex $T$ and returns a pure cubical complex $S$. If a euclidean cube is in $T$ then this cube and all its neighbouring cubes are included in $S$. \\
 \\
 \\
 \\
 \index{CropPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{CropPureCubicalComplex(T)}\\
 

 Inputs a pure cubical complex $T$ and returns a pure cubical complex $S$ obtained from $T$ by removing any "zero boundary sheets" of the binary array. Thus $S$ and $T$ are isometric as euclidean spaces but there may be fewer zero entries in the
binary array for $S$. \\
 \\
 \\
 \\
 \index{BoundingPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{BoundingPureCubicalComplex(T)}\\
 

 Inputs a pure cubical complex $T$ and returns a contractible pure cubical complex $S$ containing $T$. \\
 \\
 \\
 \\
 \index{MorseFiltration}::::::::::::::::::::::::\\
 \texttt{MorseFiltration(M,i,t,bool)}\\
 \texttt{MorseFiltration(M,i,t)}\\
 

 Inputs a pure cubical complex $M$ of dimension $d$, an integer $i$ between $1$ and $d$, a positive integer $t$ and a boolean value True or False. The function returns a list $[M_1, M_2, ..., M_t]$ of pure cubical complexes with $M_k$ a subcomplex of $M_{k+1}$. The list is constructed by setting all slices of $M$ perpendicular to the $i$-th axis equal to zero if they meet the $i$th axis at a sufficiently high coordinate (if bool=True) or sufficiently low
coordinate (if bool=False). 

 If the variable bool is not specified then it is assumed to have the value
True. \\
 \\
 \\
 \\
 \index{ComplementOfPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ComplementOfPureCubicalComplex(T)}\\
 

 Inputs a pure cubical complex $T$ and returns a pure cubical complex $S$. A euclidean cube is in $S$ precisely when the cube is not in $T$. \\
 \\
 \\
 \\
 \index{PureCubicalComplexToTextFile}::::::::::::::::::::::::\\
 \texttt{PureCubicalComplexToTextFile(file,M)}\\
 

 Inputs a pure cubical complex $M$ and a string containing the address of a file. A representation of this
complex is written to the file in a format that can be read by the CAPD
(Computer Assisted Proofs in Dynamics) software developed by Marian Mrozek and
others. \\
 \\
 \\
 \\
 \index{ThickeningFiltration}::::::::::::::::::::::::\\
 \texttt{ThickeningFiltration(M,n)}\\
 \texttt{ThickeningFiltration(M,n,k)}\\
 

 Inputs a pure cubical complex $M$ and a positive integer $n$. It returns a filtered pure cubical complex constructed frim $n$ thickenings of $M$. If a positive integer $k$ is supplied as an optional third argument, then each step of the filtration is
obtained from a $k$-fold thickening. \\
 \\
 \\
 \\
 \index{Dendrogram}::::::::::::::::::::::::\\
 \texttt{Dendrogram(M)}\\
 

 Inputs a filtered pure cubical complex $M$ and returns data that specifies the dendrogram (or phylogenetic tree)
describing how path components are born and then merge during the filtration. \\
 \\
 \\
 \\
 \index{DendrogramDisplay}::::::::::::::::::::::::\\
 \texttt{DendrogramDisplay(M)}\\
 

 Inputs a filtered pure cubical complex $M$, or alternatively inputs the out from the command Dendrogram(M), and then
uses GraphViz software to display the path component dendrogram of $M$. \\
 \\
 \\
 \\
 \index{DendrogramToPersistenceMat}::::::::::::::::::::::::\\
 \texttt{DendrogramToPersistenceMat(D)}\\
 

 Inputs the output of the function Dendrogram(M) and returns the corresponding
degree 0 Betti bar code. \\
 \\
 \\
 \\
 \index{ReadImageAsFilteredPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ReadImageAsFilteredPureCubicalComplex(file,n)}\\
 

 Inputs a string containing the path to an image file, together with a positive
integer n. It returns a filtered pure cubical complex of filtration length $n$. \\
 \\
 \\
 \\
 \index{ComplementOfFilteredPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{ComplementOfFilteredPureCubicalComplex(M)}\\
 

 Inputs a filtered pure cubical complex $M$ and returns the complement as a filtered pure cubical complex. \\
 \\
 \\
 \\
 \index{PersistentHomologyOfFilteredPureCubicalComplex}::::::::::::::::::::::::\\
 \texttt{PersistentHomologyOfFilteredPureCubicalComplex(M,n)}\\
 

 Inputs a filtered pure cubical complex $M$ and a non-negative integer $n$. It returns the degree $n$ persistent homology of $ M$ with rational coefficients. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{Regular CW-Complexes}}\logpage{[ 29, 0, 0 ]}
\hyperdef{L}{X855CD0808058727D}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{SimplicialComplexToRegularCWComplex} \texttt{SimplicialComplexToRegularCWComplex(K)} 

 Inputs a simplicial complex $K$ and returns the corresponding regular CW-complex. \\
 \index{CubicalComplexToRegularCWComplex} \texttt{CubicalComplexToRegularCWComplex(K)} \texttt{CubicalComplexToRegularCWComplex(K,n)} 

 Inputs a pure cubical complex (or cubical complex) $K$ and returns the corresponding regular CW-complex. If a positive integer $n$ is entered as an optional second argument, then just the $n$-skeleton of $K$ is returned. \\
 \index{CriticalCellsOfRegularCWComplex} \texttt{CriticalCellsOfRegularCWComplex(Y)} \texttt{CriticalCellsOfRegularCWComplex(Y,n)} 

 Inputs a regular CW-complex $Y$ and returns the critical cells of $Y$ with respect to some discrete vector field. If $Y$ does not initially have a discrete vector field then one is constructed. 

 If a positive integer $n$ is given as a second optional input, then just the critical cells in
dimensions up to and including $n$ are returned. 

 The function $CriticalCellsOfRegularCWComplex(Y)$ works by homotopy reducing cells starting at the top dimension. The function $CriticalCellsOfRegularCWComplex(Y,n)$ works by homotopy coreducing cells starting at dimension 0. The two methods
may well return different numbers of cells. \\
 \index{ChainComplex} \texttt{ChainComplex(Y)} 

 Inputs a regular CW-complex $Y$ and returns the cellular chain complex of a CW-complex W whose cells
correspond to the critical cells of $Y$ with respect to some discrete vector field. If $Y$ does not initially have a discrete vector field then one is constructed. \\
 \index{ChainComplexOfRegularCWComplex} \texttt{ChainComplexOfRegularCWComplex(Y)} 

 Inputs a regular CW-complex $Y$ and returns the cellular chain complex of $Y$. \\
 \index{FundamentalGroup} \index{FundamentalGroupOfRegularCWComplex} \texttt{FundamentalGroup(Y)} \texttt{FundamentalGroup(Y,n)} 

 Inputs a regular CW-complex $Y$ and, optionally, the number of some 0-cell. It returns the fundamental group
of $Y$ based at the 0-cell $n$. The group is returned as a finitely presented group. If $n$ is not specified then it is set $n=1$. The algorithm requires a discrete vector field on $Y$. If $Y$ does not initially have a discrete vector field then one is constructed. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Knots and Links}}\logpage{[ 30, 0, 0 ]}
\hyperdef{L}{X82DADC508677F1EE}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{PureCubicalKnot} \texttt{PureCubicalKnot(L)} \texttt{PureCubicalKnot(n,i)} 

 Inputs a list $L=[[m1,n1], [m2,n2], ..., [mk,nk]]$ of pairs of integers describing a cubical arc presentation of a link with all
vertical lines at the front and all horizontal lines at the back. The bottom
horizontal line extends from the m1-th column to the n1-th column. The second
to bottom horizontal line extends from the m2-th column to the n2-th column.
And so on. The link is returned as a 3-dimensional pure cubical complex. 

 Alternatively the function inputs two integers $n$, $i$ and returns the $i$-th prime knot on $n$ crossings. \\
 \index{ViewPureCubicalKnot} \texttt{ViewPureCubicalKnot(L)} 

 Inputs a pure cubical link $L$ and displays it. 

 \\
 \index{KnotSum} \texttt{KnotSum(K,L)} 

 Inputs two pure cubical knots $K$, $L$ and returns their sum as a pure cubical knot. This function is not defined for
links with more than one component. 

 \\
 \index{KnotGroup} \texttt{KnotGroup(K)} 

 Inputs a pure cubical link $K$ and returns the fundamental group of its complement. The group is returned as
a finitely presented group. 

 \\
 \index{AlexanderMatrix} \texttt{AlexanderMatrix(G)} 

 Inputs a finitely presented group $G$ whose abelianization is infinite cyclic. It returns the Alexander matrix of
the presentation. 

 \\
 \index{AlexanderPolynomial} \texttt{AlexanderPolynomial(K)} \texttt{AlexanderPolynomial(G)} 

 Inputs either a pure cubical knot $K$ or a finitely presented group $G$ whose abelianization is infinite cyclic. The Alexander Polynomial is returned. 

 \\
 \index{ProjectionOfPureCubicalComplex} \texttt{ProjectionOfPureCubicalComplex(K)} 

 Inputs an \$n\$-dimensional pure cubical complex $K$ and returns an n-1-dimensional pure cubical complex K'. The returned complex
is obtained by projecting Euclidean n-space onto Euclidean n-1-space. 

 \\
 \index{ReadPDBfileAsPureCubicalComplex} \texttt{ReadPDBfileAsPureCubicalComplex(file)} \texttt{ReadPDBfileAsPureCubicalComplex(file,m ,c)} 

 Inputs a protein database file describing a protein, and optionally inputs a
positive integer m and character string c. The default values for the optional
inputs are m=5 and c="A". It loads the chain of amino acids labelled by c in
the file as a 3-dimensional pure cubical complex of the homotopy type of a
circle. 

 It might happen that the function fails to construct a pure cubical complex of
the homotopy type of a circle. In this case retry with a larger integer m. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Finite metric spaces and their filtered complexes }}\logpage{[ 31, 0, 0 ]}
\hyperdef{L}{X7988ECB7803BA915}{}
{
 \begin{center}
\begin{tabular}{|l|} \index{CayleyMetric} \texttt{CayleyMetric(g,h,N) } \texttt{CayleyMetric(g,h) } 

 Inputs two permutations $g,h$ and optionally the degree $N$ of a symmetric group containing them. It returns the minimum number of
transpositions needed to express $g*h^-1$ as a product of transpositions. \\
 \index{HammingMetric} \texttt{HammingMetric(g,h,N) } \texttt{HammingMetric(g,h) } 

 Inputs two permutations $g,h$ and optionally the degree $N$ of a symmetric group containing them. It returns the number of integers moved
by the permutation $g*h^-1$. \\
 \index{KendallMetric} \texttt{KendallMetric(g,h,N) } \texttt{KendallMetric(g,h) } 

 Inputs two permutations $g,h$ and optionally the degree $N$ of a symmetric group containing them. It returns the minimum number of
adjacent transpositions needed to express $g*h^-1$ as a product of adjacent transpositions. An adjacent transposition has the for $(i,i+1)$. \\
 \index{EuclideanSquaredMetric} \texttt{EuclideanSquaredMetric(v,w) } 

 Inputs two vectors $v,w$ of equal length and returns the sum of the squares of the components of $v-w$. In other words, it returns the square of the Euclidean distance between $v$ and $w$. \\
 \index{EuclideanApproximatedMetric} \texttt{EuclideanApproximatedMetric(v,w) } 

 Inputs two vectors $v,w$ of equal length and returns a rational approximation to the square root of the
sum of the squares of the components of $v-w$. In other words, it returns an approximation to the Euclidean distance
between $v$ and $w$. \\
 \index{ManhattanMetric} \texttt{ManhattanMetric(v,w) } 

 Inputs two vectors $v,w$ of equal length and returns the sum of the absolute values of the components
of $v-w$. This is often referred to as the taxi-cab distance between $v$ and $w$. \\
 \index{VectorsToSymmetricMatrix} \texttt{VectorsToSymmetricMatrix(L) } \texttt{VectorsToSymmetricMatrix(L,D) } 

 Inputs a list $L$ of vectors and optionally a metric $D$. The default is $D=ManhattanMetric$. It returns the symmetric matrix whose i-j-entry is $S[i][j]=D(L[i],L[j])$. \\
 \index{SymmetricMatDisplay} \texttt{SymmetricMatDisplay(S) } \texttt{SymmetricMatDisplay(L,V) } 

 Inputs an $n \times n$ symmetric matrix $S$ of non-negative integers and an integer $t$ in $[0 .. 100]$. Optionally it inputs a list $V=[V_1, ... , V_k]$ of disjoint subsets of $[1 .. n]$. It displays the graph with vertex set $[1 .. n]$ and with an edge between $i$ and $j$ if $S[i][j] < t$. If the optional list $V$ is input then the vertices in $V_i$ will be given a common colour distinct from other vertices. \\
 \index{SymmetricMatrixToFilteredGraph} \texttt{SymmetricMatrixToFilteredGraph(S,t,m) } 

 Inputs an integer symmetric matrix $S$, a positive integer $t$ and a positive integer $m$. The function returns a filtered graph of filtration length $t$. The $k$-th term of the filtration is a graph with one vertex for each row of $S$. There is an edge in this graph between the $i$-th and $j$-th vertices if the entry $S[i][j]$ is less than or equal to $k*m/t$. \\
 \index{PermGroupToFilteredGraph} \texttt{PermGroupToFilteredGraph(S,D) } 

 Inputs a permutation group $G$ and a metric $D$ defined on permutations. The function returns a filtered graph. The $k$-th term of the filtration is a graph with one vertex for each element of the
group $G$. There is an edge in this graph between vertices $g$ and $h$ if $D(g,h)$ is less than some integer threshold $t_k$. The thresholds $t_1 < t_2 < ... < t_N$ are chosen to form as long a sequence as possible subject to each term of the
filtration being a distinct graph. \\
\end{tabular}\\[2mm]
\end{center}

 }

 
\chapter{\textcolor{Chapter }{ Commutative diagrams and abstract categories}}\logpage{[ 32, 0, 0 ]}
\hyperdef{L}{X83AAC8367CC7686F}{}
{
 \\
\textsc{COMMUTATIVE DIAGRAMS} \\
\\
 \\
 \\
 \\
 \index{HomomorphismChainToCommutativeDiagram}::::::::::::::::::::::::\\
 \texttt{HomomorphismChainToCommutativeDiagram(H) }\\
 

 Inputs a list $H=[h_1,h_2,...,h_n]$ of mappings such that the composite $h_1h_2...h_n$ is defined. It returns the list of composable homomorphism as a commutative
diagram. \\
 \\
 \\
 \\
 \index{NormalSeriesToQuotientDiagram}::::::::::::::::::::::::\\
 \texttt{NormalSeriesToQuotientDiagram(L) }\\
 \texttt{NormalSeriesToQuotientDiagram(L,M)}\\
 

 Inputs an increasing (or decreasing) list $L=[L_1,L_2,...,L_n]$ of normal subgroups of a group $G$ with $G=L_n$. It returns the chain of quotient homomorphisms $G/L_i \rightarrow G/L_{i+1}$ as a commutative diagram. 

 Optionally a subseries $M$ of $L$ can be entered as a second variable. Then the resulting diagram of quotient
groups has two rows of horizontal arrows and one row of vertical arrows. \\
 \\
 \\
 \\
 \index{NerveOfCommutativeDiagram}::::::::::::::::::::::::\\
 \texttt{NerveOfCommutativeDiagram(D) }\\
 

 Inputs a commutative diagram $D$ and returns the commutative diagram $ND$ consisting of all possible composites of the arrows in $D$. \\
 \\
 \\
 \\
 \index{GroupHomologyOfCommutativeDiagram}::::::::::::::::::::::::\\
 \texttt{GroupHomologyOfCommutativeDiagram(D,n) }\\
 \texttt{GroupHomologyOfCommutativeDiagram(D,n,prime) }\\
 \texttt{GroupHomologyOfCommutativeDiagram(D,n,prime,Resolution{\textunderscore}Algorithm) }\\
 

 Inputs a commutative diagram $D$ of $p$-groups and positive integer $n$. It returns the commutative diagram of vector spaces obtained by applying mod
p homology. 

 Non-prime power groups can also be handled if a prime $p$ is entered as the third argument. Integral homology can be obtained by setting $p=0$. For $p=0$ the result is a diagram of groups. 

 A particular resolution algorithm, such as ResolutionNilpotentGroup, can be
entered as a fourth argument. For positive $p$ the default is ResolutionPrimePowerGroup. For $p=0$ the default is ResolutionFiniteGroup. \\
 \\
 \\
 \\
 \index{PersistentHomologyOfCommutativeDiagramOfPGroups}::::::::::::::::::::::::\\
 \texttt{PersistentHomologyOfCommutativeDiagramOfPGroups(D,n) }\\
 

 Inputs a commutative diagram $D$ of finite $p$-groups and a positive integer $n$. It returns a list containing, for each homomorphism in the nerve of $D$, a triple $[k,l,m]$ where $k$ is the dimension of the source of the induced mod $p$ homology map in degree $n$, $l$ is the dimension of the image, and $m$ is the dimension of the cokernel. \\
 \\
 \\
 \textsc{ABSTRACT CATEGORIES} \\
\\
 \\
 \\
 \\
 \index{CategoricalEnrichment}::::::::::::::::::::::::\\
 \texttt{CategoricalEnrichment(X,Name) }\\
 

 Inputs a structure $X$ such as a group or group homomorphism, together with the name of some existing
category such as Name:=Category{\textunderscore}of{\textunderscore}Groups or
Category{\textunderscore}of{\textunderscore}Abelian{\textunderscore}Groups. It
returns, as appropriate, an object or arrow in the named category. \\
 \\
 \\
 \\
 \index{IdentityArrow}::::::::::::::::::::::::\\
 \texttt{IdentityArrow(X) }\\
 

 Inputs an object $X$ in some category, and returns the identity arrow on the object $X$. \\
 \\
 \\
 \\
 \index{InitialArrow}::::::::::::::::::::::::\\
 \texttt{InitialArrow(X) }\\
 

 Inputs an object $X$ in some category, and returns the arrow from the initial object in the
category to $X$. \\
 \\
 \\
 \\
 \index{TerminalArrow}::::::::::::::::::::::::\\
 \texttt{TerminalArrow(X) }\\
 

 Inputs an object $X$ in some category, and returns the arrow from $X$ to the terminal object in the category. \\
 \\
 \\
 \\
 \index{HasInitialObject}::::::::::::::::::::::::\\
 \texttt{HasInitialObject(Name) }\\
 

 Inputs the name of a category and returns true or false depending on whether
the category has an initial object. \\
 \\
 \\
 \\
 \index{HasTerminalObject}::::::::::::::::::::::::\\
 \texttt{HasTerminalObject(Name) }\\
 

 Inputs the name of a category and returns true or false depending on whether
the category has a terminal object. \\
 \\
 \\
 \\
 \index{Source}::::::::::::::::::::::::\\
 \texttt{Source(f) }\\
 

 Inputs an arrow $f$ in some category, and returns its source. \\
 \\
 \\
 \\
 \index{Target}::::::::::::::::::::::::\\
 \texttt{Target(f) }\\
 

 Inputs an arrow $f$ in some category, and returns its target. \\
 \\
 \\
 \\
 \index{CategoryName}::::::::::::::::::::::::\\
 \texttt{CategoryName(X) }\\
 

 Inputs an object or arrow $X$ in some category, and returns the name of the category. \\
 \\
 \\
 \\
 \texttt{"*", "=", "+", "-" }\\
 

 Composition of suitable arrows $f,g$ is given by $f*g$ when the source of $f$ equals the target of $g$. (Warning: this differes to the standard GAP convention.) 

 Equality is tested using $f=g$. 

In an additive category the sum and difference of suitable arrows is given by $f+g$ and $f-g$. \\
 \\
 \\
 \\
 \index{Object}::::::::::::::::::::::::\\
 \texttt{Object(X) }\\
 

 Inputs an object $X$ in some category, and returns the GAP structure $Y$ such that $X=CategoricalEnrichment(Y,CategoryName(X))$. \\
 \\
 \\
 \\
 \index{Mapping}::::::::::::::::::::::::\\
 \texttt{Mapping(X) }\\
 

 Inputs an arrow $f$ in some category, and returns the GAP structure $Y$ such that $f=CategoricalEnrichment(Y,CategoryName(X))$. \\
 \\
 \\
 \\
 \index{IsCategoryObject}::::::::::::::::::::::::\\
 \texttt{IsCategoryObject(X) }\\
 

 Inputs $X$ and returns true if $X$ is an object in some category. \\
 \\
 \\
 \\
 \index{IsCategoryArrow}::::::::::::::::::::::::\\
 \texttt{IsCategoryArrow(X) }\\
 

 Inputs $X$ and returns true if $X$ is an arrow in some category. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Arrays and Pseudo lists}}\logpage{[ 33, 0, 0 ]}
\hyperdef{L}{X7B71D3EA7B30ADAB}{}
{
 \\
 \\
 \\
 \index{Array}::::::::::::::::::::::::\\
 \texttt{Array(A,f)}\\
 

 Inputs an array $A$ and a function $f$. It returns the the array obtained by applying $f$ to each entry of $A$ (and leaves $A$ unchanged). \\
 \\
 \\
 \\
 \index{PermuteArray}::::::::::::::::::::::::\\
 \texttt{PermuteArray(A,f)}\\
 

 Inputs an array $A$ of dimension $d$ and a permutation $f$ of degree at most $d$. It returns the array $B$ defined by $B[i1][i2]...[id] = A[f(i1)][f(i2)]...A[f(id)]$ (and leaves $A$ unchanged). \\
 \\
 \\
 \\
 \index{ArrayDimension}::::::::::::::::::::::::\\
 \texttt{ArrayDimension(A)}\\
 

 Inputs an array $A$ and returns its dimension. \\
 \\
 \\
 \\
 \index{ArrayDimensions}::::::::::::::::::::::::\\
 \texttt{ArrayDimensions(A)}\\
 

 Inputs an array $A$ and returns its dimensions. \\
 \\
 \\
 \\
 \index{ArraySum}::::::::::::::::::::::::\\
 \texttt{ArraySum(A)}\\
 

 Inputs an array $A$ and returns the sum of its entries. \\
 \\
 \\
 \\
 \index{ArrayValue}::::::::::::::::::::::::\\
 \texttt{ArrayValue(A,x)}\\
 

 Inputs an array $A$ and a coordinate vector $x$. It returns the value of the entry in $A$ with coordinate $x$. \\
 \\
 \\
 \\
 \index{ArrayValueFunctions}::::::::::::::::::::::::\\
 \texttt{ArrayValueFunctions(d)}\\
 

 Inputs a positive integer $d$ and returns an efficient version of the function ArrayValue for arrays of
dimension $d$. \\
 \\
 \\
 \\
 \index{ArrayAssign}::::::::::::::::::::::::\\
 \texttt{ArrayAssign(A,x,n)}\\
 

 Inputs an array $A$ and a coordinate vector $x$ and an integer $n$. It sets the entry of $A$ with coordinate $x$ equal to $n$. \\
 \\
 \\
 \\
 \index{ArrayAssignFunctions}::::::::::::::::::::::::\\
 \texttt{ArrayAssignFunctions(d)}\\
 

 Inputs a positive integer $d$ and returns an efficient version of the function ArrayAssign for arrays of
dimension $d$. \\
 \\
 \\
 \\
 \index{ArrayIterate}::::::::::::::::::::::::\\
 \texttt{ArrayIterate(d)}\\
 

 Inputs a positive integer $d$ and returns a function ArrayIt(Dimensions,f). This function inputs a list
Dimensions of $d$ positive integers and also a function $f(x)$. It applies the function $f(x)$ to each integer list $x$ of length $d$ with entries $x[i]$ in the range [1..Dimension[i]]. \\
 \\
 \\
 \\
 \index{BinaryArrayToTextFile}::::::::::::::::::::::::\\
 \texttt{BinaryArrayToTextFile(file,A)}\\
 

 Inputs a string containing the address of a file, and an array $A$ of 0s and 1s. The array represents a pure cubical complex. A representation of
this complex is written to the file in a format that can be read by the CAPD
(Computer Assisted Proofs in Dynamics) software developed by Marian Mrozek and
others. 

 The second input $A$ can also be a pure cubical complex. \\
 \\
 \\
 \\
 \index{FrameArray}::::::::::::::::::::::::\\
 \texttt{FrameArray(A)}\\
 

 Inputs an array $A$ and returns the array obtained by appending a 0 to the beginning and end of
each "row" of the array. \\
 \\
 \\
 \\
 \index{UnframeArray}::::::::::::::::::::::::\\
 \texttt{UnframeArray(A)}\\
 

 Inputs an array $A$ and returns the array obtained by removing the first and last entry in each
"row" of the array. \\
 \\
 \\
 \\
 \index{Add}::::::::::::::::::::::::\\
 \texttt{Add(L,x)}\\
 

 Let $L$ be a pseudo list of length $n$, and $x$ an object compatible with the entries in $L$. If $x$ is not in $L$ then this operation converts $L$ into a pseudo list of length n+1 by adding $x$ as the final entry. If $x$ is in $L$ the operation has no effect on $L$. \\
 \\
 \\
 \\
 \index{Append}::::::::::::::::::::::::\\
 \texttt{Append(L,K)}\\
 

 Let $L$ be a pseudo list and $K$ a list whose objects are compatible with those in $L$. This operation applies Add(L,x) for each x in $K$. \\
\\
 \\
 \\
 \index{ListToPseudoList}::::::::::::::::::::::::\\
 \texttt{ListToPseudoList(L)}\\
 

 Inputs a list $L$ and returns the pseudo list representation of $L$. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Parallel Computation - Core Functions}}\logpage{[ 34, 0, 0 ]}
\hyperdef{L}{X85F9DF1985B88C37}{}
{
 \\
 \\
 \\
 \index{ChildProcess}::::::::::::::::::::::::\\
 \texttt{ChildProcess()}\\
 \texttt{ChildProcess("computer.ac.wales")}\\
 \texttt{ChildProcess(["-m", "100000M", "-T"])}\\
 \texttt{ChildProcess("computer.ac.wales", ["-m", "100000M", "-T"])}\\
 

 This starts a GAP session as a child process and returns a stream to the child
process. If no argument is given then the child process is created on the
local machine; otherwise the argument should be: 1) the address of a remote
computer for which ssh has been configured to require no password from the
user; (2) or a list of GAP command line options; (3) or the address of a
computer followed by a list of command line options. 

 (To configure ssh so that the user can login without a password prompt from
"thishost" to "remotehost" either consult "man ssh" or \\
 \\
 - open a shell on thishost\\
 - cd .ssh\\
 - ls\\
 -{\textgreater} if id{\textunderscore}dsa, id{\textunderscore}rsa etc exists,
skip the next two steps!\\
 - ssh-keygen -t rsa\\
 - ssh-keygen -t dsa\\
 - scp *.pub user@remotehost:\texttt{\symbol{126}}/\\
 - ssh remotehost -l user\\
 - cat id{\textunderscore}rsa.pub {\textgreater}{\textgreater}
.ssh/authorized{\textunderscore}keys\\
 - cat id{\textunderscore}dsa.pub {\textgreater}{\textgreater}
.ssh/authorized{\textunderscore}keys\\
 - rm id{\textunderscore}rsa.pub id{\textunderscore}dsa.pub\\
 - exit\\
 \\
 You should now be able to connect from "thishost" to "remotehost" without a
password prompt.) \\
 \\
 \\
 \\
 \index{ChildClose}::::::::::::::::::::::::\\
 \texttt{ChildClose(s)}\\
 

 This closes the stream s to a child GAP process. \\
 \\
 \\
 \\
 \index{ChildCommand}::::::::::::::::::::::::\\
 \texttt{ChildCommand("cmd;",s)}\\
 

 This runs a GAP command "cmd;" on the child process accessed by the stream s.
Here "cmd;" is a string representing the command. \\
 \\
 \\
 \\
 \index{NextAvailableChild}::::::::::::::::::::::::\\
 \texttt{NextAvailableChild(L)}\\
 

 Inputs a list $L$ of child processes and returns a child in $L$ which is ready for computation (as soon as such a child is available). \\
 \\
 \\
 \\
 \index{IsAvailableChild}::::::::::::::::::::::::\\
 \texttt{IsAvailableChild(s)}\\
 

 Inputs a child process $s$ and returns true if s is currently available for computations, and false
otherwise. \\
 \\
 \\
 \\
 \index{ChildPut}::::::::::::::::::::::::\\
 \texttt{ChildPut(A,"B",s)}\\
 

 This copies a GAP object A on the parent process to an object B on the child
process s. (The copying relies on the function PrintObj(A); ) \\
 \\
 \\
 \\
 \index{ChildGet}::::::::::::::::::::::::\\
 \texttt{ChildGet("A",s)}\\
 

 This functions copies a GAP object A on the child process s and returns it on
the parent process. (The copying relies on the function PrintObj(A); ) \\
 \\
 \\
 \\
 \index{HAPPrintTo}::::::::::::::::::::::::\\
 \texttt{HAPPrintTo("file",R)}\\
 

 Inputs a name "file" of a new text file and a HAP object R. It writes the
object R to "file". Currently this is only implemented for R equal to a
resolution. \\
 \\
 \\
 \\
 \index{HAPRead}::::::::::::::::::::::::\\
 \texttt{HAPRead("file",R)}\\
 

 Inputs a name "file" containing a HAP object R and returns the object.
Currently this is only implemented for R equal to a resolution. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Parallel Computation - Extra Functions}}\logpage{[ 35, 0, 0 ]}
\hyperdef{L}{X85B21D56816A1B39}{}
{
  \\
 \\
 \\
 \index{ChildFunction}::::::::::::::::::::::::\\
 \texttt{ChildFunction("function(arg);",s)}\\
 

 This runs the GAP function "function(arg);" on a child process accessed by the
stream s. The output from "func;" can be accessed via the stream. \\
 \\
 \\
 \\
 \index{ChildRead}::::::::::::::::::::::::\\
 \texttt{ChildRead(s)}\\
 

 This returns, as a string, the output of the last application of $ChildFunction("function(arg);",s)$. \\
 \\
 \\
 \\
 \index{ChildReadEval}::::::::::::::::::::::::\\
 \texttt{ChildReadEval(s)}\\
 

 This returns, as an evaluated string, the output of the last application of $ChildFunction("function(arg);",s)$. \\
 \\
 \\
 \\
 \index{ParallelList}::::::::::::::::::::::::\\
 \texttt{ParallelList(I,fn,L)}\\
 

 Inputs a list $I$, a function $fn$ such that $fn(x)$ is defined for all $x$ in $I$, and a list of children $L$. It uses the children in $L$ to compute $List(I,x->fn(x))$. (Obviously the function $fn$ must be defined on all child processes in $L$.) \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Some functions for accessing basic data}}\logpage{[ 36, 0, 0 ]}
\hyperdef{L}{X7AE3B902812A10B0}{}
{
 \\
 \\
 \\
 \index{BoundaryMap}::::::::::::::::::::::::\\
 \texttt{BoundaryMap(C)}\\
 

 Inputs a resolution, chain complex or cochain complex $C$ and returns the function $C!.boundary$. \\
 \\
 \\
 \\
 \index{BoundaryMatrix}::::::::::::::::::::::::\\
 \texttt{BoundaryMatrix(C,n)}\\
 

 Inputs a chain or cochain complex $C$ and integer $n${\textgreater}$0$. It returns the $n$-th boundary map of $C$ as a matrix. \\
 \\
 \\
 \\
 \index{Dimension}::::::::::::::::::::::::\\
 \texttt{Dimension(C) }\\
 \\
 \texttt{Dimension(M) }\\
 

 Inputs a resolution, chain complex or cochain complex $C$ and returns the function $C!.dimension$ . 

 Alternatively, inputs an $FpG$-module $M$ and returns its dimension as a vector space over the field of $p$ elements. \\
 \\
 \\
 \\
 \index{EvaluateProperty}::::::::::::::::::::::::\\
 \texttt{EvaluateProperty(X,"name") }\\
 

 Inputs a component object $X$ (such as a $ZG$-resolution or chain map) and a string "name" (such as "characteristic" or
"type"). It searches $X.property$ for the pair ["name",value] and returns value. If $X.property$ does not exist, or if ["name",value] does not exist, it returns fail. \\
 \\
 \\
 \\
 \index{GroupOfResolution}::::::::::::::::::::::::\\
 \texttt{GroupOfResolution(R)}\\
 

 Inputs a $ZG$-resolution $R$ and returns the group $G$. \\
 \\
 \\
 \\
 \index{Length}::::::::::::::::::::::::\\
 \texttt{Length(R)}\\
 

 Inputs a resolution $R$ and returns its length (i.e. the number of terms of $R$ that HAP has computed). \\
 \\
 \\
 \\
 \index{Map}::::::::::::::::::::::::\\
 \texttt{Map(f)}\\
 

 Inputs a chain map, or cochain map or equivariant chain map $f$ and returns the mapping function (as opposed to the target or the source of $f$) . \\
 \\
 \\
 \\
 \index{Source}::::::::::::::::::::::::\\
 \texttt{Source(f)}\\
 

 Inputs a chain map, or cochain map, or equivariant chain map, or $FpG$-module homomorphism $f$ and returns it source. \\
 \\
 \\
 \\
 \index{Target}::::::::::::::::::::::::\\
 \texttt{Target(f)}\\
 

 Inputs a chain map, or cochain map, or equivariant chain map, or $FpG$-module homomorphism $f$ and returns its target. \\
 \\
 \\
 }

 
\chapter{\textcolor{Chapter }{ Miscellaneous}}\logpage{[ 37, 0, 0 ]}
\hyperdef{L}{X7C5563A37D566DA5}{}
{
 \\
 \\
 \\
 \index{SL2Z}::::::::::::::::::::::::\\
 \texttt{SL2Z(p) }\\
 \texttt{SL2Z(1/m) }\\
 

 Inputs a prime $p$ or the reciprocal $1/m$ of a square free integer $m$. In the first case the function returns the conjugate $SL(2,Z)^P$ of the special linear group $SL(2,Z)$ by the matrix $P=[[1,0],[0,p]]$. In the second case it returns the group $SL(2,Z[1/m])$. \\
 \\
 \\
 \\
 \index{BigStepLCS}::::::::::::::::::::::::\\
 \texttt{BigStepLCS(G,n) }\\
 

 Inputs a group $G$ and a positive integer $n$. It returns a subseries $G=L_1${\textgreater}$L_2${\textgreater}$ \ldots L_k=1$ of the lower central series of $G$ such that $L_i/L_{i+1}$ has order greater than $n$. \\
 \\
 \\
 \\
 \index{Classify}::::::::::::::::::::::::\\
 \texttt{Classify(L,Inv) }\\
 

 Inputs a list of objects $L$ and a function $Inv$ which computes an invariant of each object. It returns a list of lists which
classifies the objects of $L$ according to the invariant.. \\
 \\
 \\
 \\
 \index{RefineClassification}::::::::::::::::::::::::\\
 \texttt{RefineClassification(C,Inv) }\\
 

 Inputs a list $C:=Classify(L,OldInv)$ and returns a refined classification according to the invariant $Inv$. \\
 \\
 \\
 \\
 \index{Compose(f,g)}::::::::::::::::::::::::\\
 \texttt{Compose(f,g) }\\
 

 Inputs two $FpG$-module homomorphisms $ f:M \longrightarrow N$ and $g:L \longrightarrow M$ with $Source(f)=Target(g)$ . It returns the composite homomorphism $fg:L \longrightarrow N$ . 

 This also applies to group homomorphisms $f,g$. \\
 \\
 \\
 \\
 \index{HAPcopyright}::::::::::::::::::::::::\\
 \texttt{HAPcopyright() }\\
 

 This function provides details of HAP'S GNU public copyright licence. \\
 \\
 \\
 \\
 \index{IsLieAlgebraHomomorphism}::::::::::::::::::::::::\\
 \texttt{IsLieAlgebraHomomorphism(f) }\\
 

 Inputs an object $f$ and returns true if $f$ is a homomorphism $f:A \longrightarrow B$ of Lie algebras (preserving the Lie bracket). \\
 \\
 \\
 \\
 \index{IsSuperperfect}::::::::::::::::::::::::\\
 \texttt{IsSuperperfect(G) }\\
 

 Inputs a group $G$ and returns "true" if both the first and second integral homology of $G$ is trivial. Otherwise, it returns "false". \\
 \\
 \\
 \\
 \index{MakeHAPManual}::::::::::::::::::::::::\\
 \texttt{MakeHAPManual()}\\
 

 This function creates the manual for HAP from an XML file. \\
 \\
 \\
 \\
 \index{PermToMatrixGroup}::::::::::::::::::::::::\\
 \texttt{PermToMatrixGroup(G,n) }\\
 

 Inputs a permutation group $G$ and its degree $n$. Returns a bijective homomorphism $f:G \longrightarrow M$ where $M$ is a group of permutation matrices. \\
 \\
 \\
 \\
 \index{SolutionsMatDestructive}::::::::::::::::::::::::\\
 \texttt{SolutionsMatDestructive(M,B) }\\
 

 Inputs an $m{\ensuremath{\times}}n$ matrix $M$ and a $k{\ensuremath{\times}}n$ matrix $B$ over a field. It returns a k{\ensuremath{\times}}m matrix $S$ satisfying $SM=B$. 

 The function will leave matrix $M$ unchanged but will probably change matrix $B$. 

 (This is a trivial rewrite of the standard GAP function $SolutionMatDestructive(${\textless}$mat${\textgreater},{\textless}$vec${\textgreater}) .) \\
 \\
 \\
 \\
 \index{LinearHomomorphismsPersistenceMat}::::::::::::::::::::::::\\
 \texttt{LinearHomomorphismsPersistenceMat(L) }\\
 

 Inputs a composable sequence $L$ of vector space homomorphisms. It returns an integer matrix containing the
dimensions of the images of the various composites. The sequence $L$ is determined up to isomorphism by this matrix. \\
 \\
 \\
 \\
 \index{NormalSeriesToQuotientHomomorphisms}::::::::::::::::::::::::\\
 \texttt{NormalSeriesToQuotientHomomorphisms(L) }\\
 

 Inputs an (increasing or decreasing) chain $L$ of normal subgroups in some group $G$. This $G$ is the largest group in the chain. It returns the sequence of composable group
homomorphisms $G/L[i] \rightarrow G/L[i+/-1]$. \\
 \\
 \\
 \\
 \index{TestHap}::::::::::::::::::::::::\\
 \texttt{TestHap() }\\
 

 This runs a representative sample of HAP functions and checks to see that they
produce the correct output. \\
 \\
 \\
 }

 \def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
