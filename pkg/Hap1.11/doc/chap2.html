<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (HAP) - Chapter 2: ZG-Resolutions and Group Cohomology</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">

<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X7C391012839DB4C5" name="X7C391012839DB4C5"></a></p>
<div class="ChapSects"><a href="chap2.html#X7C391012839DB4C5">2 <span class="Heading"><span class="SimpleMath">ZG</span>-Resolutions and Group Cohomology</span></a>
</div>

<h3>2 <span class="Heading"><span class="SimpleMath">ZG</span>-Resolutions and Group Cohomology</span></h3>

<p>Resolutions</p>

<div class="pcenter"><table cellspacing="10"  class="GAPDocTable">
<tr>
<td class="tdleft">
<pre class="normal">
EquivariantChainMap(R,S,f):: FreeResolution, FreeResolution, GroupHomomorphisms --&gt; EquiChainMap
</pre>

<p>Inputs a free <span class="SimpleMath">ZG</span>-resolution <span class="SimpleMath">R</span> of <span class="SimpleMath">Z</span>, a free <span class="SimpleMath">ZQ</span>-resolution <span class="SimpleMath">S</span> of <span class="SimpleMath">Z</span>, and a group homomorphism <span class="SimpleMath">f: G → Q</span>. It returns the induced <span class="SimpleMath">f</span>-equivariant chain map <span class="SimpleMath">F: R → S</span>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
FreeGResolution(P,n):: NonFreeResolution, Int --&gt; FreeResolution
</pre>

<p>Inputs a non-free $\mathbb ZG$-resolution $P_\ast$ and a positive integer <span class="SimpleMath">n</span>. It attempts to return <span class="SimpleMath">n</span> terms of a free <span class="SimpleMath">ZG</span>-resolution of <span class="SimpleMath">Z</span>. However, the stabilizer groups in the non-free resolution must be such that HAP can construct free resolutions with contracting homotopies for them.</p>

<p>The contracting homotopy on the resolution was implemented by Bui Anh Tuan.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ResolutionBieberbachGroup(G):: MatrixGroup --&gt; FreeResolution
</pre>


<pre class="normal">
ResolutionBieberbachGroup(G,v):: MatrixGroup, List --&gt; FreeResolution
</pre>

<p>Inputs a torsion free crystallographic group <span class="SimpleMath">G</span>, also known as a Bieberbach group, represented using <strong class="button">AffineCrystGroupOnRight</strong> as in the GAP package Cryst. It also optionally inputs a choice of vector <span class="SimpleMath">v</span> in the Euclidean space <span class="SimpleMath">R^n</span> on which <span class="SimpleMath">G</span> acts freely. The function returns <span class="SimpleMath">n+1</span> terms of the free ZG-resolution of <span class="SimpleMath">Z</span> arising as the cellular chain complex of the tessellation of <span class="SimpleMath">R^n</span> by the Dirichlet-Voronoi fundamental domain determined by <span class="SimpleMath">v</span>. No contracting homotopy is returned with the resolution.</p>

<p>This function is part of the HAPcryst package written by Marc Roeder and thus requires the HAPcryst package to be loaded.</p>

<p>The function requires the use of Polymake software.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ResolutionCubicalCrustGroup(G,k):: MatrixGroup, Int --&gt; FreeResolution
</pre>

<p>Inputs a crystallographic group <span class="SimpleMath">G</span> represented using <strong class="button">AffineCrystGroupOnRight</strong> as in the GAP package <span class="SimpleMath">Cryst</span> together with an integer <span class="SimpleMath">k ge 1</span>. The function tries to find a cubical fundamental domain in the Euclidean space <span class="SimpleMath">R^n</span> on which <span class="SimpleMath">G</span> acts. If it succeeds it uses this domain to return <span class="SimpleMath">k+1</span> terms of a free ZG-resolution of <span class="SimpleMath">Z</span>.</p>

<p>This function was written by Bui Anh Tuan.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ResolutionFiniteGroup(G,k):: Group, Int --&gt; FreeResolution
</pre>

<p>Inputs a finite group <span class="SimpleMath">G</span> and an integer <span class="SimpleMath">k ge 1</span>. It returns <span class="SimpleMath">k+1</span> terms of a free ZG-resolution of <span class="SimpleMath">Z</span>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ResolutionNilpotentGroup(G,k):: Group, Int --&gt; FreeResolution
</pre>

<p>Inputs a nilpotent group <span class="SimpleMath">G</span> (which can be infinite) and an integer <span class="SimpleMath">k ge 1</span>. It returns <span class="SimpleMath">k+1</span> terms of a free <span class="SimpleMath">ZG</span>-resolution of <span class="SimpleMath">Z</span>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ResolutionNormalSeries(L,k):: List, Int --&gt; FreeResolution
</pre>

<p>Inputs a a list <span class="SimpleMath">L</span> consisting of a chain $<span class="SimpleMath">1=N_1 le N_2 le ⋯ le N_n =G</span> of normal subgroups of <span class="SimpleMath">G</span>, together with an integer <span class="SimpleMath">k ge 1</span>. It returns <span class="SimpleMath">k+1</span> terms of a free ZG-resolution of <span class="SimpleMath">Z</span>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ResolutionPrimePowerGroup(G,k):: Group, Int --&gt; FreeResolution
</pre>

<p>Inputs a finite <span class="SimpleMath">p</span>-group <span class="SimpleMath">G</span> and an integer <span class="SimpleMath">k ge 1</span>. It returns <span class="SimpleMath">k+1</span> terms of a minimal free <span class="SimpleMath">FG</span>-resolution of the field <span class="SimpleMath">F</span> of <span class="SimpleMath">p</span> elements.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ResolutionSL2Z(m,k):: Int, Int --&gt; FreeResolution
</pre>

<p>Inputs positive integers <span class="SimpleMath">m, n</span> and returns <span class="SimpleMath">n</span> terms of a free <span class="SimpleMath">ZG</span>-resolution of <span class="SimpleMath">Z</span> for the group <span class="SimpleMath">G=SL_2( Z[1/m])</span>.</p>

<p>This function is joint work with Bui Anh Tuan.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ResolutionSmallGroup(G,k):: Group, Int --&gt; FreeResolution
</pre>


<pre class="normal">
ResolutionSmallGroup(G,k):: FpGroup, Int --&gt; FreeResolution
</pre>

<p>Inputs a small group <span class="SimpleMath">G</span> and an integer <span class="SimpleMath">k ge 1</span>. It returns <span class="SimpleMath">k+1</span> terms of a free ZG-resolution of <span class="SimpleMath">Z</span>.</p>

<p>If <span class="SimpleMath">G</span> is a finitely presented group then up to degree $2$ the resolution coincides with cellular chain complex of the universal cover of the <span class="SimpleMath">2</span> complex associated to the presentation of <span class="SimpleMath">G</span>. Thus the boundaries of the generators in degree <span class="SimpleMath">3</span> provide a generating set for the module of identities of the presentation.</p>

<p>This function was written by Irina Kholodna.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ResolutionSubgroup(R,H):: FreeResolution, Group --&gt; FreeResolution
</pre>

<p>Inputs a free ZG-resolution of <span class="SimpleMath">Z</span> and a finite index subgroup <span class="SimpleMath">H le G</span>. It returns a free ZH-resolution of <span class="SimpleMath">Z</span>.</p>

</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>Algebras <span class="SimpleMath">⟶</span> (Co)chain Complexes</p>

<div class="pcenter"><table cellspacing="10"  class="GAPDocTable">
<tr>
<td class="tdleft">
<pre class="normal">
LeibnizComplex(g,n):: LeibnizAlgebra, Int --&gt; ChainComplex
</pre>

<p>Inputs a Leibniz algebra, or Lie algebra, <span class="SimpleMath">mathfrakg</span> over a ring <span class="SimpleMath">K</span> together with an integer <span class="SimpleMath">nge 0</span>. It returns the first <span class="SimpleMath">n</span> terms of the Leibniz chain complex over <span class="SimpleMath">K</span>. The complex was implemented by Pablo Fernandez Ascariz.</p>

</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>Resolutions <span class="SimpleMath">⟶</span> (Co)chain Complexes</p>

<div class="pcenter"><table cellspacing="10"  class="GAPDocTable">
<tr>
<td class="tdleft">
<pre class="normal">
HomToIntegers(C):: ChainComplex --&gt; CochainComplex
</pre>


<pre class="normal">
HomToIntegers(R):: FreeResolution --&gt; CochainComplex
</pre>


<pre class="normal">
HomToIntegers(F):: EquiChainMap --&gt; CochainMap
</pre>

<p>Inputs a chain complex <span class="SimpleMath">C</span> of free abelian groups and returns the cochain complex <span class="SimpleMath">Hom_ Z(C, Z)</span>.</p>

<p>Inputs a free <span class="SimpleMath">ZG</span>-resolution <span class="SimpleMath">R</span> in characteristic <span class="SimpleMath">0</span> and returns the cochain complex <span class="SimpleMath">Hom_ ZG(R, Z)</span>.</p>

<p>Inputs an equivariant chain map <span class="SimpleMath">F: R→ S</span> of resolutions and returns the induced cochain map <span class="SimpleMath">Hom_ ZG(S, Z) ⟶ Hom_ ZG(R, Z)</span>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
HomToIntegralModule(R,A):: FreeResolution, GroupHomomorphism --&gt; CochainComplex
</pre>

<p>Inputs a free <span class="SimpleMath">ZG</span>-resolution <span class="SimpleMath">R</span> in characteristic <span class="SimpleMath">0</span> and a group homomorphism <span class="SimpleMath">A: G → GL_n( Z)</span>. The homomorphism <span class="SimpleMath">A</span> can be viewed as the <span class="SimpleMath">ZG</span>-module with underlying abelian group <span class="SimpleMath">Z^n</span> on which <span class="SimpleMath">G</span> acts via the homomorphism <span class="SimpleMath">A</span>. It returns the cochain complex <span class="SimpleMath">Hom_ ZG(R,A)</span>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
TensorWithIntegers(R):: FreeResolution --&gt; ChainComplex
</pre>


<pre class="normal">
TensorWithIntegers(F):: EquiChainMap --&gt; ChainMap
</pre>

<p>Inputs a free <span class="SimpleMath">ZG</span>-resolution <span class="SimpleMath">R</span> of characteristic <span class="SimpleMath">0</span> and returns the chain complex <span class="SimpleMath">R ⊗_ ZG Z</span>.</p>

<p>Inputs an equivariant chain map <span class="SimpleMath">F: R → S</span> in characteristic <span class="SimpleMath">0</span> and returns the induced chain map <span class="SimpleMath">F⊗_ ZG Z : R ⊗_ ZG Z ⟶ S ⊗_ ZG Z</span>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
TensorWithIntegersModP(C,p):: ChainComplex, Int --&gt; ChainComplex
</pre>


<pre class="normal">
TensorWithIntegersModP(R,p):: FreeResolution, Int --&gt; ChainComplex
</pre>


<pre class="normal">
TensorWithIntegersModP(F,p):: EquiChainMap, Int --&gt; ChainMap
</pre>

<p>Inputs a chain complex <span class="SimpleMath">C</span> of characteristic <span class="SimpleMath">0</span> and a prime integer <span class="SimpleMath">p</span>. It returns the chain complex <span class="SimpleMath">C ⊗_ Z Z_p</span> of characteristic <span class="SimpleMath">p</span>.</p>

<p>Inputs a free <span class="SimpleMath">ZG</span>-resolution <span class="SimpleMath">R</span> of characteristic <span class="SimpleMath">0</span> and a prime integer <span class="SimpleMath">p</span>. It returns the chain complex <span class="SimpleMath">R ⊗_ ZG Z_p</span> of characteristic <span class="SimpleMath">p</span>.</p>

<p>Inputs an equivariant chain map <span class="SimpleMath">F: R → S</span> in characteristic <span class="SimpleMath">0</span> a prime integer <span class="SimpleMath">p</span>. It returns the induced chain map <span class="SimpleMath">F⊗_ ZG Z_p : R ⊗_ ZG Z_p ⟶ S ⊗_ ZG Z_p</span>.</p>

</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>Cohomology rings</p>

<div class="pcenter"><table cellspacing="10"  class="GAPDocTable">
<tr>
<td class="tdleft">
<pre class="normal">
AreIsomorphicGradedAlgebras(A,B):: PresentedGradedAlgebra, PresentedGradedAlgebra --&gt; Boolean
</pre>

<p>Inputs two freely presented graded algebras <span class="SimpleMath">A= F[x_1, ..., x_m]/I</span> and <span class="SimpleMath">B= F[y_1, ..., y_n]/J</span> and returns <strong class="button">true</strong> if they are isomorphic, and <strong class="button">false</strong> otherwise. This function was implemented by Paul Smith.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
HAPDerivation(R,I,L):: PolynomialRing, List, List --&gt; Derivation
</pre>

<p>Inputs a polynomial ring <span class="SimpleMath">R= F[x_1,...,x_m]</span> over a field <span class="SimpleMath">F</span> together with a list <span class="SimpleMath">I</span> of generators for an ideal in <span class="SimpleMath">R</span> and a list <span class="SimpleMath">L=[y_1,...,y_m]⊂ R</span>. It returns the derivation <span class="SimpleMath">d: E → E</span> for <span class="SimpleMath">E=R/I</span> defined by <span class="SimpleMath">d(x_i)=y_i</span>. This function was written by Paul Smith. It uses the Singular commutative algebra package.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
HilbertPoincareSeries::PresentedGradedAlgebra  --&gt; RationalFunction
</pre>

<p>Inputs a presentation <span class="SimpleMath">E= F[x_1,...,x_m]/I</span> of a graded algebra and returns its Hilbert-Poincar\'e series. This function was written by Paul Smith and uses the Singular commutative algebra package. It is essentially a wrapper for Singular's Hilbert-Poincare series.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
HomologyOfDerivation(d):: Derivation --&gt; List
</pre>

<p>Inputs a derivation <span class="SimpleMath">d: E → E</span> on a quotient <span class="SimpleMath">E=R/I</span> of a polynomial ring <span class="SimpleMath">R= F[x_1,...,x_m]</span> over a field <span class="SimpleMath">F</span>. It returns a list <span class="SimpleMath">[S,J,h]</span> where <span class="SimpleMath">S</span> is a polynomial ring and <span class="SimpleMath">J</span> is a list of generators for an ideal in $S$ such that there is an isomorphism <span class="SimpleMath">α: S/J → ker d/ im~ d</span>. This isomorphism lifts to the ring homomorphism <span class="SimpleMath">h: S → ker d</span>. This function was written by Paul Smith. It uses the Singular commutative algebra package.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
IntegralCohomologyGenerators(R,n):: FreeResolution, Int --&gt; List
</pre>

<p>Inputs at least <span class="SimpleMath">n+1</span> terms of a free <span class="SimpleMath">ZG</span>-resolution of <span class="SimpleMath">Z</span> and the integer <span class="SimpleMath">n ge 1</span>. It returns a minimal list of cohomology classes in <span class="SimpleMath">H^n(G, Z)</span> which, together with all cup products of lower degree classes, generate the group <span class="SimpleMath">H^n(G, Z)</span> . (Let <span class="SimpleMath">a_i</span> be the <span class="SimpleMath">i</span>-th canonical generator of the <span class="SimpleMath">d</span>-generator abelian group <span class="SimpleMath">H^n(G,Z)</span>. The cohomology class <span class="SimpleMath">n_1a_1 + ... +n_da_d</span> is represented by the integer vector <span class="SimpleMath">u=(n_1, ..., n_d)</span>. )</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
LHSSpectralSequence(G,N,r):: Group, Int, Int --&gt; List
</pre>

<p>Inputs a finite <span class="SimpleMath">2</span>-group <span class="SimpleMath">G</span>, and normal subgroup <span class="SimpleMath">N</span> and an integer <span class="SimpleMath">r</span>. It returns a list of length <span class="SimpleMath">r</span> whose <span class="SimpleMath">i</span>-th term is a presentation for the <span class="SimpleMath">i</span>-th page of the Lyndon-Hochschild-Serre spectral sequence. This function was written by Paul Smith. It uses the Singular commutative algebra package.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
LHSSpectralSequenceLastSheet(G,N):: Group, Int --&gt; List
</pre>

<p>Inputs a finite <span class="SimpleMath">2</span>-group <span class="SimpleMath">G</span> and normal subgroup <span class="SimpleMath">N</span>. It returns presentation for the <span class="SimpleMath">E_∞</span> page of the Lyndon-Hochschild-Serre spectral sequence. This function was written by Paul Smith. It uses the Singular commutative algebra package.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ModPCohomologyGenerators(G,n):: Group, Int --&gt; List
</pre>


<pre class="normal">
ModPCohomologyGenerators(R):: FreeResolution --&gt; List
</pre>

<p>Inputs either a <span class="SimpleMath">p</span>-group <span class="SimpleMath">G</span> and positive integer <span class="SimpleMath">n</span>, or else <span class="SimpleMath">n+1</span> terms of a minimal <span class="SimpleMath">FG</span>-resolution <span class="SimpleMath">R</span> of the field <span class="SimpleMath">F</span> of <span class="SimpleMath">p</span> elements. It returns a pair whose first entry is a minimal list of homogeneous generators for the cohomology ring <span class="SimpleMath">A=H^∗(G, F)</span> modulo all elements in degree greater than <span class="SimpleMath">n</span>. The second entry of the pair is a function <strong class="button">deg</strong> which, when applied to a minimal generator, yields its degree. WARNING: the following rule must be applied when multiplying generators <span class="SimpleMath">x_i</span> together. Only products of the form <span class="SimpleMath">x_1*(x_2*(x_3*(x_4*...)))</span> with <span class="SimpleMath">deg(x_i) le deg(x_i+1)</span> should be computed (since the <span class="SimpleMath">x_i</span> belong to a structure constant algebra with only a partially defined structure constants table).</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
ModPCohomologyRing(R):: FreeResolution --&gt; SCAlgebra
</pre>


<pre class="normal">
ModPCohomologyRing(R,level):: FreeResolution, String --&gt; SCAlgebra
</pre>


<pre class="normal">
ModPCohomologyRing(G,n):: Group, Int --&gt; SCAlgebra
</pre>


<pre class="normal">
ModPCohomologyRing(G,n,level):: Group, Int, String --&gt; SCAlgebra
</pre>

<p>Inputs either a <span class="SimpleMath">p</span>-group <span class="SimpleMath">G</span> and positive integer <span class="SimpleMath">n</span>, or else <span class="SimpleMath">n</span> terms of a minimal <span class="SimpleMath">FG</span>-resolution <span class="SimpleMath">R</span> of the field <span class="SimpleMath">F</span> of <span class="SimpleMath">p</span> elements. It returns the cohomology ring <span class="SimpleMath">A=H^∗(G, F)</span> modulo all elements in degree greater than <span class="SimpleMath">n</span>. The ring is returned as a structure constant algebra <span class="SimpleMath">A</span>. The ring <span class="SimpleMath">A</span> is graded. It has a component <strong class="button">A!.degree(x)</strong> which is a function returning the degree of each (homogeneous) element <span class="SimpleMath">x</span> in <strong class="button">GeneratorsOfAlgebra(A)</strong>. An optional input variable <span class="SimpleMath">"level"</span> can be set to one of the strings <span class="SimpleMath">"medium"</span> or <span class="SimpleMath">"high"</span>. These settings determine parameters in the algorithm. The default setting is <span class="SimpleMath">"medium"</span>. When <span class="SimpleMath">"level"</span> is set to <span class="SimpleMath">"high"</span> the ring <span class="SimpleMath">A</span> is returned with a component <strong class="button">A!.niceBasis</strong>. This component is a pair <span class="SimpleMath">[Coeff,Bas]</span>. Here <span class="SimpleMath">Bas</span> is a list of integer lists; a "nice" basis for the vector space <span class="SimpleMath">A</span> can be constructed using the command <strong class="button">List(Bas,x-&gt;Product(List(x,i-&gt;Basis(A)[i]))</strong>. The coefficients of the canonical basis element <strong class="button">Basis(A)[i]</strong> are stored as <strong class="button">Coeff[i]</strong>. If the ring <span class="SimpleMath">A</span> is computed using the setting <span class="SimpleMath">"level"="medium"</span> then the component <strong class="button">A!.niceBasis</strong> can be added to <span class="SimpleMath">A</span> using the command <strong class="button">A:=ModPCohomologyRing\_part\_2(A)</strong>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
Mod2CohomologyRingPresentation(G):: Group --&gt; PresentedGradedAlgebra
</pre>


<pre class="normal">
Mod2CohomologyRingPresentation(G,n):: Group --&gt; PresentedGradedAlgebra
</pre>


<pre class="normal">
Mod2CohomologyRingPresentation(A):: Group --&gt; PresentedGradedAlgebra
</pre>


<pre class="normal">
Mod2CohomologyRingPresentation(R):: Group --&gt; PresentedGradedAlgebra
</pre>

<p>When applied to a finite <span class="SimpleMath">2</span>-group <span class="SimpleMath">G</span> this function returns a presentation for the mod-<span class="SimpleMath">2</span> cohomology ring <span class="SimpleMath">H^∗(G, F)</span>. The Lyndon-Hochschild-Serre spectral sequence is used to prove that the presentation is complete. When the function is applied to a <span class="SimpleMath">2</span>-group G and positive integer <span class="SimpleMath">n</span> the function first constructs <span class="SimpleMath">n+1</span> terms of a free <span class="SimpleMath">FG</span>-resolution <span class="SimpleMath">R</span>, then constructs the finite-dimensional graded algebra <span class="SimpleMath">A=H^(∗ le n)(G, F)</span>, and finally uses <span class="SimpleMath">A</span> to approximate a presentation for <span class="SimpleMath">H^*(G, F)</span>. For "sufficiently large" <span class="SimpleMath">n</span> the approximation will be a correct presentation for <span class="SimpleMath">H^∗(G, F)</span>. Alternatively, the function can be applied directly to either the resolution <span class="SimpleMath">R</span> or graded algebra <span class="SimpleMath">A</span>. This function was written by Paul Smith. It uses the Singular commutative algebra package to handle the Lyndon-Hochschild-Serre spectral sequence.</p>

</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>Group Invariants</p>

<div class="pcenter"><table cellspacing="10"  class="GAPDocTable">
<tr>
<td class="tdleft">
<pre class="normal">
GroupCohomology(G,k):: Group, Int --&gt; List
</pre>


<pre class="normal">
GroupCohomology(G,k,p):: Group, Int, Int --&gt; List
</pre>

<p>Inputs a group <span class="SimpleMath">G</span> and integer <span class="SimpleMath">k ge 0</span>. The group <span class="SimpleMath">G</span> should either be finite or else lie in one of a range of classes of infinite groups (such as nilpotent, crystallographic, Artin etc.). The function returns the list of abelian invariants of <span class="SimpleMath">H^k(G, Z)</span>.</p>

<p>If a prime <span class="SimpleMath">p</span> is given as an optional third input variable then the function returns the list of abelian invariants of <span class="SimpleMath">H^k(G, Z_p)</span>. In this case each abelian invariant will be equal to <span class="SimpleMath">p</span> and the length of the list will be the dimension of the vector space <span class="SimpleMath">H^k(G, Z_p)</span>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
GroupHomology(G,k):: Group, Int --&gt; List
</pre>


<pre class="normal">
GroupHomology(G,k,p):: Group, Int, Int --&gt; List
</pre>

<p>Inputs a group <span class="SimpleMath">G</span> and integer <span class="SimpleMath">k ge 0</span>. The group <span class="SimpleMath">G</span> should either be finite or else lie in one of a range of classes of infinite groups (such as nilpotent, crystallographic, Artin etc.). The function returns the list of abelian invariants of <span class="SimpleMath">H_k(G, Z)</span>.</p>

<p>If a prime <span class="SimpleMath">p</span> is given as an optional third input variable then the function returns the list of abelian invariants of <span class="SimpleMath">H_k(G, Z_p)</span>. In this case each abelian invariant will be equal to <span class="SimpleMath">p</span> and the length of the list will be the dimension of the vector space <span class="SimpleMath">H_k(G, Z_p)</span>.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
PrimePartDerivedFunctor(G,R,A,k):: Group, FreeResolution, Function, Int --&gt; List
</pre>

<p>Inputs a group <span class="SimpleMath">G</span>, an integer <span class="SimpleMath">k ge 0</span>, at least <span class="SimpleMath">k+1</span> terms of a free <span class="SimpleMath">ZP</span>-resolution of <span class="SimpleMath">Z</span> for <span class="SimpleMath">P</span> a Sylow <span class="SimpleMath">p</span>-subgroup of <span class="SimpleMath">G</span>. A function such as <strong class="button">A=TensorWithIntegers</strong> is also entered. The abelian invariants of the <span class="SimpleMath">p</span>-primary part <span class="SimpleMath">H_k(G,A)_(p)</span> of the homology with coefficients in <span class="SimpleMath">A</span> is returned.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
PoincareSeries(G,n):: Group, Int --&gt; RationalFunction
</pre>


<pre class="normal">
PoincareSeries(G):: Group --&gt; RationalFunction
</pre>


<pre class="normal">
PoincareSeries(R,n):: Group, Int --&gt; RationalFunction
</pre>


<pre class="normal">
PoincareSeries(L,n):: Group, Int --&gt; RationalFunction
</pre>

<p>Inputs a finite <span class="SimpleMath">p</span>-group <span class="SimpleMath">G</span> and a positive integer <span class="SimpleMath">n</span>. It returns a quotient of polynomials <span class="SimpleMath">f(x)=P(x)/Q(x)</span> whose expansion has coefficient of <span class="SimpleMath">x^k</span> equal to the rank of the vector space <span class="SimpleMath">H_k(G, F_p)</span> for all <span class="SimpleMath">k</span> in the range <span class="SimpleMath">1 le k le n</span>. (The second input variable can be omitted, in which case the function tries to choose a `reasonable' value for <span class="SimpleMath">n</span>. For 2-groups the function <strong class="button">PoincareSeriesLHS(G)</strong> can be used to produce an <span class="SimpleMath">f(x)</span> that is correct in all degrees.) In place of the group <span class="SimpleMath">G</span> the function can also input (at least <span class="SimpleMath">n</span> terms of) a minimal mod-<span class="SimpleMath">p</span> resolution <span class="SimpleMath">R</span> for <span class="SimpleMath">G</span>. Alternatively, the first input variable can be a list <span class="SimpleMath">L</span> of integers. In this case the coefficient of <span class="SimpleMath">x^k</span> in <span class="SimpleMath">f(x)</span> is equal to the <span class="SimpleMath">(k+1)</span>st term in the list.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
PoincareSeries(G,n):: Group, Int --&gt; RationalFunction
</pre>


<pre class="normal">
PoincareSeries(G):: Group --&gt; RationalFunction
</pre>


<pre class="normal">
PoincareSeries(R,n):: Group, Int --&gt; RationalFunction
</pre>


<pre class="normal">
PoincareSeries(L,n):: Group, Int --&gt; RationalFunction
</pre>

<p>Inputs a finite <span class="SimpleMath">p</span>-group <span class="SimpleMath">G</span> and a positive integer <span class="SimpleMath">n</span>. It returns a quotient of polynomials <span class="SimpleMath">f(x)=P(x)/Q(x)</span> whose expansion has coefficient of <span class="SimpleMath">x^k</span> equal to the rank of the vector space <span class="SimpleMath">H_k(G, F_p)</span> for all <span class="SimpleMath">k</span> in the range <span class="SimpleMath">1 le k le n</span>. (The second input variable can be omitted, in which case the function tries to choose a `reasonable' value for <span class="SimpleMath">n</span>. For 2-groups the function <strong class="button">PoincareSeriesLHS(G)</strong> can be used to produce an <span class="SimpleMath">f(x)</span> that is correct in all degrees.) In place of the group <span class="SimpleMath">G</span> the function can also input (at least <span class="SimpleMath">n</span> terms of) a minimal mod-<span class="SimpleMath">p</span> resolution <span class="SimpleMath">R</span> for <span class="SimpleMath">G</span>. Alternatively, the first input variable can be a list <span class="SimpleMath">L</span> of integers. In this case the coefficient of <span class="SimpleMath">x^k</span> in <span class="SimpleMath">f(x)</span> is equal to the <span class="SimpleMath">(k+1)</span>st term in the list.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
RankHomologyPGroup(G,P,n):: Group, RationalFunction, Int --&gt; Int
</pre>

<p>Inputs a <span class="SimpleMath">p</span>-group <span class="SimpleMath">G</span>, a rational function <span class="SimpleMath">P</span> representing the Poincar\'e series of the mod-<span class="SimpleMath">p</span> cohomology of <span class="SimpleMath">G</span> and a positive integer <span class="SimpleMath">n</span>. It returns the minimum number of generators for the finite abelian <span class="SimpleMath">p</span>-group <span class="SimpleMath">H_nG, Z)</span>.</p>

</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><span class="SimpleMath">F_p</span>-modules</p>

<div class="pcenter"><table cellspacing="10"  class="GAPDocTable">
<tr>
<td class="tdleft">
<pre class="normal">
GroupAlgebraAsFpGModule:: Group --&gt; FpGModule
</pre>

<p>Inputs a finite <span class="SimpleMath">p</span>-group <span class="SimpleMath">G</span> and returns the modular group algebra <span class="SimpleMath">F_pG</span> in the form of an <span class="SimpleMath">F_pG</span>-module.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
Radical:: FpGModule --&gt; FpGModule
</pre>

<p>Inputs an <span class="SimpleMath">F_pG</span>-module and returns its radical.</p>

</td>
</tr>
<tr>
<td class="tdleft">
<pre class="normal">
RadicalSeries(M):: FpGModule --&gt; List
</pre>


<pre class="normal">
RadicalSeries(R):: Resolution --&gt; FilteredSparseChainComplex
</pre>

<p>Inputs an <span class="SimpleMath">F_pG</span>-module <span class="SimpleMath">M</span> and returns its radical series as a list of <span class="SimpleMath">F_pG</span>-modules.</p>

<p>Inputs a free <span class="SimpleMath">F_pG</span>-resolution R and returns the filtered chain complex <span class="SimpleMath">⋯ Rad_2( F_pG)R le Rad_1( F_pG)R le R</span>.</p>

</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chap16.html">16</a>  <a href="chap17.html">17</a>  <a href="chap18.html">18</a>  <a href="chap19.html">19</a>  <a href="chap20.html">20</a>  <a href="chap21.html">21</a>  <a href="chap22.html">22</a>  <a href="chap23.html">23</a>  <a href="chap24.html">24</a>  <a href="chap25.html">25</a>  <a href="chap26.html">26</a>  <a href="chap27.html">27</a>  <a href="chap28.html">28</a>  <a href="chap29.html">29</a>  <a href="chap30.html">30</a>  <a href="chap31.html">31</a>  <a href="chap32.html">32</a>  <a href="chap33.html">33</a>  <a href="chap34.html">34</a>  <a href="chap35.html">35</a>  <a href="chap36.html">36</a>  <a href="chap37.html">37</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
